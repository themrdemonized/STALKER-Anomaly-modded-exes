diff --git a/src/Include/xrRender/RenderVisual.h b/src/Include/xrRender/RenderVisual.h
index 94bc87e..a31273a 100644
--- a/src/Include/xrRender/RenderVisual.h
+++ b/src/Include/xrRender/RenderVisual.h
@@ -25,6 +25,10 @@ public:
 	virtual shared_str	_BCL	getDebugName() = 0;
 #endif
 
+	//--DSR-- HeatVision_start
+	virtual void MarkAsHot(bool is_hot) {};
+	//--DSR-- HeatVision_end
+
 	virtual IKinematics* _BCL dcast_PKinematics() { return 0; }
 	virtual IKinematicsAnimated* dcast_PKinematicsAnimated() { return 0; }
 	virtual IParticleCustom* dcast_ParticleCustom() { return 0; }
diff --git a/src/Layers/xrRender/Blender_BmmD.cpp b/src/Layers/xrRender/Blender_BmmD.cpp
index 02e36cb..381d9ec 100644
--- a/src/Layers/xrRender/Blender_BmmD.cpp
+++ b/src/Layers/xrRender/Blender_BmmD.cpp
@@ -257,6 +257,11 @@ void CBlender_BmmD::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_dn_b", strconcat(sizeof(mask), mask, oB_Name, "_bump"));
 		C.r_dx10Texture("s_dn_a", strconcat(sizeof(mask), mask, oA_Name, "_bump"));
 
+		C.r_dx10Texture("s_puddles_normal", "fx\\water_normal");
+		C.r_dx10Texture("s_puddles_perlin", "fx\\puddles_perlin");
+		C.r_dx10Texture("s_puddles_mask", strconcat(sizeof(mask), mask, C.L_textures[0].c_str(), "_puddles_mask"));
+		C.r_dx10Texture("s_rainsplash", "fx\\water_sbumpvolume");
+
 		C.r_dx10Sampler("smp_base");
 		C.r_dx10Sampler("smp_linear");
 
diff --git a/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp b/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp
index 5035624..6d370c4 100644
--- a/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp
+++ b/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp
@@ -258,9 +258,26 @@ class cl_eye_P : public R_constant_setup
 		RCache.set_c(C, V.x, V.y, V.z, 1);
 	}
 };
-
 static cl_eye_P binder_eye_P;
 
+// interpolated eye position (crookr scope parallax)
+// We can improve this by clamping the magnitude of the travel here instead of in-shader. 
+// it would fix the issue with the fog "sticking" when moving too far off center
+extern float scope_fog_interp;
+extern float scope_fog_travel;
+class cl_eye_PL : public R_constant_setup
+{
+	Fvector tV;
+	virtual void setup(R_constant* C)
+	{
+		Fvector& V = RDEVICE.vCameraPosition;
+		tV = tV.lerp(tV, V, scope_fog_interp);
+
+		RCache.set_c(C, tV.x, tV.y, tV.z, 1);
+	}
+};
+static cl_eye_PL binder_eye_PL;
+
 // eye-params
 class cl_eye_D : public R_constant_setup
 {
@@ -270,9 +287,22 @@ class cl_eye_D : public R_constant_setup
 		RCache.set_c(C, V.x, V.y, V.z, 0);
 	}
 };
-
 static cl_eye_D binder_eye_D;
 
+// interpolated eye direction (crookr scope parallax)
+class cl_eye_DL : public R_constant_setup
+{
+	Fvector tV;
+	virtual void setup(R_constant* C)
+	{
+		Fvector& V = RDEVICE.vCameraDirection;
+		tV = tV.lerp(tV, V, scope_fog_interp);
+
+		RCache.set_c(C, tV.x, tV.y, tV.z, 0);
+	}
+};
+static cl_eye_DL binder_eye_DL;
+
 // eye-params
 class cl_eye_N : public R_constant_setup
 {
@@ -285,6 +315,97 @@ class cl_eye_N : public R_constant_setup
 
 static cl_eye_N binder_eye_N;
 
+
+// fake scope params (crookr)
+extern float scope_outerblur;
+extern float scope_innerblur;
+extern float scope_scrollpower;
+extern float scope_brightness;
+class cl_fakescope_params : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, scope_scrollpower, scope_innerblur, scope_outerblur, scope_brightness);
+	}
+};
+static cl_fakescope_params binder_fakescope_params;
+
+extern float scope_ca;
+extern float scope_fog_attack;
+extern float scope_fog_mattack;
+//extern float scope_fog_travel;
+class cl_fakescope_ca : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, scope_ca, scope_fog_attack, scope_fog_mattack, scope_fog_travel);
+	}
+};
+static cl_fakescope_ca binder_fakescope_ca;
+
+extern float scope_radius;
+extern float scope_fog_radius;
+extern float scope_fog_sharp;
+//extern float scope_drift_amount;
+class cl_fakescope_params3 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, scope_radius, scope_fog_radius, scope_fog_sharp, 0.0f);
+	}
+};
+static cl_fakescope_params3 binder_fakescope_params3;
+
+//--DSR-- HeatVision_start
+extern float heat_vision_mode;
+extern Fvector4 heat_vision_steps;
+extern Fvector4 heat_vision_blurring;
+extern Fvector4 heat_vision_args_1;
+extern Fvector4 heat_vision_args_2;
+
+static class cl_heatvision_hotness : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.hemi.set_c_hotness(C);
+	}
+} binder_heatvision_hotness;
+
+static class cl_heatvision_steps : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_r2_heatvision, heat_vision_steps.x, heat_vision_steps.y, heat_vision_steps.z);
+	}
+} binder_heatvision_params1;
+
+static class cl_heatvision_blurring : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, heat_vision_blurring.x, heat_vision_blurring.y, heat_vision_blurring.z, heat_vision_mode);
+	}
+} binder_heatvision_params2;
+
+static class cl_heatvision_args1 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, heat_vision_args_1.x, heat_vision_args_1.y, heat_vision_args_1.z, heat_vision_args_1.w);
+	}
+} binder_heatvision_args1;
+
+static class cl_heatvision_args2 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, heat_vision_args_2.x, heat_vision_args_2.y, heat_vision_args_2.z, heat_vision_args_2.w);
+	}
+} binder_heatvision_args2;
+
+//--DSR-- HeatVision_end
+
+
 #ifndef _EDITOR
 // D-Light0
 class cl_sun0_color : public R_constant_setup
@@ -384,6 +505,23 @@ class cl_hemi_color : public R_constant_setup
 };
 
 static cl_hemi_color binder_hemi_color;
+
+class cl_sky_color : public R_constant_setup
+{
+	u32 marker;
+	Fvector4 result;
+
+	virtual void setup(R_constant* C)
+	{
+		if (marker != Device.dwFrame)
+		{
+			CEnvDescriptor& desc = *g_pGamePersistent->Environment().CurrentEnv;
+			result.set(desc.sky_color.x, desc.sky_color.y, desc.sky_color.z, desc.sky_rotation);
+		}
+		RCache.set_c(C, result);
+	}
+};
+static cl_sky_color binder_sky_color;
 #endif
 
 static class cl_screen_res : public R_constant_setup
@@ -521,6 +659,10 @@ static class cl_near_far_plane : public R_constant_setup
 	}
 } binder_near_far_plane;
 
+// Screen Space Shaders Stuff
+extern Fvector4 ps_ssfx_wpn_dof_1;
+extern float ps_ssfx_wpn_dof_2;
+
 //Sneaky debug stuff
 extern Fvector4 ps_dev_param_1;
 extern Fvector4 ps_dev_param_2;
@@ -595,6 +737,22 @@ static class dev_param_8 : public R_constant_setup
 	}
 }    dev_param_8;
 
+static class ssfx_wpn_dof_1 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_wpn_dof_1.x, ps_ssfx_wpn_dof_1.y, ps_ssfx_wpn_dof_1.z, ps_ssfx_wpn_dof_1.w);
+	}
+}    ssfx_wpn_dof_1;
+
+static class ssfx_wpn_dof_2 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_wpn_dof_2, 0, 0, 0);
+	}
+}    ssfx_wpn_dof_2;
+
 // Standart constant-binding
 void CBlender_Compile::SetMapping()
 {
@@ -639,7 +797,9 @@ void CBlender_Compile::SetMapping()
 
 	// eye-params
 	r_Constant("eye_position", &binder_eye_P);
+	r_Constant("eye_position_lerp", &binder_eye_PL); // crookr
 	r_Constant("eye_direction", &binder_eye_D);
+	r_Constant("eye_direction_lerp", &binder_eye_DL); // crookr
 	r_Constant("eye_normal", &binder_eye_N);
 
 #ifndef _EDITOR
@@ -680,6 +840,11 @@ void CBlender_Compile::SetMapping()
 	// PDA
 	r_Constant("pda_params", &binder_pda_params);
 
+	// Screen Space Shaders
+	r_Constant("sky_color", &binder_sky_color);
+	r_Constant("ssfx_wpn_dof_1", &ssfx_wpn_dof_1);
+	r_Constant("ssfx_wpn_dof_2", &ssfx_wpn_dof_2);
+
 	// Shader stuff
 	r_Constant("shader_param_1", &dev_param_1);
 	r_Constant("shader_param_2", &dev_param_2);
@@ -690,10 +855,23 @@ void CBlender_Compile::SetMapping()
 	r_Constant("shader_param_7", &dev_param_7);
 	r_Constant("shader_param_8", &dev_param_8);
 
+	// crookr
+	r_Constant("fakescope_params1", &binder_fakescope_params);
+	r_Constant("fakescope_params2", &binder_fakescope_ca);
+	r_Constant("fakescope_params3", &binder_fakescope_params3);
+
 	// other common
 	for (u32 it = 0; it < DEV->v_constant_setup.size(); it++)
 	{
 		std::pair<shared_str, R_constant_setup*> cs = DEV->v_constant_setup[it];
 		r_Constant(*cs.first, cs.second);
 	}
+
+	//--DSR-- HeatVision_start
+	r_Constant("L_hotness", &binder_heatvision_hotness);
+	r_Constant("heatvision_params1", &binder_heatvision_params1);
+	r_Constant("heatvision_params2", &binder_heatvision_params2);
+	r_Constant("heatvision_params3", &binder_heatvision_args1);
+	r_Constant("heatvision_params4", &binder_heatvision_args2);
+	//--DSR-- HeatVision_end
 }
diff --git a/src/Layers/xrRender/Blender_tree.cpp b/src/Layers/xrRender/Blender_tree.cpp
index 7a8b831..234bee3 100644
--- a/src/Layers/xrRender/Blender_tree.cpp
+++ b/src/Layers/xrRender/Blender_tree.cpp
@@ -216,6 +216,11 @@ void CBlender_Tree::Compile(CBlender_Compile& C)
 	switch (C.iElement)
 	{
 	case SE_R2_NORMAL_HQ: // deffer
+
+		// Is a branch/bush. Use a different VS
+		if (oBlend.value)
+			tvs = "tree_branch";
+
 		if (bUseATOC)
 		{
 			uber_deffer(C, true, tvs, "base_atoc", oBlend.value, 0, true);
diff --git a/src/Layers/xrRender/DetailManager.cpp b/src/Layers/xrRender/DetailManager.cpp
index 7d63982..bf1f074 100644
--- a/src/Layers/xrRender/DetailManager.cpp
+++ b/src/Layers/xrRender/DetailManager.cpp
@@ -292,7 +292,7 @@ void CDetailManager::UpdateVisibleM()
 				continue;
 			}
 			u32 mask = 0xff;
-			u32 res = View.testSAABB(MS.vis.sphere.P, MS.vis.sphere.R, MS.vis.box.data(), mask);
+			u32 res = View.testSphere(MS.vis.sphere.P, MS.vis.sphere.R, mask);
 			if (fcvNone == res)
 			{
 				continue; // invisible-view frustum
@@ -319,7 +319,7 @@ void CDetailManager::UpdateVisibleM()
 				if (fcvPartial == res)
 				{
 					u32 _mask = mask;
-					u32 _res = View.testSAABB(S.vis.sphere.P, S.vis.sphere.R, S.vis.box.data(), _mask);
+					u32 _res = View.testSphere(S.vis.sphere.P, S.vis.sphere.R, _mask);
 					if (fcvNone == _res)
 					{
 						continue; // invisible-view frustum
@@ -370,7 +370,9 @@ void CDetailManager::UpdateVisibleM()
 							if (ssa > r_ssaCHEAP) vis_id = Item.vis_ID;
 
 							sp.r_items[vis_id].push_back(*siIT);
-
+							
+							Item.distance = dist_sq;
+							Item.position = S.vis.sphere.P;
 							//2							visible[vis_id][sp.id].push_back(&Item);
 						}
 					}
@@ -458,3 +460,27 @@ void __stdcall CDetailManager::MT_CALC()
 		}
 	MT.Leave();
 }
+
+void CDetailManager::details_clear()
+{
+	// Disable fade, next render will be scene
+	fade_distance = 99999;
+
+	if (ps_ssfx_grass_shadows.x <= 0)
+		return;
+
+	for (u32 x = 0; x < 3; x++)
+	{
+		vis_list& list = m_visibles[x];
+
+		for (u32 O = 0; O < objects.size(); O++)
+		{
+			CDetail& Object = *objects[O];
+			xr_vector<SlotItemVec*>& vis = list[O];
+			if (!vis.empty())
+			{
+				vis.clear_not_free();
+			}
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/Layers/xrRender/DetailManager.h b/src/Layers/xrRender/DetailManager.h
index 5851f93..95da475 100644
--- a/src/Layers/xrRender/DetailManager.h
+++ b/src/Layers/xrRender/DetailManager.h
@@ -64,6 +64,12 @@ const float		dm_fade = float(2 * dm_size) - .5f;
 class ECORE_API CDetailManager
 {
 public:
+
+	float fade_distance = 99999;
+	Fvector light_position;
+
+	void details_clear();
+
 	struct SlotItem
 	{
 		// один кустик
@@ -73,6 +79,8 @@ public:
 		u32 vis_ID; // индекс в visibility списке он же тип [не качается, качается1, качается2]
 		float c_hemi;
 		float c_sun;
+		float distance;
+		Fvector position;
 #if RENDER==R_R1
 		Fvector c_rgb;
 #endif
diff --git a/src/Layers/xrRender/FBasicVisual.cpp b/src/Layers/xrRender/FBasicVisual.cpp
index f8e4651..ba1455a 100644
--- a/src/Layers/xrRender/FBasicVisual.cpp
+++ b/src/Layers/xrRender/FBasicVisual.cpp
@@ -11,6 +11,7 @@
 
 #include "fbasicvisual.h"
 #include "../../xrEngine/fmesh.h"
+#include "dxRenderDeviceRender.h"
 
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
@@ -76,6 +77,21 @@ void dxRender_Visual::Load(const char* N, IReader* data, u32)
 #endif
 }
 
+//--DSR-- HeatVision_start
+void dxRender_Visual::MarkAsHot(bool is_hot) {
+	Shader* s = shader._get();
+	if (0 == s) return;
+	ShaderElement* e = s->E[0]._get();
+	if (0 == e || e->passes.empty()) return;
+	SPass* p = e->passes[0]._get();
+	STextureList* l = p->T._get();
+	if (0 == l || l->empty()) return;
+	CTexture* t = l->at(0).second._get();
+	if (t)
+		t->m_is_hot = is_hot;
+}
+//--DSR-- HeatVision_end
+
 #define PCOPY(a)	a = pFrom->a
 
 void dxRender_Visual::Copy(dxRender_Visual* pFrom)
diff --git a/src/Layers/xrRender/FBasicVisual.h b/src/Layers/xrRender/FBasicVisual.h
index 666dccc..aad4252 100644
--- a/src/Layers/xrRender/FBasicVisual.h
+++ b/src/Layers/xrRender/FBasicVisual.h
@@ -77,6 +77,10 @@ public:
 
 	virtual vis_data& _BCL getVisData() { return vis; }
 	virtual u32 getType() { return Type; }
+	
+	//--DSR-- HeatVision_start
+	virtual void MarkAsHot(bool is_hot);
+	//--DSR-- HeatVision_end
 
 	dxRender_Visual();
 	virtual ~dxRender_Visual();
diff --git a/src/Layers/xrRender/FHierrarhyVisual.cpp b/src/Layers/xrRender/FHierrarhyVisual.cpp
index c5b821a..68dacdc 100644
--- a/src/Layers/xrRender/FHierrarhyVisual.cpp
+++ b/src/Layers/xrRender/FHierrarhyVisual.cpp
@@ -90,6 +90,15 @@ void FHierrarhyVisual::Load(const char* N, IReader* data, u32 dwFlags)
 	}
 }
 
+//--DSR-- HeatVision_start
+void FHierrarhyVisual::MarkAsHot(bool is_hot) 
+{
+	dxRender_Visual::MarkAsHot(is_hot);
+	for (u32 i = 0; i < children.size(); i++)
+		children[i]->MarkAsHot(is_hot);
+}
+//--DSR-- HeatVision_end
+
 void FHierrarhyVisual::Copy(dxRender_Visual* pSrc)
 {
 	dxRender_Visual::Copy(pSrc);
diff --git a/src/Layers/xrRender/FHierrarhyVisual.h b/src/Layers/xrRender/FHierrarhyVisual.h
index 5f20c61..960ffe0 100644
--- a/src/Layers/xrRender/FHierrarhyVisual.h
+++ b/src/Layers/xrRender/FHierrarhyVisual.h
@@ -21,6 +21,10 @@ public:
 	virtual void Load(const char* N, IReader* data, u32 dwFlags);
 	virtual void Copy(dxRender_Visual* pFrom);
 	virtual void Release();
+
+	//--DSR-- HeatVision_start
+	virtual void MarkAsHot(bool is_hot);
+	//--DSR-- HeatVision_end
 };
 
 #endif //FHierrarhyVisualH
diff --git a/src/Layers/xrRender/FTreeVisual.cpp b/src/Layers/xrRender/FTreeVisual.cpp
index 0489ef7..ae734d7 100644
--- a/src/Layers/xrRender/FTreeVisual.cpp
+++ b/src/Layers/xrRender/FTreeVisual.cpp
@@ -19,6 +19,9 @@ shared_str c_c_bias;
 shared_str c_c_scale;
 shared_str c_c_sun;
 
+shared_str c_c_BendersPos;
+shared_str c_c_BendersSetup;
+
 FTreeVisual::FTreeVisual(void)
 {
 }
@@ -91,6 +94,9 @@ void FTreeVisual::Load(const char* N, IReader* data, u32 dwFlags)
 	c_c_bias = "c_bias";
 	c_c_scale = "c_scale";
 	c_c_sun = "c_sun";
+
+	c_c_BendersPos = "benders_pos";
+	c_c_BendersSetup = "benders_setup";
 }
 
 struct FTreeVisual_setup
@@ -160,6 +166,47 @@ void FTreeVisual::Render(float LOD)
 	                       s * c_bias.rgb.z + desc.ambient.z, s * c_bias.hemi); // bias
 #endif
 	RCache.tree.set_c_sun(s * c_scale.sun, s * c_bias.sun, 0, 0); // sun
+
+#if RENDER==R_R4 || RENDER==R_R3
+
+	if (ps_ssfx_grass_interactive.y > 0)
+	{
+		// Inter grass Settings
+		RCache.set_c(c_c_BendersSetup, ps_ssfx_int_grass_params_1);
+
+		// Grass benders data ( Player + Characters )
+		IGame_Persistent::grass_data& GData = g_pGamePersistent->grass_shader_data;
+		Fvector4 player_pos = { 0, 0, 0, 0 };
+		int BendersQty = _min(16, ps_ssfx_grass_interactive.y + 1);
+
+		// Add Player?
+		if (ps_ssfx_grass_interactive.x > 0)
+		{
+			player_pos.set(Device.vCameraPosition.x, Device.vCameraPosition.y, Device.vCameraPosition.z, -1);
+		}
+
+		Fvector4* c_grass;
+		{
+			void* GrassData;
+			RCache.get_ConstantDirect(c_c_BendersPos, BendersQty * sizeof(Fvector4), &GrassData, 0, 0);
+
+			c_grass = (Fvector4*)GrassData;
+		}
+		VERIFY(c_grass);
+
+		if (c_grass)
+		{
+			c_grass[0].set(player_pos);
+			c_grass[16].set(0.0f, -99.0f, 0.0f, 1.0f);
+
+			for (int Bend = 1; Bend < BendersQty; Bend++)
+			{
+				c_grass[Bend].set(GData.pos[Bend].x, GData.pos[Bend].y, GData.pos[Bend].z, GData.radius_curr[Bend]);
+				c_grass[Bend + 16].set(GData.dir[Bend].x, GData.dir[Bend].y, GData.dir[Bend].z, GData.str[Bend]);
+			}
+		}
+	}
+#endif
 }
 
 #define PCOPY(a)	a = pFrom->a
diff --git a/src/Layers/xrRender/ParticleEffect.cpp b/src/Layers/xrRender/ParticleEffect.cpp
index 872ed30..52f4d32 100644
--- a/src/Layers/xrRender/ParticleEffect.cpp
+++ b/src/Layers/xrRender/ParticleEffect.cpp
@@ -12,9 +12,6 @@
 using namespace PAPI;
 using namespace PS;
 
-const u32 PS::uDT_STEP = 33;
-const float PS::fDT_STEP = float(uDT_STEP) / 1000.f;
-
 static void ApplyTexgen(const Fmatrix& mVP)
 {
 	Fmatrix mTexgen;
@@ -135,6 +132,8 @@ void CParticleEffect::OnFrame(u32 frame_dt)
 		m_MemDT += frame_dt;
 
 		int StepCount = 0;
+		u32 uDT_STEP = m_Def->GetUStep();
+		float fDT_STEP = m_Def->GetFStep();
 		if (m_MemDT >= uDT_STEP)
 		{
 			// allow maximum of three steps (99ms) to avoid slowdown after loading
@@ -507,11 +506,11 @@ void ParticleRenderStream(FVF::LIT* pv, u32 count, PAPI::Particle * particles, C
 						Fvector p;
 						pPE->m_XFORM.transform_tiny(p, m.pos);
 						M.mulA_43(pPE->m_XFORM);
-						FillSprite(pv, M.k, M.i, p, lt, rb, r_x, r_y, m.color, sina, cosa);
+						FillSprite(pv, M.k, M.i, p, lt, rb, r_x, r_y, color_rgba_f(m.colorR, m.colorG, m.colorB, m.colorA), sina, cosa);
 					}
 					else
 					{
-						FillSprite(pv, M.k, M.i, m.pos, lt, rb, r_x, r_y, m.color, sina, cosa);
+						FillSprite(pv, M.k, M.i, m.pos, lt, rb, r_x, r_y, color_rgba_f(m.colorR, m.colorG, m.colorB, m.colorA), sina, cosa);
 					}
 				}
 				else if ((speed >= EPS_S) && pPE->m_Def->m_Flags.is(CPEDef::dfFaceAlign))
@@ -531,11 +530,11 @@ void ParticleRenderStream(FVF::LIT* pv, u32 count, PAPI::Particle * particles, C
 						Fvector p;
 						pPE->m_XFORM.transform_tiny(p, m.pos);
 						M.mulA_43(pPE->m_XFORM);
-						FillSprite(pv, M.j, M.i, p, lt, rb, r_x, r_y, m.color, sina, cosa);
+						FillSprite(pv, M.j, M.i, p, lt, rb, r_x, r_y, color_rgba_f(m.colorR, m.colorG, m.colorB, m.colorA), sina, cosa);
 					}
 					else
 					{
-						FillSprite(pv, M.j, M.i, m.pos, lt, rb, r_x, r_y, m.color, sina, cosa);
+						FillSprite(pv, M.j, M.i, m.pos, lt, rb, r_x, r_y, color_rgba_f(m.colorR, m.colorG, m.colorB, m.colorA), sina, cosa);
 					}
 				}
 				else
@@ -550,11 +549,11 @@ void ParticleRenderStream(FVF::LIT* pv, u32 count, PAPI::Particle * particles, C
 						Fvector p, d;
 						pPE->m_XFORM.transform_tiny(p, m.pos);
 						pPE->m_XFORM.transform_dir(d, dir);
-						FillSprite(pv, p, d, lt, rb, r_x, r_y, m.color, sina, cosa);
+						FillSprite(pv, p, d, lt, rb, r_x, r_y, color_rgba_f(m.colorR, m.colorG, m.colorB, m.colorA), sina, cosa);
 					}
 					else
 					{
-						FillSprite(pv, m.pos, dir, lt, rb, r_x, r_y, m.color, sina, cosa);
+						FillSprite(pv, m.pos, dir, lt, rb, r_x, r_y, color_rgba_f(m.colorR, m.colorG, m.colorB, m.colorA), sina, cosa);
 					}
 				}
 			}
@@ -564,11 +563,11 @@ void ParticleRenderStream(FVF::LIT* pv, u32 count, PAPI::Particle * particles, C
 				{
 					Fvector p;
 					pPE->m_XFORM.transform_tiny(p, m.pos);
-					FillSprite(pv, RDEVICE.vCameraTop, RDEVICE.vCameraRight, p, lt, rb, r_x, r_y, m.color, sina, cosa);
+					FillSprite(pv, RDEVICE.vCameraTop, RDEVICE.vCameraRight, p, lt, rb, r_x, r_y, color_rgba_f(m.colorR, m.colorG, m.colorB, m.colorA), sina, cosa);
 				}
 				else
 				{
-					FillSprite(pv, RDEVICE.vCameraTop, RDEVICE.vCameraRight, m.pos, lt, rb, r_x, r_y, m.color, sina, cosa);
+					FillSprite(pv, RDEVICE.vCameraTop, RDEVICE.vCameraRight, m.pos, lt, rb, r_x, r_y, color_rgba_f(m.colorR, m.colorG, m.colorB, m.colorA), sina, cosa);
 				}
 			}
 		}
diff --git a/src/Layers/xrRender/ParticleEffect.h b/src/Layers/xrRender/ParticleEffect.h
index 26fc1c9..5c69ff6 100644
--- a/src/Layers/xrRender/ParticleEffect.h
+++ b/src/Layers/xrRender/ParticleEffect.h
@@ -98,9 +98,6 @@ namespace PS
 
 	void OnEffectParticleBirth(void* owner, u32 param, PAPI::Particle& m, u32 idx);
 	void OnEffectParticleDead(void* owner, u32 param, PAPI::Particle& m, u32 idx);
-
-	extern const u32 uDT_STEP;
-	extern const float fDT_STEP;
 }
 
 //---------------------------------------------------------------------------
diff --git a/src/Layers/xrRender/ParticleEffectDef.cpp b/src/Layers/xrRender/ParticleEffectDef.cpp
index 81eaad4..eecfb0b 100644
--- a/src/Layers/xrRender/ParticleEffectDef.cpp
+++ b/src/Layers/xrRender/ParticleEffectDef.cpp
@@ -15,12 +15,16 @@
 using namespace PAPI;
 using namespace PS;
 
+extern float ps_particle_update_coeff;
+
 //------------------------------------------------------------------------------
 // class CParticleEffectDef
 //------------------------------------------------------------------------------
 CPEDef::CPEDef()
 {
 	m_Frame.InitDefault();
+	m_uStep = 33;
+	m_fStep = float(m_uStep) / 1000.f;
 	m_MaxParticles = 0;
 	m_CachedShader = 0;
 	m_fTimeLimit = 0.f;
@@ -43,6 +47,16 @@ CPEDef::~CPEDef()
 #endif
 }
 
+u32 CPEDef::GetUStep()
+{
+	return m_uStep * ps_particle_update_coeff;
+}
+
+float CPEDef::GetFStep()
+{
+	return m_fStep * ps_particle_update_coeff;
+}
+
 void CPEDef::CreateShader()
 {
 	if (*m_ShaderName && *m_TextureName)
@@ -283,6 +297,11 @@ BOOL CPEDef::Load(IReader& F)
 BOOL CPEDef::Load2(CInifile& ini)
 {
 	//.	u16 version		= ini.r_u16("_effect", "version");
+	if (ini.line_exist("_effect", "update_step")) 
+	{
+		m_uStep = ini.r_u32("_effect", "update_step");
+		m_fStep = float(m_uStep) / 1000.f;
+	}
 	m_MaxParticles = ini.r_u32("_effect", "max_particles");
 	m_Flags.assign(ini.r_u32("_effect", "flags"));
 
diff --git a/src/Layers/xrRender/ParticleEffectDef.h b/src/Layers/xrRender/ParticleEffectDef.h
index 4ca68bf..1099d65 100644
--- a/src/Layers/xrRender/ParticleEffectDef.h
+++ b/src/Layers/xrRender/ParticleEffectDef.h
@@ -85,7 +85,9 @@ namespace PS
 		SFrame m_Frame;
 		// compiled actions
 		CMemoryWriter m_Actions;
-		// def        
+		// def
+		u32 m_uStep;		// update rate of this effect in ms
+		float m_fStep;		// update rate of this effect in s
 		float m_fTimeLimit; // time limit
 		int m_MaxParticles; // max particle count
 		Fvector m_VelocityScale; // velocity scale
@@ -105,6 +107,9 @@ namespace PS
 		CPEDef();
 		~CPEDef();
 
+		u32 GetUStep();
+		float GetFStep();
+
 		void SetName(LPCSTR name);
 		IC LPCSTR Name() const { return *m_Name; }
 		void CreateShader();
diff --git a/src/Layers/xrRender/ParticleGroup.cpp b/src/Layers/xrRender/ParticleGroup.cpp
index 5349383..1797c51 100644
--- a/src/Layers/xrRender/ParticleGroup.cpp
+++ b/src/Layers/xrRender/ParticleGroup.cpp
@@ -217,7 +217,7 @@ void CParticleGroup::SItem::StartRelatedChild(CParticleEffect* emitter, LPCSTR e
 	M.identity();
 	Fvector vel;
 	vel.sub(m.pos, m.posB);
-	vel.div(fDT_STEP);
+	vel.div(C->m_Def->GetFStep());
 	if (emitter->m_RT_Flags.is(CParticleEffect::flRT_XFORM))
 	{
 		M.set(emitter->m_XFORM);
@@ -251,7 +251,7 @@ void CParticleGroup::SItem::StartFreeChild(CParticleEffect* emitter, LPCSTR nm,
 		M.identity();
 		Fvector vel;
 		vel.sub(m.pos, m.posB);
-		vel.div(fDT_STEP);
+		vel.div(C->m_Def->GetFStep());
 		if (emitter->m_RT_Flags.is(CParticleEffect::flRT_XFORM))
 		{
 			M.set(emitter->m_XFORM);
@@ -389,7 +389,7 @@ void CParticleGroup::SItem::OnFrame(u32 u_dt, const CPGDef::SEffect& def, Fbox&
 						M.translate(m.pos);
 						Fvector vel;
 						vel.sub(m.pos, m.posB);
-						vel.div(fDT_STEP);
+						vel.div(C->m_Def->GetFStep());
 						C->UpdateParent(M, vel,FALSE);
 					}
 				}
diff --git a/src/Layers/xrRender/R_Backend_hemi.cpp b/src/Layers/xrRender/R_Backend_hemi.cpp
index 15ccb1f..795f2f9 100644
--- a/src/Layers/xrRender/R_Backend_hemi.cpp
+++ b/src/Layers/xrRender/R_Backend_hemi.cpp
@@ -13,6 +13,9 @@ void R_hemi::unmap()
 	c_pos_faces = 0;
 	c_neg_faces = 0;
 	c_material = 0;
+	//--DSR-- HeatVision_start
+	c_hotness = 0;
+	//--DSR-- HeatVision_end
 }
 
 void R_hemi::set_pos_faces(float posx, float posy, float posz)
@@ -29,3 +32,10 @@ void R_hemi::set_material(float x, float y, float z, float w)
 {
 	if (c_material) RCache.set_c(c_material, x, y, z, w);
 }
+
+//--DSR-- HeatVision_start
+void R_hemi::set_hotness(float x, float y, float z, float w)
+{
+	if (c_hotness) RCache.set_c(c_hotness, x, y, z, w);
+}
+//--DSR-- HeatVision_end
diff --git a/src/Layers/xrRender/R_Backend_hemi.h b/src/Layers/xrRender/R_Backend_hemi.h
index eaff851..911a71d 100644
--- a/src/Layers/xrRender/R_Backend_hemi.h
+++ b/src/Layers/xrRender/R_Backend_hemi.h
@@ -9,6 +9,10 @@ public:
 	R_constant* c_neg_faces;
 	R_constant* c_material;
 
+	//--DSR-- HeatVision_start
+	R_constant* c_hotness;
+	//--DSR-- HeatVision_end
+
 public:
 	R_hemi();
 	void unmap();
@@ -17,8 +21,17 @@ public:
 	void set_c_neg_faces(R_constant* C) { c_neg_faces = C; }
 	void set_c_material(R_constant* C) { c_material = C; }
 
+	//--DSR-- HeatVision_start
+	void set_c_hotness(R_constant* C) { c_hotness = C; }
+	//--DSR-- HeatVision_end
+
+
 	void set_pos_faces(float posx, float posy, float posz);
 	void set_neg_faces(float negx, float negy, float negz);
 	void set_material(float x, float y, float z, float w);
+
+	//--DSR-- HeatVision_start
+	void set_hotness(float x, float y, float z, float w);
+	//--DSR-- HeatVision_end
 };
 #endif
diff --git a/src/Layers/xrRender/SH_Texture.h b/src/Layers/xrRender/SH_Texture.h
index 62f91a6..cde2b8a 100644
--- a/src/Layers/xrRender/SH_Texture.h
+++ b/src/Layers/xrRender/SH_Texture.h
@@ -97,6 +97,10 @@ public: //	Public class members (must be encapsulated furthur)
 	float m_material;
 	shared_str m_bumpmap;
 
+	//--DSR-- HeatVision_start
+	bool m_is_hot = false;
+	//--DSR-- HeatVision_end
+
 	union
 	{
 		u32 m_play_time; // sync theora time
diff --git a/src/Layers/xrRender/SkeletonAnimated.cpp b/src/Layers/xrRender/SkeletonAnimated.cpp
index a2b6c3f..d5ac60e 100644
--- a/src/Layers/xrRender/SkeletonAnimated.cpp
+++ b/src/Layers/xrRender/SkeletonAnimated.cpp
@@ -11,6 +11,7 @@
 #include	"../../xrcore/dump_string.h"
 #endif
 extern int psSkeletonUpdate;
+extern shared_str current_player_hud_sect;
 using namespace animation;
 //////////////////////////////////////////////////////////////////////////
 // BoneInstance methods
@@ -781,7 +782,7 @@ void CKinematicsAnimated::Load(const char* N, IReader* data, u32 dwFlags)
 		if (!FS.exist(fn, "$level$", _path))
 		{
 			if (!FS.exist(fn, "$game_meshes$", _path))
-				Debug.fatal(DEBUG_INFO, "Can't find motion file '%s'.", _path);
+				Debug.fatal(DEBUG_INFO, "Can't find motion file '%s'\nsection '%s'\nmodel '%s'", _path, current_player_hud_sect.c_str(), N);
 		}
 
 		// Check compatibility
@@ -798,7 +799,7 @@ void CKinematicsAnimated::Load(const char* N, IReader* data, u32 dwFlags)
 		else
 		{
 			m_Motions.pop_back();
-			Msg("! error in model [%s]. Unable to load motion file '%s'.", N, _path);
+			Msg("! error in model [%s]. Unable to load motion file '%s', section '%s'.", N, _path, current_player_hud_sect.c_str());
 		}
 	};
 
@@ -808,7 +809,7 @@ void CKinematicsAnimated::Load(const char* N, IReader* data, u32 dwFlags)
 		string_path items_nm;
 		data->r_stringZ(items_nm, sizeof(items_nm));
 		u32 set_cnt = _GetItemCount(items_nm);
-		R_ASSERT(set_cnt<MAX_ANIM_SLOT);
+		R_ASSERT2(set_cnt<MAX_ANIM_SLOT, make_string("section '%s'\nmodel '%s'", current_player_hud_sect.c_str(), N).c_str());
 		m_Motions.reserve(set_cnt);
 		string_path nm;
 		for (u32 k = 0; k < set_cnt; ++k)
@@ -853,7 +854,7 @@ void CKinematicsAnimated::Load(const char* N, IReader* data, u32 dwFlags)
 		m_Motions.back().motions.create(nm, data, bones);
 	}
 
-	R_ASSERT(m_Motions.size());
+	R_ASSERT2(m_Motions.size(), make_string("section '%s'\nmodel '%s'", current_player_hud_sect.c_str(), N).c_str());
 
 	m_Partition = m_Motions[0].motions.partition();
 	m_Partition->load(this, N);
diff --git a/src/Layers/xrRender/SkeletonCustom.cpp b/src/Layers/xrRender/SkeletonCustom.cpp
index b738622..3267696 100644
--- a/src/Layers/xrRender/SkeletonCustom.cpp
+++ b/src/Layers/xrRender/SkeletonCustom.cpp
@@ -542,6 +542,7 @@ void CKinematics::Visibility_Update()
 			children_invisible.push_back(children[c_it]);
 			swap(children[c_it], children.back());
 			children.pop_back();
+			Update_Visibility = TRUE;
 		}
 	}
 
@@ -556,6 +557,7 @@ void CKinematics::Visibility_Update()
 			children.push_back(children_invisible[_it]);
 			swap(children_invisible[_it], children_invisible.back());
 			children_invisible.pop_back();
+			Update_Visibility = TRUE;
 		}
 	}
 }
diff --git a/src/Layers/xrRender/WallmarksEngine.cpp b/src/Layers/xrRender/WallmarksEngine.cpp
index d0592f8..cb12f86 100644
--- a/src/Layers/xrRender/WallmarksEngine.cpp
+++ b/src/Layers/xrRender/WallmarksEngine.cpp
@@ -34,7 +34,7 @@ namespace WallmarksEngine
 const float W_DIST_FADE = 15.f;
 const float W_DIST_FADE_SQR = W_DIST_FADE * W_DIST_FADE;
 const float I_DIST_FADE_SQR = 1.f / W_DIST_FADE_SQR;
-const int MAX_TRIS = 1024;
+const int MAX_TRIS = 1024 * 16;
 
 IC bool operator ==(const CWallmarksEngine::wm_slot* slot, const ref_shader& shader) { return slot->shader == shader; }
 
@@ -203,8 +203,9 @@ void CWallmarksEngine::BuildMatrix(Fmatrix& mView, float invsz, const Fvector& f
 	mView.mulA_43(mScale);
 }
 
+// demonized: add user defined rotation to wallmark
 void CWallmarksEngine::AddWallmark_internal(CDB::TRI* pTri, const Fvector* pVerts, const Fvector& contact_point,
-                                            ref_shader hShader, float sz, float ttl, bool random_rotation)
+                                            ref_shader hShader, float sz, float ttl, float rotation)
 {
 	// query for polygons in bounding box
 	// calculate adjacency
@@ -240,7 +241,7 @@ void CWallmarksEngine::AddWallmark_internal(CDB::TRI* pTri, const Fvector* pVert
 	// build 3D ortho-frustum
 	Fmatrix mView, mRot;
 	BuildMatrix(mView, 1 / sz, contact_point);
-	mRot.rotateZ(random_rotation ? ::Random.randF(deg2rad(-20.f), deg2rad(20.f)) : 0.f);
+	mRot.rotateZ(deg2rad(rotation));
 	mView.mulA_43(mRot);
 	sml_clipper.CreateFromMatrix(mView,FRUSTUM_P_LRTB);
 
@@ -300,8 +301,20 @@ void CWallmarksEngine::AddWallmark_internal(CDB::TRI* pTri, const Fvector* pVert
 	//}
 }
 
+void CWallmarksEngine::AddWallmark_internal(CDB::TRI* pTri, const Fvector* pVerts, const Fvector& contact_point,
+	ref_shader hShader, float sz, float ttl, bool random_rotation)
+{
+	AddWallmark_internal(pTri, pVerts, contact_point, hShader, sz, ttl, random_rotation ? ::Random.randF(-20.f, 20.f) : 0.f);
+}
+
 void CWallmarksEngine::AddStaticWallmark(CDB::TRI* pTri, const Fvector* pVerts, const Fvector& contact_point,
                                          ref_shader hShader, float sz, float ttl, bool ignore_opt, bool random_rotation)
+{
+	AddStaticWallmark(pTri, pVerts, contact_point, hShader, sz, ttl, ignore_opt, random_rotation ? ::Random.randF(-20.f, 20.f) : 0.f);
+}
+
+void CWallmarksEngine::AddStaticWallmark(CDB::TRI* pTri, const Fvector* pVerts, const Fvector& contact_point,
+	ref_shader hShader, float sz, float ttl, bool ignore_opt, float rotation)
 {
 	// optimization cheat: don't allow wallmarks more than 100 m from viewer/actor
 	if (!ignore_opt && contact_point.distance_to_sqr(Device.vCameraPosition) > _sqr(100.f))
@@ -309,7 +322,7 @@ void CWallmarksEngine::AddStaticWallmark(CDB::TRI* pTri, const Fvector* pVerts,
 
 	// Physics may add wallmarks in parallel with rendering
 	lock.Enter();
-	AddWallmark_internal(pTri, pVerts, contact_point, hShader, sz, ttl, random_rotation);
+	AddWallmark_internal(pTri, pVerts, contact_point, hShader, sz, ttl, rotation);
 	lock.Leave();
 }
 
diff --git a/src/Layers/xrRender/WallmarksEngine.h b/src/Layers/xrRender/WallmarksEngine.h
index 9ce1dde..2b30c50 100644
--- a/src/Layers/xrRender/WallmarksEngine.h
+++ b/src/Layers/xrRender/WallmarksEngine.h
@@ -52,8 +52,8 @@ private:
 private:
 	void BuildMatrix(Fmatrix& dest, float invsz, const Fvector& from);
 	void RecurseTri(u32 T, Fmatrix& mView, static_wallmark& W);
-	void AddWallmark_internal(CDB::TRI* pTri, const Fvector* pVerts, const Fvector& contact_point, ref_shader hTexture,
-	                          float sz, float ttl = 0.f, bool random_rotation = true);
+	void AddWallmark_internal(CDB::TRI* pTri, const Fvector* pVerts, const Fvector& contact_point, ref_shader hTexture, float sz, float ttl = 0.f, bool random_rotation = true);
+	void AddWallmark_internal(CDB::TRI* pTri, const Fvector* pVerts, const Fvector& contact_point, ref_shader hTexture, float sz, float ttl, float rotation);
 
 	static_wallmark* static_wm_allocate();
 	void static_wm_render(static_wallmark* W, FVF::LIT* & V);
@@ -64,8 +64,11 @@ public:
 	CWallmarksEngine();
 	~CWallmarksEngine();
 	// edit wallmarks
-	void AddStaticWallmark(CDB::TRI* pTri, const Fvector* pVerts, const Fvector& contact_point, ref_shader hTexture,
-	                       float sz, float ttl = 0.f, bool ignore_opt = false, bool random_rotation = true);
+	void AddStaticWallmark(CDB::TRI* pTri, const Fvector* pVerts, const Fvector& contact_point, ref_shader hTexture, float sz, float ttl = 0.f, bool ignore_opt = false, bool random_rotation = true);
+
+	// demonized: add user defined rotation to wallmark
+	void AddStaticWallmark(CDB::TRI* pTri, const Fvector* pVerts, const Fvector& contact_point, ref_shader hTexture, float sz, float ttl, bool ignore_opt, float rotation);
+
 	void AddSkeletonWallmark(intrusive_ptr<CSkeletonWallmark> wm);
 	void AddSkeletonWallmark(const Fmatrix* xf, CKinematics* obj, ref_shader& sh, const Fvector& start,
 	                         const Fvector& dir, float size, float ttl = 0.f, bool ignore_opt = false);
diff --git a/src/Layers/xrRender/light.h b/src/Layers/xrRender/light.h
index 8146a37..7b24183 100644
--- a/src/Layers/xrRender/light.h
+++ b/src/Layers/xrRender/light.h
@@ -70,6 +70,7 @@ public:
 		bool		visible;		// visible/invisible
 		bool		pending;		// test is still pending
 		u16			smap_ID;
+		float		distance;
 	}				vis;
 
 	union			_xform	{
diff --git a/src/Layers/xrRender/r__dsgraph_build.cpp b/src/Layers/xrRender/r__dsgraph_build.cpp
index 274542b..40a0ede 100644
--- a/src/Layers/xrRender/r__dsgraph_build.cpp
+++ b/src/Layers/xrRender/r__dsgraph_build.cpp
@@ -592,7 +592,7 @@ IC bool IsValuableToRender(dxRender_Visual* pVisual, bool isStatic, bool sm, Fma
 
 		if (sm && !!psDeviceFlags2.test(rsOptShadowGeom)) // Highest cut off for shadow map
 		{
-			if (sphere_volume < 50000.f && adjusted_distane > 160)
+			if (sphere_volume < 50000.f && adjusted_distane > ps_ssfx_shadow_cascades.z)
 				// don't need geometry behind the farest sun shadow cascade
 				return false;
 
diff --git a/src/Layers/xrRender/r__dsgraph_render.cpp b/src/Layers/xrRender/r__dsgraph_render.cpp
index 9ef142d..4d0ae5c 100644
--- a/src/Layers/xrRender/r__dsgraph_render.cpp
+++ b/src/Layers/xrRender/r__dsgraph_render.cpp
@@ -521,11 +521,6 @@ void R_dsgraph_structure::r_dsgraph_render_hud()
 	mapHUD.traverseLR(sorted_L1);
 	mapHUD.clear();
 
-#if	RENDER==R_R1
-	if (g_hud && g_hud->RenderActiveItemUIQuery())
-		r_dsgraph_render_hud_ui(); // hud ui
-#endif
-
 	rmNormal();
 
 	// Restore projection
@@ -537,8 +532,6 @@ void R_dsgraph_structure::r_dsgraph_render_hud()
 
 void R_dsgraph_structure::r_dsgraph_render_hud_ui()
 {
-	VERIFY(g_hud && g_hud->RenderActiveItemUIQuery());
-
 	// Change projection
 	Fmatrix Pold = Device.mProject;
 	Fmatrix FTold = Device.mFullTransform;
@@ -550,36 +543,6 @@ void R_dsgraph_structure::r_dsgraph_render_hud_ui()
 	Device.mFullTransform.mul(Device.mProject, Device.mView);
 	RCache.set_xform_project(Device.mProject);
 
-#if	RENDER!=R_R1
-	// Targets, use accumulator for temporary storage
-	const ref_rt rt_null;
-	RCache.set_RT(0, 1);
-	RCache.set_RT(0, 2);
-#if	(RENDER==R_R3) || (RENDER==R_R4)
-	if (!RImplementation.o.dx10_msaa)
-	{
-		if (RImplementation.o.albedo_wo)
-			RImplementation.Target->u_setrt(RImplementation.Target->rt_Accumulator,
-			                                rt_null, rt_null, HW.pBaseZB);
-		else RImplementation.Target->u_setrt(RImplementation.Target->rt_Color, rt_null, rt_null, HW.pBaseZB);
-	}
-	else
-	{
-		if (RImplementation.o.albedo_wo)
-			RImplementation.Target->u_setrt(RImplementation.Target->rt_Accumulator,
-			                                rt_null, rt_null,
-			                                RImplementation.Target->rt_MSAADepth->pZRT);
-		else
-			RImplementation.Target->u_setrt(RImplementation.Target->rt_Color, rt_null, rt_null,
-			                                RImplementation.Target->rt_MSAADepth->pZRT);
-	}
-#else // (RENDER==R_R3) || (RENDER==R_R4)
-	if (RImplementation.o.albedo_wo) RImplementation.Target->u_setrt(RImplementation.Target->rt_Accumulator, rt_null,
-	                                                                 rt_null, HW.pBaseZB);
-	else RImplementation.Target->u_setrt(RImplementation.Target->rt_Color, rt_null, rt_null, HW.pBaseZB);
-#endif // (RENDER==R_R3) || (RENDER==R_R4)
-#endif // RENDER!=R_R1
-
 	rmNear();
 	g_hud->RenderActiveItemUI();
 	rmNormal();
diff --git a/src/Layers/xrRender/rendertarget_phase_nightvision.cpp b/src/Layers/xrRender/rendertarget_phase_nightvision.cpp
index 248d1c4..64da747 100644
--- a/src/Layers/xrRender/rendertarget_phase_nightvision.cpp
+++ b/src/Layers/xrRender/rendertarget_phase_nightvision.cpp
@@ -51,3 +51,111 @@ void CRenderTarget::phase_nightvision()
 	HW.pContext->CopyResource(rt_Generic_0->pTexture->surface_get(), dest_rt->pTexture->surface_get());
 #endif
 };
+
+
+//crookr
+void CRenderTarget::phase_fakescope()
+{
+	//Constants
+	u32 Offset = 0;
+	u32 C = color_rgba(0, 0, 0, 255);
+
+	float d_Z = EPS_S;
+	float d_W = 1.0f;
+	float w = float(Device.dwWidth);
+	float h = float(Device.dwHeight);
+
+	Fvector2 p0, p1;
+#if defined(USE_DX10) || defined(USE_DX11)	
+	p0.set(0.0f, 0.0f);
+	p1.set(1.0f, 1.0f);
+#else
+	p0.set(0.5f / w, 0.5f / h);
+	p1.set((w + 0.5f) / w, (h + 0.5f) / h);
+#endif
+
+	//////////////////////////////////////////////////////////////////////////
+	//Set MSAA/NonMSAA rendertarget
+#if defined(USE_DX10) || defined(USE_DX11)
+	ref_rt& dest_rt = RImplementation.o.dx10_msaa ? rt_Generic : rt_Color;
+	u_setrt(dest_rt, nullptr, nullptr, nullptr);
+#else
+	u_setrt(rt_Generic_0, nullptr, nullptr, nullptr);
+#endif		
+
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	//Fill vertex buffer
+	FVF::TL* pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, float(h), d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(float(w), float(h), d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(float(w), 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	//Set pass
+	RCache.set_Element(s_fakescope->E[ps_r2_nightvision]);
+
+	//Set geometry
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+#if defined(USE_DX10) || defined(USE_DX11)
+	HW.pContext->CopyResource(rt_Generic_0->pTexture->surface_get(), dest_rt->pTexture->surface_get());
+#endif
+};
+
+//--DSR-- HeatVision_start
+void CRenderTarget::phase_heatvision()
+{
+	//Constants
+	u32 Offset = 0;
+	u32 C = color_rgba(0, 0, 0, 255);
+
+	float d_Z = EPS_S;
+	float d_W = 1.0f;
+	float w = float(Device.dwWidth);
+	float h = float(Device.dwHeight);
+
+	Fvector2 p0, p1;
+#if defined(USE_DX10) || defined(USE_DX11)	
+	p0.set(0.0f, 0.0f);
+	p1.set(1.0f, 1.0f);
+#else
+	p0.set(0.5f / w, 0.5f / h);
+	p1.set((w + 0.5f) / w, (h + 0.5f) / h);
+#endif
+
+	//////////////////////////////////////////////////////////////////////////
+	//Set MSAA/NonMSAA rendertarget
+#if defined(USE_DX10) || defined(USE_DX11)
+	ref_rt& dest_rt = RImplementation.o.dx10_msaa ? rt_Generic : rt_Color;
+	u_setrt(dest_rt, nullptr, nullptr, nullptr);
+#else
+	u_setrt(rt_Generic_0, nullptr, nullptr, nullptr);
+#endif		
+
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	//Fill vertex buffer
+	FVF::TL* pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, float(h), d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(float(w), float(h), d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(float(w), 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	//Set pass
+	RCache.set_Element(s_heatvision->E[ps_r2_heatvision]);
+
+	//Set geometry
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+#if defined(USE_DX10) || defined(USE_DX11)
+	HW.pContext->CopyResource(rt_Generic_0->pTexture->surface_get(), dest_rt->pTexture->surface_get());
+#endif
+};
+//--DSR-- HeatVision_start
diff --git a/src/Layers/xrRender/xrRender_console.cpp b/src/Layers/xrRender/xrRender_console.cpp
index 19cf561..c8a1ec7 100644
--- a/src/Layers/xrRender/xrRender_console.cpp
+++ b/src/Layers/xrRender/xrRender_console.cpp
@@ -258,6 +258,18 @@ Fvector ps_r2_drops_control = {.0f, 1.15f, .0f}; // r2-only
 
 int ps_r2_nightvision = 0;
 
+//--DSR-- HeatVision_start
+int ps_r2_heatvision = 0;
+float heat_vision_mode = 0.0f;
+Fvector4 heat_vision_steps = { 0.45f, 0.65f, 0.76f, .0f };
+Fvector4 heat_vision_blurring = { 15.f, 4.f, 60.f, .0f };
+Fvector4 heat_vision_args_1 = { .0f, .0f, .0f, .0f };
+Fvector4 heat_vision_args_2 = { .0f, .0f, .0f, .0f };
+//--DSR-- HeatVision_end
+//crookr
+int scope_fake_enabled = 1;
+//string32 scope_fake_texture = "wpn\\wpn_crosshair_pso1";
+
 float ps_r2_ss_sunshafts_length = 1.f;
 float ps_r2_ss_sunshafts_radius = 1.f;
 
@@ -290,8 +302,21 @@ Fvector4 ps_dev_param_6 = { .0f, .0f, .0f, .0f };
 Fvector4 ps_dev_param_7 = { .0f, .0f, .0f, .0f };
 Fvector4 ps_dev_param_8 = { .0f, .0f, .0f, .0f };
 
+float ps_particle_update_coeff = 1.f;
+
 /////////////////////////////////
 
+// Screen Space Shaders Stuff
+Fvector3 ps_ssfx_shadow_cascades = { 20, 40, 160 };
+Fvector4 ps_ssfx_grass_shadows = { .0f, .35f, 30.0f, .0f };
+
+Fvector4 ps_ssfx_grass_interactive = { .0f, .0f, 2000.0f, 1.0f };
+Fvector4 ps_ssfx_int_grass_params_1 = { 1.0f, 1.0f, 1.0f, 25.0f };
+Fvector4 ps_ssfx_int_grass_params_2 = { 1.0f, 5.0f, 1.0f, 1.0f };
+
+Fvector4 ps_ssfx_wpn_dof_1 = { .0f, .0f, .0f, .0f };
+float ps_ssfx_wpn_dof_2 = 1.0f;
+
 //	x - min (0), y - focus (1.4), z - max (100)
 Fvector3 ps_r2_dof = { -1.25f, 0.f, 600.f };
 float ps_r2_dof_sky = 30; //	distance to sky
@@ -347,6 +372,33 @@ int opt_dynamic = 2;
 #include "../xrRenderDX10/StateManager/dx10SamplerStateCache.h"
 #endif	//	USE_DX10
 
+class CCC_ssfx_cascades : public CCC_Vector3
+{
+public:
+	void apply()
+	{
+#if defined(USE_DX10) || defined(USE_DX11)
+		RImplementation.init_cacades();
+#endif
+	}
+
+	CCC_ssfx_cascades(LPCSTR N, Fvector3* V, const Fvector3 _min, const Fvector3 _max) : CCC_Vector3(N, V, _min, _max)
+	{
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+		CCC_Vector3::Execute(args);
+		apply();
+	}
+
+	virtual void Status(TStatus& S)
+	{
+		CCC_Vector3::Status(S);
+		apply();
+	}
+};
+
 //-----------------------------------------------------------------------
 //AVO: detail draw radius
 #ifdef DETAIL_RADIUS
@@ -1046,6 +1098,10 @@ void xrRender_initconsole()
 	CMD4(CCC_Vector4, "r__bloom_weight", &ps_pp_bloom_weight, twb_min, twb_max);
 	CMD4(CCC_Vector4, "r__bloom_thresh", &ps_pp_bloom_thresh, twb_min, twb_max);
 	CMD4(CCC_Integer, "r__nightvision", &ps_r2_nightvision, 0, 3); //For beef's nightvision shader or other stuff
+
+	CMD4(CCC_Integer, "r__fakescope", &scope_fake_enabled, 0, 1); //crookr for fake scope
+
+	CMD4(CCC_Integer, "r__heatvision", &ps_r2_heatvision, 0, 1); //--DSR-- HeatVision
 	CMD3(CCC_Mask, "r2_terrain_z_prepass", &ps_r2_ls_flags, R2FLAG_TERRAIN_PREPASS); //Terrain Z Prepass @Zagolski
 	
 	//////////other
@@ -1070,6 +1126,27 @@ void xrRender_initconsole()
 	CMD4(CCC_Vector4, "shader_param_6", &ps_dev_param_6, tw2_min, tw2_max);
 	CMD4(CCC_Vector4, "shader_param_7", &ps_dev_param_7, tw2_min, tw2_max);
 	CMD4(CCC_Vector4, "shader_param_8", &ps_dev_param_8, tw2_min, tw2_max);
+	
+	// Screen Space Shaders
+	CMD4(CCC_Vector4, "ssfx_grass_shadows", &ps_ssfx_grass_shadows, Fvector4().set(0, 0, 0, 0), Fvector4().set(3, 1, 100, 100));
+	CMD4(CCC_ssfx_cascades, "ssfx_shadow_cascades", &ps_ssfx_shadow_cascades, Fvector3().set(1.0f, 1.0f, 1.0f), Fvector3().set(300, 300, 300));
+	
+	CMD4(CCC_Vector4, "ssfx_grass_interactive", &ps_ssfx_grass_interactive, Fvector4().set(0, 0, 0, 0), Fvector4().set(1, 15, 5000, 1));
+	CMD4(CCC_Vector4, "ssfx_int_grass_params_1", &ps_ssfx_int_grass_params_1, Fvector4().set(0, 0, 0, 0), Fvector4().set(5, 5, 5, 60));
+	CMD4(CCC_Vector4, "ssfx_int_grass_params_2", &ps_ssfx_int_grass_params_2, Fvector4().set(0, 0, 0, 0), Fvector4().set(5, 20, 1, 5));
+	
+	CMD4(CCC_Vector4, "ssfx_wpn_dof_1", &ps_ssfx_wpn_dof_1, tw2_min, tw2_max);
+	CMD4(CCC_Float, "ssfx_wpn_dof_2", &ps_ssfx_wpn_dof_2, 0, 1);
+
+	//--DSR-- HeatVision_start
+	CMD2(CCC_Float,   "heat_vision_mode",		&heat_vision_mode);
+	CMD4(CCC_Vector4, "heat_vision_steps",		&heat_vision_steps, tw2_min, tw2_max);
+	CMD4(CCC_Vector4, "heat_vision_blurring",	&heat_vision_blurring, tw2_min, tw2_max);
+	CMD4(CCC_Vector4, "heat_vision_args_1",		&heat_vision_args_1, tw2_min, tw2_max);
+	CMD4(CCC_Vector4, "heat_vision_args_2",		&heat_vision_args_2, tw2_min, tw2_max);
+	//--DSR-- HeatVision_end
+
+	CMD4(CCC_Float, "particle_update_mod", &ps_particle_update_coeff, 0.04f, 10.f);
 
 	// Geometry optimization
 	CMD4(CCC_Integer, "r__optimize_static_geom", &opt_static, 0, 4);
diff --git a/src/Layers/xrRender/xrRender_console.h b/src/Layers/xrRender/xrRender_console.h
index 7ee8c11..21be1bf 100644
--- a/src/Layers/xrRender/xrRender_console.h
+++ b/src/Layers/xrRender/xrRender_console.h
@@ -3,6 +3,12 @@
 #pragma once
 
 // Common
+extern ECORE_API Fvector4 ps_ssfx_grass_shadows;
+extern ECORE_API Fvector3 ps_ssfx_shadow_cascades;
+extern ECORE_API Fvector4 ps_ssfx_grass_interactive;
+extern ECORE_API Fvector4 ps_ssfx_int_grass_params_1;
+extern ECORE_API Fvector4 ps_ssfx_int_grass_params_2;
+
 extern ECORE_API u32 ps_r_sun_shafts; //=	0;
 extern ECORE_API xr_token qsun_shafts_token[];
 
@@ -140,6 +146,8 @@ extern ECORE_API int ps_r2_qsync;
 extern ECORE_API Fvector4 ps_r2_mask_control; // r2-only
 extern ECORE_API Fvector ps_r2_drops_control; // r2-only
 extern ECORE_API int ps_r2_nightvision;
+extern ECORE_API int scope_fake_enabled; //crookr
+extern ECORE_API int ps_r2_heatvision; //--DSR-- HeatVision
 extern ECORE_API float ps_r2_ss_sunshafts_length;
 extern ECORE_API float ps_r2_ss_sunshafts_radius;
 extern u32 ps_sunshafts_mode;
diff --git a/src/Layers/xrRenderDX10/dx10DetailManager_VS.cpp b/src/Layers/xrRenderDX10/dx10DetailManager_VS.cpp
index bb08aa2..e4e26ea 100644
--- a/src/Layers/xrRenderDX10/dx10DetailManager_VS.cpp
+++ b/src/Layers/xrRenderDX10/dx10DetailManager_VS.cpp
@@ -110,6 +110,18 @@ void CDetailManager::hw_Render_dump(const Fvector4& consts, const Fvector4& wave
 	static shared_str strArray("array");
 	static shared_str strXForm("xform");
 
+	static shared_str strPos("benders_pos");
+	static shared_str strGrassSetup("benders_setup");
+
+	// Grass benders data
+	IGame_Persistent::grass_data& GData = g_pGamePersistent->grass_shader_data;
+	Fvector4 player_pos = { 0, 0, 0, 0 };
+	int BendersQty = _min(16, ps_ssfx_grass_interactive.y + 1);
+
+	// Add Player?
+	if (ps_ssfx_grass_interactive.x > 0)
+		player_pos.set(Device.vCameraPosition.x, Device.vCameraPosition.y, Device.vCameraPosition.z, -1);
+
 	Device.Statistic->RenderDUMP_DT_Count = 0;
 
 	// Matrices and offsets
@@ -146,6 +158,31 @@ void CDetailManager::hw_Render_dump(const Fvector4& consts, const Fvector4& wave
 				RCache.set_c(strDir2D, wind);
 				RCache.set_c(strXForm, Device.mFullTransform);
 
+				if (ps_ssfx_grass_interactive.y > 0)
+				{
+					RCache.set_c(strGrassSetup, ps_ssfx_int_grass_params_1);
+
+					Fvector4* c_grass;
+					{
+						void* GrassData;
+						RCache.get_ConstantDirect(strPos, BendersQty * sizeof(Fvector4), &GrassData, 0, 0);
+						c_grass = (Fvector4*)GrassData;
+					}
+					VERIFY(c_grass);
+
+					if (c_grass)
+					{
+						c_grass[0].set(player_pos);
+						c_grass[16].set(0.0f, -99.0f, 0.0f, 1.0f);
+
+						for (int Bend = 1; Bend < BendersQty; Bend++)
+						{
+							c_grass[Bend].set(GData.pos[Bend].x, GData.pos[Bend].y, GData.pos[Bend].z, GData.radius_curr[Bend]);
+							c_grass[Bend + 16].set(GData.dir[Bend].x, GData.dir[Bend].y, GData.dir[Bend].z, GData.str[Bend]);
+						}
+					}
+				}
+
 				//ref_constant constArray = RCache.get_c(strArray);
 				//VERIFY(constArray);
 
@@ -176,8 +213,20 @@ void CDetailManager::hw_Render_dump(const Fvector4& consts, const Fvector4& wave
 						SlotItem& Instance = **_iI;
 						u32 base = dwBatch * 4;
 
-						// Build matrix ( 3x4 matrix, last row - color )
 						float scale = Instance.scale_calculated;
+
+						// Sort of fade using the scale
+						// fade_distance == -1 use light_position to define "fade", anything else uses fade_distance
+						if (fade_distance <= -1)
+							scale *= 1.0f - Instance.position.distance_to_xz_sqr(light_position) * 0.005f;
+						else if (Instance.distance > fade_distance)
+							scale *= 1.0f - abs(Instance.distance - fade_distance) * 0.005f;
+
+						if (scale <= 0)
+							break;
+
+						// Build matrix ( 3x4 matrix, last row - color )
+						//float scale = Instance.scale_calculated;
 						Fmatrix& M = Instance.mRotY;
 						c_storage[base + 0].set(M._11 * scale, M._21 * scale, M._31 * scale, M._41);
 						c_storage[base + 1].set(M._12 * scale, M._22 * scale, M._32 * scale, M._42);
@@ -233,13 +282,16 @@ void CDetailManager::hw_Render_dump(const Fvector4& consts, const Fvector4& wave
 			}
 			// Clean up
 			// KD: we must not clear vis on r2 since we want details shadows
-			if (!psDeviceFlags2.test(rsGrassShadow) || ((ps_r2_ls_flags.test(R2FLAG_SUN_DETAILS) && (RImplementation.PHASE_SMAP ==
+			if (ps_ssfx_grass_shadows.x <= 0)
+			{
+				if (!psDeviceFlags2.test(rsGrassShadow) || ((ps_r2_ls_flags.test(R2FLAG_SUN_DETAILS) && (RImplementation.PHASE_SMAP ==
 					RImplementation.phase)) // phase smap with shadows
-				|| (ps_r2_ls_flags.test(R2FLAG_SUN_DETAILS) && (RImplementation.PHASE_NORMAL == RImplementation.phase)
-					&& (!RImplementation.is_sun())) // phase normal with shadows without sun
-				|| (!ps_r2_ls_flags.test(R2FLAG_SUN_DETAILS) && (RImplementation.PHASE_NORMAL == RImplementation.phase))
-			)) // phase normal without shadows
-				vis.clear_not_free();
+					|| (ps_r2_ls_flags.test(R2FLAG_SUN_DETAILS) && (RImplementation.PHASE_NORMAL == RImplementation.phase)
+						&& (!RImplementation.is_sun())) // phase normal with shadows without sun
+					|| (!ps_r2_ls_flags.test(R2FLAG_SUN_DETAILS) && (RImplementation.PHASE_NORMAL == RImplementation.phase))
+					)) // phase normal without shadows
+					vis.clear_not_free();
+			}
 		}
 		vOffset += hw_BatchSize * Object.number_vertices;
 		iOffset += hw_BatchSize * Object.number_indices;
diff --git a/src/Layers/xrRenderDX10/dx10ResourceManager_Scripting.cpp b/src/Layers/xrRenderDX10/dx10ResourceManager_Scripting.cpp
index 70d8640..e748ddf 100644
--- a/src/Layers/xrRenderDX10/dx10ResourceManager_Scripting.cpp
+++ b/src/Layers/xrRenderDX10/dx10ResourceManager_Scripting.cpp
@@ -193,6 +193,12 @@ public:
 		return *this;
 	}
 
+	adopt_compiler& _dx10CullMode(u32 Ref)
+	{
+		C->r_CullMode((D3DCULL)Ref);
+		return *this;
+	}
+
 	adopt_compiler& _dx10ATOC(bool Enable)
 	{
 		C->RS.SetRS(XRDX10RS_ALPHATOCOVERAGE, Enable);
@@ -389,6 +395,7 @@ void CResourceManager::LS_Load()
 		.def("dx10texture", &adopt_compiler::_dx10texture, return_reference_to(_1))
 		.def("dx10stencil", &adopt_compiler::_dx10Stencil, return_reference_to(_1))
 		.def("dx10stencil_ref", &adopt_compiler::_dx10StencilRef, return_reference_to(_1))
+		.def("dx10cullmode", &adopt_compiler::_dx10CullMode, return_reference_to(_1))
 		.def("dx10atoc", &adopt_compiler::_dx10ATOC, return_reference_to(_1))
 		.def("dx10zfunc", &adopt_compiler::_dx10ZFunc, return_reference_to(_1))
 
diff --git a/src/Layers/xrRenderPC_R1/FStaticRender.cpp b/src/Layers/xrRenderPC_R1/FStaticRender.cpp
index 85ed6d3..16bfac1 100644
--- a/src/Layers/xrRenderPC_R1/FStaticRender.cpp
+++ b/src/Layers/xrRenderPC_R1/FStaticRender.cpp
@@ -304,24 +304,35 @@ void CRender::add_Visual(IRenderVisual* V)
 
 void CRender::add_Geometry(IRenderVisual* V) { add_Static((dxRender_Visual*)V, View->getMask()); }
 
+// demonized: add user defined rotation to wallmark
 void CRender::add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* verts, float ttl, bool ignore_opt, bool random_rotation)
+{
+	add_StaticWallmark(S, P, s, T, verts, ttl, ignore_opt, random_rotation ? ::Random.randF(-20.f, 20.f) : 0.f);
+}
+
+void CRender::add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* verts, float ttl, bool ignore_opt, float rotation)
 {
 	if (T->suppress_wm) return;
-	VERIFY2(_valid(P) && _valid(s) && T && verts && (s>EPS_L), "Invalid static wallmark params");
-	Wallmarks->AddStaticWallmark(T, verts, P, &*S, s, ttl, ignore_opt, random_rotation);
+	VERIFY2(_valid(P) && _valid(s) && T && verts && (s > EPS_L), "Invalid static wallmark params");
+	Wallmarks->AddStaticWallmark(T, verts, P, &*S, s, ttl, ignore_opt, rotation);
 }
 
 void CRender::add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, bool random_rotation)
 {
-	dxWallMarkArray* pWMA = (dxWallMarkArray *)pArray;
+	add_StaticWallmark(pArray, P, s, T, V, ttl, ignore_opt, random_rotation ? ::Random.randF(-20.f, 20.f) : 0.f);
+}
+
+void CRender::add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, float rotation)
+{
+	dxWallMarkArray* pWMA = (dxWallMarkArray*)pArray;
 	ref_shader* pShader = pWMA->dxGenerateWallmark();
-	if (pShader) add_StaticWallmark(*pShader, P, s, T, V, ttl, ignore_opt, random_rotation);
+	if (pShader) add_StaticWallmark(*pShader, P, s, T, V, ttl, ignore_opt, rotation);
 }
 
 void CRender::add_StaticWallmark(const wm_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V)
 {
 	dxUIShader* pShader = (dxUIShader*)&*S;
-	add_StaticWallmark(pShader->hShader, P, s, T, V);
+	add_StaticWallmark(pShader->hShader, P, s, T, V, 0.0f, false, true);
 }
 
 void CRender::clear_static_wallmarks()
@@ -711,6 +722,9 @@ void CRender::Render()
 	L_Dynamic->render(0); // addititional light sources
 	if (Wallmarks)Wallmarks->Render(); // wallmarks has priority as normal geometry
 
+	if (g_hud && g_hud->RenderActiveItemUIQuery())
+		r_dsgraph_render_hud_ui();
+
 	HOM.Enable();
 	o.vis_intersect = FALSE;
 	phase = PHASE_NORMAL;
diff --git a/src/Layers/xrRenderPC_R1/FStaticRender.h b/src/Layers/xrRenderPC_R1/FStaticRender.h
index 44ed99f..d97bd14 100644
--- a/src/Layers/xrRenderPC_R1/FStaticRender.h
+++ b/src/Layers/xrRenderPC_R1/FStaticRender.h
@@ -163,8 +163,12 @@ public:
 	virtual void add_Geometry(IRenderVisual* V); // add visual(s)	(all culling performed)
 
 	// wallmarks
+	// demonized: add user defined rotation to wallmark
 	virtual void add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl = 0.f, bool ignore_opt = false, bool random_rotation = true);
+	virtual void add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, float rotation);
 	virtual void add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl = 0.f, bool ignore_opt = false, bool random_rotation = true);
+	virtual void add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, float rotation);
+
 	virtual void add_StaticWallmark(const wm_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V);
 	virtual void clear_static_wallmarks();
 	virtual void add_SkeletonWallmark(intrusive_ptr<CSkeletonWallmark> wm);
diff --git a/src/Layers/xrRenderPC_R2/blender_nightvision.cpp b/src/Layers/xrRenderPC_R2/blender_nightvision.cpp
index b44403b..042b2c4 100644
--- a/src/Layers/xrRenderPC_R2/blender_nightvision.cpp
+++ b/src/Layers/xrRenderPC_R2/blender_nightvision.cpp
@@ -3,11 +3,21 @@
 #include "blender_nightvision.h"
 
 CBlender_nightvision::CBlender_nightvision() { description.CLS = 0; }
+CBlender_fakescope::CBlender_fakescope() { description.CLS = 0; } //crookr
+CBlender_heatvision::CBlender_heatvision() { description.CLS = 0;  } //--DSR-- HeatVision
 
 CBlender_nightvision::~CBlender_nightvision()
 {
 }
 
+CBlender_fakescope::~CBlender_fakescope() //crookr
+{
+}
+
+CBlender_heatvision::~CBlender_heatvision() //--DSR-- HeatVision_start
+{
+}
+
 void CBlender_nightvision::Compile(CBlender_Compile& C)
 {
 	IBlender::Compile(C);
@@ -38,3 +48,23 @@ void CBlender_nightvision::Compile(CBlender_Compile& C)
 		break;	
 	}
 }
+
+void CBlender_fakescope::Compile(CBlender_Compile& C) //crookr
+{
+	IBlender::Compile(C);
+	C.r_Pass("null", "fakescope", FALSE, FALSE, FALSE);
+	C.r_Sampler_rtf("s_position", r2_RT_P);
+	C.r_Sampler_clf("s_image", r2_RT_generic0);
+	C.r_End();
+}
+
+//--DSR-- HeatVision_start
+void CBlender_heatvision::Compile(CBlender_Compile& C)
+{
+	IBlender::Compile(C);
+	C.r_Pass("null", "heatvision", FALSE, FALSE, FALSE);
+	C.r_Sampler_rtf("s_position", r2_RT_P);
+	C.r_Sampler_clf("s_image", r2_RT_generic0);
+	C.r_End();	
+}
+//--DSR-- HeatVision_end
diff --git a/src/Layers/xrRenderPC_R2/blender_nightvision.h b/src/Layers/xrRenderPC_R2/blender_nightvision.h
index 0801e41..8efe46d 100644
--- a/src/Layers/xrRenderPC_R2/blender_nightvision.h
+++ b/src/Layers/xrRenderPC_R2/blender_nightvision.h
@@ -13,3 +13,32 @@ public:
 	CBlender_nightvision();
 	virtual ~CBlender_nightvision();
 };
+
+//crookr
+class CBlender_fakescope : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "fakescope"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_fakescope();
+	virtual ~CBlender_fakescope();
+};
+
+//--DSR-- HeatVision_start
+class CBlender_heatvision : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "heatvision"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_heatvision();
+	virtual ~CBlender_heatvision();
+};
+//--DSR-- HeatVision_end
diff --git a/src/Layers/xrRenderPC_R2/r2.cpp b/src/Layers/xrRenderPC_R2/r2.cpp
index ac81c93..74dbc29 100644
--- a/src/Layers/xrRenderPC_R2/r2.cpp
+++ b/src/Layers/xrRenderPC_R2/r2.cpp
@@ -615,24 +615,35 @@ BOOL CRender::occ_visible(Fbox& P) { return HOM.visible(P); }
 void CRender::add_Visual(IRenderVisual* V) { add_leafs_Dynamic((dxRender_Visual*)V, V->_ignore_optimization); }
 void CRender::add_Geometry(IRenderVisual* V) { add_Static((dxRender_Visual*)V, View->getMask()); }
 
+// demonized: add user defined rotation to wallmark
 void CRender::add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* verts, float ttl, bool ignore_opt, bool random_rotation)
+{
+	add_StaticWallmark(S, P, s, T, verts, ttl, ignore_opt, random_rotation ? ::Random.randF(-20.f, 20.f) : 0.f);
+}
+
+void CRender::add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* verts, float ttl, bool ignore_opt, float rotation)
 {
 	if (T->suppress_wm) return;
-	VERIFY2(_valid(P) && _valid(s) && T && verts && (s>EPS_L), "Invalid static wallmark params");
-	Wallmarks->AddStaticWallmark(T, verts, P, &*S, s, ttl, ignore_opt, random_rotation);
+	VERIFY2(_valid(P) && _valid(s) && T && verts && (s > EPS_L), "Invalid static wallmark params");
+	Wallmarks->AddStaticWallmark(T, verts, P, &*S, s, ttl, ignore_opt, rotation);
 }
 
 void CRender::add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, bool random_rotation)
 {
-	dxWallMarkArray* pWMA = (dxWallMarkArray *)pArray;
+	add_StaticWallmark(pArray, P, s, T, V, ttl, ignore_opt, random_rotation ? ::Random.randF(-20.f, 20.f) : 0.f);
+}
+
+void CRender::add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, float rotation)
+{
+	dxWallMarkArray* pWMA = (dxWallMarkArray*)pArray;
 	ref_shader* pShader = pWMA->dxGenerateWallmark();
-	if (pShader) add_StaticWallmark(*pShader, P, s, T, V, ttl, ignore_opt, random_rotation);
+	if (pShader) add_StaticWallmark(*pShader, P, s, T, V, ttl, ignore_opt, rotation);
 }
 
 void CRender::add_StaticWallmark(const wm_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V)
 {
 	dxUIShader* pShader = (dxUIShader*)&*S;
-	add_StaticWallmark(pShader->hShader, P, s, T, V);
+	add_StaticWallmark(pShader->hShader, P, s, T, V, 0.0f, false, true);
 }
 
 void CRender::clear_static_wallmarks()
diff --git a/src/Layers/xrRenderPC_R2/r2.h b/src/Layers/xrRenderPC_R2/r2.h
index a3ff957..dadda48 100644
--- a/src/Layers/xrRenderPC_R2/r2.h
+++ b/src/Layers/xrRenderPC_R2/r2.h
@@ -264,8 +264,12 @@ public:
 	virtual void add_Geometry(IRenderVisual* V); // add visual(s)	(all culling performed)
 
 	// wallmarks
+	// demonized: add user defined rotation to wallmark
 	virtual void add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl = 0.f, bool ignore_opt = false, bool random_rotation = true);
+	virtual void add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, float rotation);
 	virtual void add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl = 0.f, bool ignore_opt = false, bool random_rotation = true);
+	virtual void add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, float rotation);
+
 	virtual void add_StaticWallmark(const wm_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V);
 	virtual void clear_static_wallmarks();
 	virtual void add_SkeletonWallmark(intrusive_ptr<CSkeletonWallmark> wm);
diff --git a/src/Layers/xrRenderPC_R2/r2_R_render.cpp b/src/Layers/xrRenderPC_R2/r2_R_render.cpp
index 4df2bc0..528bbad 100644
--- a/src/Layers/xrRenderPC_R2/r2_R_render.cpp
+++ b/src/Layers/xrRenderPC_R2/r2_R_render.cpp
@@ -142,12 +142,22 @@ void CRender::render_main(Fmatrix& m_ViewProjection, bool _fportals)
 				break; // exit loop on frustums
 			}
 		}
-		if (g_pGameLevel && (phase == PHASE_NORMAL)) g_hud->Render_Last(); // HUD
+		if (g_pGameLevel && (phase == PHASE_NORMAL))
+		{
+			g_hud->Render_Last(); // HUD
+			if (g_hud->RenderActiveItemUIQuery())
+				r_dsgraph_render_hud_ui();
+		}
 	}
 	else
 	{
 		set_Object(0);
-		if (g_pGameLevel && (phase == PHASE_NORMAL)) g_hud->Render_Last(); // HUD
+		if (g_pGameLevel && (phase == PHASE_NORMAL))
+		{
+			g_hud->Render_Last(); // HUD
+			if (g_hud->RenderActiveItemUIQuery())
+				r_dsgraph_render_hud_ui();
+		}
 	}
 }
 
@@ -405,12 +415,6 @@ void CRender::Render()
 		Target->phase_scene_end();
 	}
 
-	if (g_hud && g_hud->RenderActiveItemUIQuery())
-	{
-		Target->phase_wallmarks();
-		r_dsgraph_render_hud_ui();
-	}
-
 	// Wall marks
 	if (Wallmarks)
 	{
diff --git a/src/Layers/xrRenderPC_R2/r2_rendertarget.cpp b/src/Layers/xrRenderPC_R2/r2_rendertarget.cpp
index f55c506..7f17163 100644
--- a/src/Layers/xrRenderPC_R2/r2_rendertarget.cpp
+++ b/src/Layers/xrRenderPC_R2/r2_rendertarget.cpp
@@ -247,6 +247,8 @@ CRenderTarget::CRenderTarget()
 	b_gasmask_drops = xr_new<CBlender_gasmask_drops>();
 	b_gasmask_dudv = xr_new<CBlender_gasmask_dudv>();
 	b_nightvision = xr_new<CBlender_nightvision>();
+	b_fakescope = xr_new<CBlender_fakescope>(); //crookr
+	b_heatvision = xr_new<CBlender_heatvision>(); //--DSR-- HeatVision
 	b_lut = xr_new<CBlender_lut>();
 	b_smaa = xr_new<CBlender_smaa>();
 
@@ -288,6 +290,11 @@ CRenderTarget::CRenderTarget()
 		rt_secondVP.create(r2_RT_secondVP, w, h, D3DFMT_A8R8G8B8); //--#SM+#-- +SecondVP+
 		rt_ui_pda.create(r2_RT_ui, w, h, D3DFMT_A8R8G8B8);
 
+		rt_fakescope.create(r2_RT_scopert, w, h, D3DFMT_A8R8G8B8, 1); //crookr fakescope
+		
+		//--DSR-- HeatVision_start
+		rt_Heat.create(r2_RT_heat, w, h, D3DFMT_A8R8G8B8, 1);
+		//--DSR-- HeatVision_end
 
 		// RT Blur
 		rt_blur_h_2.create(r2_RT_blur_h_2, u32(w/2), u32(h/2), D3DFMT_A8R8G8B8);
@@ -323,6 +330,8 @@ CRenderTarget::CRenderTarget()
 	s_gasmask_drops.create(b_gasmask_drops, "r2\\gasmask_drops");
 	s_gasmask_dudv.create(b_gasmask_dudv, "r2\\gasmask_dudv");
 	s_nightvision.create(b_nightvision, "r2\\nightvision");
+	s_fakescope.create(b_fakescope, "r2\\fakescope"); //crookr
+	s_heatvision.create(b_heatvision, "r2\\heatvision"); //--DSR-- HeatVision
 	s_lut.create(b_lut, "r2\\lut");	
 	// OCCLUSION
 	s_occq.create(b_occq, "r2\\occq");
@@ -758,6 +767,8 @@ CRenderTarget::~CRenderTarget()
 	xr_delete(b_gasmask_drops);
 	xr_delete(b_gasmask_dudv);
 	xr_delete(b_nightvision);
+	xr_delete(b_fakescope); //crookr
+	xr_delete(b_heatvision); //--DSR-- HeatVision
 	xr_delete(b_lut);	
 	xr_delete(b_smaa);
 
diff --git a/src/Layers/xrRenderPC_R2/r2_rendertarget.h b/src/Layers/xrRenderPC_R2/r2_rendertarget.h
index 727029d..3b9e2be 100644
--- a/src/Layers/xrRenderPC_R2/r2_rendertarget.h
+++ b/src/Layers/xrRenderPC_R2/r2_rendertarget.h
@@ -39,6 +39,8 @@ public:
 	IBlender* b_gasmask_drops;
 	IBlender* b_gasmask_dudv;
 	IBlender* b_nightvision;
+	IBlender* b_fakescope; //crookr
+	IBlender* b_heatvision; //--DSR-- HeatVision
 	IBlender* b_lut;
 	
 	IBlender* b_smaa;	
@@ -68,7 +70,10 @@ public:
 	ref_rt rt_secondVP;		// 32bit		(r,g,b,a) --//#SM+#-- +SecondVP+
 	ref_rt rt_ui_pda;
 
+	ref_rt rt_fakescope; //crookr
+
 	ref_rt rt_dof;
+	ref_rt rt_Heat; //--DSR-- HeatVision
 	
 	ref_rt rt_blur_h_2;
 	ref_rt rt_blur_2;
@@ -122,6 +127,8 @@ private:
 	ref_shader s_gasmask_drops;
 	ref_shader s_gasmask_dudv;
 	ref_shader s_nightvision;
+	ref_shader s_fakescope; //crookr
+	ref_shader s_heatvision; //--DSR-- HeatVision
 
 	ref_shader s_blur;	
 	ref_shader s_dof;
@@ -260,6 +267,8 @@ public:
 	void phase_gasmask_drops();
 	void phase_gasmask_dudv();
 	void phase_nightvision();
+	void phase_fakescope(); //crookr
+	void phase_heatvision(); //--DSR-- HeatVision
 	void phase_lut();	
 	void phase_smaa();
 		
diff --git a/src/Layers/xrRenderPC_R2/r2_rendertarget_phase_combine.cpp b/src/Layers/xrRenderPC_R2/r2_rendertarget_phase_combine.cpp
index bbec49c..443c2c0 100644
--- a/src/Layers/xrRenderPC_R2/r2_rendertarget_phase_combine.cpp
+++ b/src/Layers/xrRenderPC_R2/r2_rendertarget_phase_combine.cpp
@@ -276,6 +276,11 @@ void CRenderTarget::phase_combine()
 	if(ps_r2_nightvision > 0)
 		phase_nightvision();
 	
+	if (scope_fake_enabled)
+	{
+		phase_fakescope(); //crookr
+	}
+
     //SMAA
 	if (ps_smaa_quality)
 	{
diff --git a/src/Layers/xrRenderPC_R2/r2_types.h b/src/Layers/xrRenderPC_R2/r2_types.h
index 7033e17..3d3c50d 100644
--- a/src/Layers/xrRenderPC_R2/r2_types.h
+++ b/src/Layers/xrRenderPC_R2/r2_types.h
@@ -62,6 +62,9 @@
 #define		r2_RT_dof			"$user$dof"
 #define		r2_RT_ui			"$user$ui"
 
+#define		r2_RT_scopert		"$user$scopeRT" //crookr
+#define		r2_RT_heat			"$user$heat" //--DSR-- HeatVision
+
 #define		r2_RT_smaa_edgetex "$user$smaa_edgetex"
 #define		r2_RT_smaa_blendtex "$user$smaa_blendtex"
 
diff --git a/src/Layers/xrRenderPC_R3/blender_nightvision.cpp b/src/Layers/xrRenderPC_R3/blender_nightvision.cpp
index 1a5d5c6..6cecd9f 100644
--- a/src/Layers/xrRenderPC_R3/blender_nightvision.cpp
+++ b/src/Layers/xrRenderPC_R3/blender_nightvision.cpp
@@ -3,11 +3,22 @@
 #include "blender_nightvision.h"
 
 CBlender_nightvision::CBlender_nightvision() { description.CLS = 0; }
+CBlender_fakescope::CBlender_fakescope() { description.CLS = 0; } //crookr
+CBlender_heatvision::CBlender_heatvision() { description.CLS = 0; } //--DSR-- HeatVision
+
 
 CBlender_nightvision::~CBlender_nightvision()
 {
 }
 
+CBlender_fakescope::~CBlender_fakescope() //crookr
+{
+}
+
+CBlender_heatvision::~CBlender_heatvision() //--DSR-- HeatVision
+{
+}
+
 void CBlender_nightvision::Compile(CBlender_Compile& C)
 {
 	IBlender::Compile(C);
@@ -66,3 +77,44 @@ void CBlender_nightvision::Compile(CBlender_Compile& C)
 		break;		
 	}
 }
+
+void CBlender_fakescope::Compile(CBlender_Compile& C) //crookr
+{
+	IBlender::Compile(C);
+
+	C.r_Pass("stub_screen_space", "fakescope", FALSE, FALSE, FALSE);
+	C.r_dx10Texture("s_position", r2_RT_P);
+	C.r_dx10Texture("s_image", r2_RT_generic0);
+	C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
+	C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
+	C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
+	C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
+
+	C.r_dx10Sampler("smp_base");
+	C.r_dx10Sampler("smp_nofilter");
+	C.r_dx10Sampler("smp_rtlinear");
+	C.r_End();
+
+}
+
+//--DSR-- HeatVision_start
+void CBlender_heatvision::Compile(CBlender_Compile& C)
+{
+	IBlender::Compile(C);
+	
+	C.r_Pass("stub_screen_space", "heatvision", FALSE, FALSE, FALSE);
+	C.r_dx10Texture("s_position", r2_RT_P);
+	C.r_dx10Texture("s_image", r2_RT_generic0);
+	C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
+	C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
+	C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
+	C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
+
+	C.r_dx10Texture("s_heat", r2_RT_heat);
+
+	C.r_dx10Sampler("smp_base");
+	C.r_dx10Sampler("smp_nofilter");
+	C.r_dx10Sampler("smp_rtlinear");
+	C.r_End();
+}
+//--DSR-- HeatVision_end
diff --git a/src/Layers/xrRenderPC_R3/blender_nightvision.h b/src/Layers/xrRenderPC_R3/blender_nightvision.h
index 0801e41..8efe46d 100644
--- a/src/Layers/xrRenderPC_R3/blender_nightvision.h
+++ b/src/Layers/xrRenderPC_R3/blender_nightvision.h
@@ -13,3 +13,32 @@ public:
 	CBlender_nightvision();
 	virtual ~CBlender_nightvision();
 };
+
+//crookr
+class CBlender_fakescope : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "fakescope"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_fakescope();
+	virtual ~CBlender_fakescope();
+};
+
+//--DSR-- HeatVision_start
+class CBlender_heatvision : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "heatvision"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_heatvision();
+	virtual ~CBlender_heatvision();
+};
+//--DSR-- HeatVision_end
diff --git a/src/Layers/xrRenderPC_R3/r2_types.h b/src/Layers/xrRenderPC_R3/r2_types.h
index 6597231..0414f9c 100644
--- a/src/Layers/xrRenderPC_R3/r2_types.h
+++ b/src/Layers/xrRenderPC_R3/r2_types.h
@@ -70,6 +70,9 @@
 #define		r2_RT_dof			"$user$dof"
 #define		r2_RT_ui			"$user$ui"
 
+#define		r2_RT_scopert		"$user$scopeRT" //crookr
+#define		r2_RT_heat			"$user$heat" //--DSR-- HeatVision
+
 #define		r2_RT_smaa_edgetex "$user$smaa_edgetex"
 #define		r2_RT_smaa_blendtex "$user$smaa_blendtex"
 
diff --git a/src/Layers/xrRenderPC_R3/r3.cpp b/src/Layers/xrRenderPC_R3/r3.cpp
index 1824690..708bdf4 100644
--- a/src/Layers/xrRenderPC_R3/r3.cpp
+++ b/src/Layers/xrRenderPC_R3/r3.cpp
@@ -757,24 +757,35 @@ BOOL CRender::occ_visible(Fbox& P) { return HOM.visible(P); }
 void CRender::add_Visual(IRenderVisual* V) { add_leafs_Dynamic((dxRender_Visual*)V, V->_ignore_optimization); }
 void CRender::add_Geometry(IRenderVisual* V) { add_Static((dxRender_Visual*)V, View->getMask()); }
 
+// demonized: add user defined rotation to wallmark
 void CRender::add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* verts, float ttl, bool ignore_opt, bool random_rotation)
+{
+	add_StaticWallmark(S, P, s, T, verts, ttl, ignore_opt, random_rotation ? ::Random.randF(-20.f, 20.f) : 0.f);
+}
+
+void CRender::add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* verts, float ttl, bool ignore_opt, float rotation)
 {
 	if (T->suppress_wm) return;
-	VERIFY2(_valid(P) && _valid(s) && T && verts && (s>EPS_L), "Invalid static wallmark params");
-	Wallmarks->AddStaticWallmark(T, verts, P, &*S, s, ttl, ignore_opt, random_rotation);
+	VERIFY2(_valid(P) && _valid(s) && T && verts && (s > EPS_L), "Invalid static wallmark params");
+	Wallmarks->AddStaticWallmark(T, verts, P, &*S, s, ttl, ignore_opt, rotation);
 }
 
 void CRender::add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, bool random_rotation)
 {
-	dxWallMarkArray* pWMA = (dxWallMarkArray *)pArray;
+	add_StaticWallmark(pArray, P, s, T, V, ttl, ignore_opt, random_rotation ? ::Random.randF(-20.f, 20.f) : 0.f);
+}
+
+void CRender::add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, float rotation)
+{
+	dxWallMarkArray* pWMA = (dxWallMarkArray*)pArray;
 	ref_shader* pShader = pWMA->dxGenerateWallmark();
-	if (pShader) add_StaticWallmark(*pShader, P, s, T, V, ttl, ignore_opt, random_rotation);
+	if (pShader) add_StaticWallmark(*pShader, P, s, T, V, ttl, ignore_opt, rotation);
 }
 
 void CRender::add_StaticWallmark(const wm_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V)
 {
 	dxUIShader* pShader = (dxUIShader*)&*S;
-	add_StaticWallmark(pShader->hShader, P, s, T, V);
+	add_StaticWallmark(pShader->hShader, P, s, T, V, 0.0f, false, true);
 }
 
 void CRender::clear_static_wallmarks()
diff --git a/src/Layers/xrRenderPC_R3/r3.h b/src/Layers/xrRenderPC_R3/r3.h
index 3f8201b..d079773 100644
--- a/src/Layers/xrRenderPC_R3/r3.h
+++ b/src/Layers/xrRenderPC_R3/r3.h
@@ -299,8 +299,12 @@ public:
 	virtual void add_Geometry(IRenderVisual* V); // add visual(s)	(all culling performed)
 
 	// wallmarks
+	// demonized: add user defined rotation to wallmark
 	virtual void add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl = 0.f, bool ignore_opt = false, bool random_rotation = true);
+	virtual void add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, float rotation);
 	virtual void add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl = 0.f, bool ignore_opt = false, bool random_rotation = true);
+	virtual void add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, float rotation);
+
 	virtual void add_StaticWallmark(const wm_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V);
 	virtual void clear_static_wallmarks();
 	virtual void add_SkeletonWallmark(intrusive_ptr<CSkeletonWallmark> wm);
diff --git a/src/Layers/xrRenderPC_R3/r3_R_render.cpp b/src/Layers/xrRenderPC_R3/r3_R_render.cpp
index 2421e35..39c0de8 100644
--- a/src/Layers/xrRenderPC_R3/r3_R_render.cpp
+++ b/src/Layers/xrRenderPC_R3/r3_R_render.cpp
@@ -145,12 +145,22 @@ void CRender::render_main(Fmatrix& m_ViewProjection, bool _fportals)
 				break; // exit loop on frustums
 			}
 		}
-		if (g_pGameLevel && (phase == PHASE_NORMAL)) g_hud->Render_Last(); // HUD
+		if (g_pGameLevel && (phase == PHASE_NORMAL))
+		{
+			g_hud->Render_Last(); // HUD
+			if (g_hud->RenderActiveItemUIQuery())
+				r_dsgraph_render_hud_ui();
+		}
 	}
 	else
 	{
 		set_Object(0);
-		if (g_pGameLevel && (phase == PHASE_NORMAL)) g_hud->Render_Last(); // HUD
+		if (g_pGameLevel && (phase == PHASE_NORMAL))
+		{
+			g_hud->Render_Last(); // HUD
+			if (g_hud->RenderActiveItemUIQuery())
+				r_dsgraph_render_hud_ui();
+		}
 	}
 }
 
@@ -435,12 +445,6 @@ void CRender::Render()
 		Target->phase_scene_end();
 	}
 
-	if (g_hud && g_hud->RenderActiveItemUIQuery())
-	{
-		Target->phase_wallmarks();
-		r_dsgraph_render_hud_ui();
-	}
-
 	// Wall marks
 	if (Wallmarks)
 	{
diff --git a/src/Layers/xrRenderPC_R3/r3_rendertarget.cpp b/src/Layers/xrRenderPC_R3/r3_rendertarget.cpp
index 9c5ecf2..229f82d 100644
--- a/src/Layers/xrRenderPC_R3/r3_rendertarget.cpp
+++ b/src/Layers/xrRenderPC_R3/r3_rendertarget.cpp
@@ -351,6 +351,8 @@ CRenderTarget::CRenderTarget()
 	b_gasmask_drops = xr_new<CBlender_gasmask_drops>();
 	b_gasmask_dudv = xr_new<CBlender_gasmask_dudv>();
 	b_nightvision = xr_new<CBlender_nightvision>();
+	b_fakescope = xr_new<CBlender_fakescope>(); //crookr
+	b_heatvision = xr_new<CBlender_heatvision>(); //--DSR-- HeatVision
 	b_lut = xr_new<CBlender_lut>();
 	b_smaa = xr_new<CBlender_smaa>();
 
@@ -430,6 +432,12 @@ CRenderTarget::CRenderTarget()
 		rt_Generic_1.create(r2_RT_generic1, w, h, D3DFMT_A8R8G8B8, 1);
 		rt_Generic.create(r2_RT_generic, w, h, D3DFMT_A8R8G8B8, 1);
 
+		rt_fakescope.create(r2_RT_scopert, w, h, D3DFMT_A8R8G8B8, 1); //crookr fakescope
+
+		//--DSR-- HeatVision_start
+		rt_Heat.create(r2_RT_heat, w, h, D3DFMT_A8R8G8B8, SampleCount);
+		//--DSR-- HeatVision_end
+
         if (RImplementation.o.dx10_msaa)
             rt_Generic_temp.create("$user$generic_temp", w, h, D3DFMT_A8R8G8B8, SampleCount);
         else
@@ -477,6 +485,8 @@ CRenderTarget::CRenderTarget()
 	s_gasmask_drops.create(b_gasmask_drops, "r2\\gasmask_drops");
 	s_gasmask_dudv.create(b_gasmask_dudv, "r2\\gasmask_dudv");
 	s_nightvision.create(b_nightvision, "r2\\nightvision");
+	s_fakescope.create(b_fakescope, "r2\\fakescope"); //crookr
+	s_heatvision.create(b_heatvision, "r2\\heatvision"); //--DSR-- HeatVision
 	s_lut.create(b_lut, "r2\\lut");	
 	// OCCLUSION
 	s_occq.create(b_occq, "r2\\occq");
@@ -1143,6 +1153,8 @@ CRenderTarget::~CRenderTarget()
 	xr_delete(b_gasmask_drops);
 	xr_delete(b_gasmask_dudv);
 	xr_delete(b_nightvision);
+	xr_delete(b_fakescope); //crookr
+	xr_delete(b_heatvision); //--DSR-- HeatVision
 	xr_delete(b_lut);	
 	xr_delete(b_smaa);
 
diff --git a/src/Layers/xrRenderPC_R3/r3_rendertarget.h b/src/Layers/xrRenderPC_R3/r3_rendertarget.h
index 6d332ba..b3cbb66 100644
--- a/src/Layers/xrRenderPC_R3/r3_rendertarget.h
+++ b/src/Layers/xrRenderPC_R3/r3_rendertarget.h
@@ -58,6 +58,8 @@ public:
 	IBlender* b_gasmask_drops;
 	IBlender* b_gasmask_dudv;
 	IBlender* b_nightvision;
+	IBlender* b_fakescope; //crookr
+	IBlender* b_heatvision; //--DSR-- HeatVision
 	IBlender* b_lut;
 	
 	IBlender* b_smaa;	
@@ -93,6 +95,11 @@ public:
 	ref_rt rt_secondVP;		// 32bit		(r,g,b,a) --//#SM+#-- +SecondVP+
 	ref_rt rt_ui_pda;
 
+
+	ref_rt rt_fakescope; //crookr
+	
+	ref_rt rt_Heat; //--DSR-- HeatVision
+
 	ref_rt rt_dof;
 
 	ref_rt rt_blur_h_2;
@@ -171,6 +178,8 @@ private:
 	ref_shader s_gasmask_drops;
 	ref_shader s_gasmask_dudv;
 	ref_shader s_nightvision;
+	ref_shader s_fakescope; //crookr
+	ref_shader s_heatvision; //--DSR-- HeatVision
 	ref_shader s_lut;	
 
     ref_shader s_smaa;
@@ -298,6 +307,8 @@ public:
 	void phase_gasmask_drops();
 	void phase_gasmask_dudv();
 	void phase_nightvision();
+	void phase_fakescope(); //crookr
+	void phase_heatvision(); //--DSR-- HeatVision
 	void phase_lut();	
 	void phase_smaa();	
 
diff --git a/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_combine.cpp b/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_combine.cpp
index fe27772..f7576be 100644
--- a/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_combine.cpp
+++ b/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_combine.cpp
@@ -396,6 +396,11 @@ void CRenderTarget::phase_combine()
 	
 	if(ps_r2_nightvision > 0)
 		phase_nightvision();
+
+	if (scope_fake_enabled)
+	{
+		phase_fakescope(); //crookr
+	}
 	
     //SMAA
 	if (ps_smaa_quality)
diff --git a/src/Layers/xrRenderPC_R4/blender_nightvision.cpp b/src/Layers/xrRenderPC_R4/blender_nightvision.cpp
index 1a5d5c6..a88a9a5 100644
--- a/src/Layers/xrRenderPC_R4/blender_nightvision.cpp
+++ b/src/Layers/xrRenderPC_R4/blender_nightvision.cpp
@@ -3,11 +3,23 @@
 #include "blender_nightvision.h"
 
 CBlender_nightvision::CBlender_nightvision() { description.CLS = 0; }
+CBlender_fakescope::CBlender_fakescope() { description.CLS = 0; } //crookr
+CBlender_heatvision::CBlender_heatvision() { description.CLS = 0;  } //--DSR-- Heatvision
 
 CBlender_nightvision::~CBlender_nightvision()
 {
 }
 
+CBlender_fakescope::~CBlender_fakescope() //crookr
+{
+}
+
+//--DSR-- HeatVision_start
+CBlender_heatvision::~CBlender_heatvision()
+{
+}
+//--DSR-- HeatVision_end
+
 void CBlender_nightvision::Compile(CBlender_Compile& C)
 {
 	IBlender::Compile(C);
@@ -30,6 +42,9 @@ void CBlender_nightvision::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
 		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
 		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);		
+
+		C.r_dx10Texture("s_heat", r2_RT_heat); //--DSR-- HeatVision
+
 			
 		C.r_dx10Sampler("smp_base");
 		C.r_dx10Sampler("smp_nofilter");
@@ -45,6 +60,8 @@ void CBlender_nightvision::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
 		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);		
 		
+		C.r_dx10Texture("s_heat", r2_RT_heat); //--DSR-- HeatVision
+
 		C.r_dx10Sampler("smp_base");
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_rtlinear");
@@ -59,6 +76,8 @@ void CBlender_nightvision::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
 		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);		
 		
+		C.r_dx10Texture("s_heat", r2_RT_heat); //--DSR-- HeatVision
+
 		C.r_dx10Sampler("smp_base");
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_rtlinear");
@@ -66,3 +85,63 @@ void CBlender_nightvision::Compile(CBlender_Compile& C)
 		break;		
 	}
 }
+
+void CBlender_fakescope::Compile(CBlender_Compile& C) //crookr
+{
+	IBlender::Compile(C);
+
+	C.r_Pass("stub_screen_space", "fakescope", FALSE, FALSE, FALSE);
+	C.r_dx10Texture("s_position", r2_RT_P);
+	C.r_dx10Texture("s_image", r2_RT_generic0);
+	C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
+	C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
+	C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
+	C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
+	//C.r_dx10Texture("s_scope", "wpn\\wpn_crosshair_pso1");
+	//C.r_dx10Texture("s_scope", scope_fake_texture);
+	C.r_dx10Texture("s_scope", r2_RT_scopert);
+
+
+	C.r_dx10Sampler("smp_base");
+	C.r_dx10Sampler("smp_nofilter");
+	C.r_dx10Sampler("smp_rtlinear");
+	C.r_End();
+
+}
+
+//--DSR-- HeatVision_start
+void CBlender_heatvision::Compile(CBlender_Compile& C) 
+{
+	IBlender::Compile(C);
+
+	switch (C.iElement)
+	{
+	case 0: //Dummy shader - because IDK what gonna happen when r2_nightvision will be 0
+		C.r_Pass("stub_screen_space", "copy_nomsaa", FALSE, FALSE, FALSE);
+		C.r_dx10Texture("s_generic", r2_RT_generic0);
+
+		C.r_dx10Sampler("smp_base");
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_rtlinear");
+		C.r_End();
+		break;
+	case 1:
+		C.r_Pass("stub_screen_space", "heatvision", FALSE, FALSE, FALSE);
+		C.r_dx10Texture("s_position", r2_RT_P);
+		C.r_dx10Texture("s_image", r2_RT_generic0);
+		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
+		C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
+		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
+		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
+
+		C.r_dx10Texture("s_heat", r2_RT_heat); //--DSR-- HeatVision
+
+
+		C.r_dx10Sampler("smp_base");
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_rtlinear");
+		C.r_End();
+		break;
+	}
+}
+//--DSR-- HeatVision_end
diff --git a/src/Layers/xrRenderPC_R4/blender_nightvision.h b/src/Layers/xrRenderPC_R4/blender_nightvision.h
index 0801e41..8efe46d 100644
--- a/src/Layers/xrRenderPC_R4/blender_nightvision.h
+++ b/src/Layers/xrRenderPC_R4/blender_nightvision.h
@@ -13,3 +13,32 @@ public:
 	CBlender_nightvision();
 	virtual ~CBlender_nightvision();
 };
+
+//crookr
+class CBlender_fakescope : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "fakescope"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_fakescope();
+	virtual ~CBlender_fakescope();
+};
+
+//--DSR-- HeatVision_start
+class CBlender_heatvision : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "heatvision"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_heatvision();
+	virtual ~CBlender_heatvision();
+};
+//--DSR-- HeatVision_end
diff --git a/src/Layers/xrRenderPC_R4/light_vis.cpp b/src/Layers/xrRenderPC_R4/light_vis.cpp
index f4334ea..ca2ca94 100644
--- a/src/Layers/xrRenderPC_R4/light_vis.cpp
+++ b/src/Layers/xrRenderPC_R4/light_vis.cpp
@@ -36,7 +36,9 @@ void light::vis_prepare()
 	if (ps_r2_ls_flags.test(R2FLAG_EXP_DONT_TEST_UNSHADOWED) && !flags.bShadow) skiptest = true;
 	if (ps_r2_ls_flags.test(R2FLAG_EXP_DONT_TEST_SHADOWED) && flags.bShadow) skiptest = true;
 
-	if (skiptest || Device.vCameraPosition.distance_to(spatial.sphere.P) <= (spatial.sphere.R * 1.01f + safe_area))
+	vis.distance = Device.vCameraPosition.distance_to(spatial.sphere.P);
+
+	if (skiptest || vis.distance <= (spatial.sphere.R * 1.01f + safe_area))
 	{
 		// small error
 		vis.visible = true;
diff --git a/src/Layers/xrRenderPC_R4/r2_R_lights.cpp b/src/Layers/xrRenderPC_R4/r2_R_lights.cpp
index a66b3e0..378121f 100644
--- a/src/Layers/xrRenderPC_R4/r2_R_lights.cpp
+++ b/src/Layers/xrRenderPC_R4/r2_R_lights.cpp
@@ -7,6 +7,24 @@ IC bool pred_area(light* _1, light* _2)
 	return a0 > a1; // reverse -> descending
 }
 
+bool check_grass_shadow(light* L, CFrustum VB)
+{
+	// Grass shadows are allowed?
+	if (ps_ssfx_grass_shadows.x < 3 || !psDeviceFlags2.test(rsGrassShadow))
+		return false;
+
+	// Inside the range?
+	if (L->vis.distance > ps_ssfx_grass_shadows.z)
+		return false;
+
+	// Is in view? L->vis.visible?
+	u32 mask = 0xff;
+	if (!VB.testSphere(L->position, L->range * 0.6f, mask))
+		return false;
+
+	return true;
+}
+
 void CRender::render_lights(light_Package& LP)
 {
 	//////////////////////////////////////////////////////////////////////////
@@ -117,6 +135,15 @@ void CRender::render_lights(light_Package& LP)
 				RCache.set_xform_view(L->X.S.view);
 				RCache.set_xform_project(L->X.S.project);
 				r_dsgraph_render_graph(0);
+				if (Details)
+				{
+					if (check_grass_shadow(L, ViewBase))
+					{
+						Details->fade_distance = -1; // Use light position to calc "fade"
+						Details->light_position.set(L->position);
+						Details->Render();
+					}
+				}
 				L->X.S.transluent = FALSE;
 				if (bSpecial)
 				{
diff --git a/src/Layers/xrRenderPC_R4/r2_R_sun.cpp b/src/Layers/xrRenderPC_R4/r2_R_sun.cpp
index 7d6c6e9..2b0671c 100644
--- a/src/Layers/xrRenderPC_R4/r2_R_sun.cpp
+++ b/src/Layers/xrRenderPC_R4/r2_R_sun.cpp
@@ -1093,13 +1093,13 @@ void CRender::init_cacades()
 	float fBias = -0.0000025f;
 	//	float size = MAP_SIZE_START;
 	m_sun_cascades[0].reset_chain = true;
-	m_sun_cascades[0].size = 20; 
+	m_sun_cascades[0].size = ps_ssfx_shadow_cascades.x; //20
 	m_sun_cascades[0].bias = m_sun_cascades[0].size * fBias;
 
-	m_sun_cascades[1].size = 40;
+	m_sun_cascades[1].size = ps_ssfx_shadow_cascades.y; //40
 	m_sun_cascades[1].bias = m_sun_cascades[1].size * fBias;
 
-	m_sun_cascades[2].size = 160;
+	m_sun_cascades[2].size = ps_ssfx_shadow_cascades.z; //160
 	m_sun_cascades[2].bias = m_sun_cascades[2].size * fBias;
 
 	// 	for( u32 i = 0; i < cascade_count; ++i )
@@ -1384,8 +1384,11 @@ void CRender::render_sun_cascade(u32 cascade_ind)
 			RCache.set_xform_view(Fidentity);
 			RCache.set_xform_project(fuckingsun->X.D.combine);
 			r_dsgraph_render_graph(0);
-			if (ps_r2_ls_flags.test(R2FLAG_SUN_DETAILS))
+			if (psDeviceFlags2.test(rsGrassShadow) && cascade_ind <= ps_ssfx_grass_shadows.x)
+			{
+				Details->fade_distance = dm_fade * dm_fade * ps_ssfx_grass_shadows.y;
 				Details->Render();
+			}
 			fuckingsun->X.D.transluent = FALSE;
 			if (bSpecial)
 			{
diff --git a/src/Layers/xrRenderPC_R4/r2_types.h b/src/Layers/xrRenderPC_R4/r2_types.h
index 18a11d4..723d606 100644
--- a/src/Layers/xrRenderPC_R4/r2_types.h
+++ b/src/Layers/xrRenderPC_R4/r2_types.h
@@ -69,6 +69,9 @@
 #define		r2_RT_dof			"$user$dof"
 #define		r2_RT_ui			"$user$ui"
 
+#define		r2_RT_scopert		"$user$scopeRT" //crookr
+#define		r2_RT_heat			"$user$heat" //--DSR-- HeatVision
+
 #define		r2_RT_smaa_edgetex "$user$smaa_edgetex"
 #define		r2_RT_smaa_blendtex "$user$smaa_blendtex"
 
diff --git a/src/Layers/xrRenderPC_R4/r4.cpp b/src/Layers/xrRenderPC_R4/r4.cpp
index 77fb925..9ef4c87 100644
--- a/src/Layers/xrRenderPC_R4/r4.cpp
+++ b/src/Layers/xrRenderPC_R4/r4.cpp
@@ -614,6 +614,9 @@ void CRender::OnFrame()
 		Device.seqParallel.insert(Device.seqParallel.begin(),
 			fastdelegate::FastDelegate0<>(&HOM, &CHOM::MT_RENDER));
 	}
+
+	if (Details)
+		g_pGamePersistent->GrassBendersUpdateAnimations();
 }
 
 // Particles
@@ -777,24 +780,35 @@ BOOL CRender::occ_visible(Fbox& P) { return HOM.visible(P); }
 void CRender::add_Visual(IRenderVisual* V) { add_leafs_Dynamic((dxRender_Visual*)V, V->_ignore_optimization); }
 void CRender::add_Geometry(IRenderVisual* V) { add_Static((dxRender_Visual*)V, View->getMask()); }
 
+// demonized: add user defined rotation to wallmark
 void CRender::add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* verts, float ttl, bool ignore_opt, bool random_rotation)
+{
+	add_StaticWallmark(S, P, s, T, verts, ttl, ignore_opt, random_rotation ? ::Random.randF(-20.f, 20.f) : 0.f);
+}
+
+void CRender::add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* verts, float ttl, bool ignore_opt, float rotation)
 {
 	if (T->suppress_wm) return;
-	VERIFY2(_valid(P) && _valid(s) && T && verts && (s>EPS_L), "Invalid static wallmark params");
-	Wallmarks->AddStaticWallmark(T, verts, P, &*S, s, ttl, ignore_opt, random_rotation);
+	VERIFY2(_valid(P) && _valid(s) && T && verts && (s > EPS_L), "Invalid static wallmark params");
+	Wallmarks->AddStaticWallmark(T, verts, P, &*S, s, ttl, ignore_opt, rotation);
 }
 
 void CRender::add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, bool random_rotation)
 {
-	dxWallMarkArray* pWMA = (dxWallMarkArray *)pArray;
+	add_StaticWallmark(pArray, P, s, T, V, ttl, ignore_opt, random_rotation ? ::Random.randF(-20.f, 20.f) : 0.f);
+}
+
+void CRender::add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, float rotation)
+{
+	dxWallMarkArray* pWMA = (dxWallMarkArray*)pArray;
 	ref_shader* pShader = pWMA->dxGenerateWallmark();
-	if (pShader) add_StaticWallmark(*pShader, P, s, T, V, ttl, ignore_opt, random_rotation);
+	if (pShader) add_StaticWallmark(*pShader, P, s, T, V, ttl, ignore_opt, rotation);
 }
 
 void CRender::add_StaticWallmark(const wm_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V)
 {
 	dxUIShader* pShader = (dxUIShader*)&*S;
-	add_StaticWallmark(pShader->hShader, P, s, T, V);
+	add_StaticWallmark(pShader->hShader, P, s, T, V, 0.0f, false, true);
 }
 
 void CRender::clear_static_wallmarks()
@@ -1223,6 +1237,8 @@ HRESULT CRender::shader_compile(
 	char c_ssao [32];
 	char c_sun_quality [32];
 	char c_smaa_quality [32];
+	
+	char c_inter_grass[32];
 
 	char sh_name[MAX_PATH] = "";
 
@@ -1680,6 +1696,27 @@ HRESULT CRender::shader_compile(
 	}
 	sh_name[len] = '0' + char(o.dx10_minmax_sm != 0);
 	++len;
+	
+	if (ps_ssfx_grass_interactive.y > 0)
+	{
+		xr_sprintf(c_inter_grass, "%d", u8(ps_ssfx_grass_interactive.y));
+		defines[def_it].Name = "SSFX_INT_GRASS";
+		defines[def_it].Definition = c_inter_grass;
+		def_it++;
+		xr_strcat(sh_name, c_inter_grass);
+		len += xr_strlen(c_inter_grass);
+	}
+	else
+	{
+		sh_name[len] = '0';
+		++len;
+	}
+
+	defines[def_it].Name = "SSFX_MODEXE";
+	defines[def_it].Definition = "1";
+	def_it++;
+	sh_name[len] = '1';
+	++len;
 
 	//Be carefull!!!!! this should be at the end to correctly generate
 	//compiled shader name;
diff --git a/src/Layers/xrRenderPC_R4/r4.h b/src/Layers/xrRenderPC_R4/r4.h
index 9ae8b61..ebd3821 100644
--- a/src/Layers/xrRenderPC_R4/r4.h
+++ b/src/Layers/xrRenderPC_R4/r4.h
@@ -233,6 +233,9 @@ public:
 		o_hemi = 0.75f * LT.get_hemi();
 		//o_hemi						= 0.5f*LT.get_hemi			()	;
 		o_sun = 0.75f * LT.get_sun();
+		//--DSR-- HeatVision_start
+		RCache.hemi.set_hotness(O->GetHotness(), O->GetTransparency(), 0.f, 0.f);
+		//--DSR-- HeatVision_end
 		CopyMemory(o_hemi_cube, LT.get_hemi_cube(), CROS_impl::NUM_FACES*sizeof(float));
 	}
 
@@ -248,6 +251,8 @@ public:
 #ifdef	DEBUG
         if (ps_r2_ls_flags.test(R2FLAG_GLOBALMATERIAL))	mtl=ps_r2_gmaterial;
 #endif
+		if (!T || T && !T->m_is_hot)
+			RCache.hemi.set_hotness(0.f, 0.f, 0.f, 0.f);
 		RCache.hemi.set_material(o_hemi, o_sun, 0, (mtl < 5 ? (mtl + .5f) / 4.f : mtl));
 		RCache.hemi.set_pos_faces(o_hemi_cube[CROS_impl::CUBE_FACE_POS_X],
 		                          o_hemi_cube[CROS_impl::CUBE_FACE_POS_Y],
@@ -300,8 +305,12 @@ public:
 	virtual void add_Geometry(IRenderVisual* V); // add visual(s)	(all culling performed)
 
 	// wallmarks
+	// demonized: add user defined rotation to wallmark
 	virtual void add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl = 0.f, bool ignore_opt = false, bool random_rotation = true);
+	virtual void add_StaticWallmark(ref_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, float rotation);
 	virtual void add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl = 0.f, bool ignore_opt = false, bool random_rotation = true);
+	virtual void add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, float rotation);
+
 	virtual void add_StaticWallmark(const wm_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V);
 	virtual void clear_static_wallmarks();
 	virtual void add_SkeletonWallmark(intrusive_ptr<CSkeletonWallmark> wm);
diff --git a/src/Layers/xrRenderPC_R4/r4_R_render.cpp b/src/Layers/xrRenderPC_R4/r4_R_render.cpp
index 46e1c03..f520c80 100644
--- a/src/Layers/xrRenderPC_R4/r4_R_render.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_R_render.cpp
@@ -145,12 +145,22 @@ void CRender::render_main(Fmatrix& m_ViewProjection, bool _fportals)
 				break; // exit loop on frustums
 			}
 		}
-		if (g_pGameLevel && (phase == PHASE_NORMAL)) g_hud->Render_Last(); // HUD
+		if (g_pGameLevel && (phase == PHASE_NORMAL))
+		{
+			g_hud->Render_Last(); // HUD
+			if (g_hud->RenderActiveItemUIQuery())
+				r_dsgraph_render_hud_ui();
+		}
 	}
 	else
 	{
 		set_Object(0);
-		if (g_pGameLevel && (phase == PHASE_NORMAL)) g_hud->Render_Last(); // HUD
+		if (g_pGameLevel && (phase == PHASE_NORMAL))
+		{
+			g_hud->Render_Last(); // HUD
+			if (g_hud->RenderActiveItemUIQuery())
+				r_dsgraph_render_hud_ui();
+		}
 	}
 }
 
@@ -435,12 +445,6 @@ void CRender::Render()
 		Target->phase_scene_end();
 	}
 
-	if (g_hud && g_hud->RenderActiveItemUIQuery())
-	{
-		Target->phase_wallmarks();
-		r_dsgraph_render_hud_ui();
-	}
-
 	// Wall marks
 	if (Wallmarks)
 	{
@@ -538,6 +542,9 @@ void CRender::Render()
 		Target->phase_combine();
 	}
 
+	if (Details)
+		Details->details_clear();
+
 	VERIFY(0==mapDistort.size());
 }
 
@@ -585,4 +592,4 @@ void CRender::RenderToTarget(RRT target)
 	HW.m_pSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBuffer);
 	HW.pContext->CopyResource((*RT)->pSurface, pBuffer);
 	pBuffer->Release();
-}
\ No newline at end of file
+}
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp b/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp
index 4280e5f..6ca6788 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp
@@ -350,6 +350,8 @@ CRenderTarget::CRenderTarget()
 	b_gasmask_drops = xr_new<CBlender_gasmask_drops>();
 	b_gasmask_dudv = xr_new<CBlender_gasmask_dudv>();
 	b_nightvision = xr_new<CBlender_nightvision>();
+	b_fakescope = xr_new<CBlender_fakescope>(); //crookr
+	b_heatvision = xr_new<CBlender_heatvision>(); //--DSR-- HeatVision
 	b_lut = xr_new<CBlender_lut>();
 	b_smaa = xr_new<CBlender_smaa>();
 
@@ -434,6 +436,13 @@ CRenderTarget::CRenderTarget()
 		rt_Generic_1.create(r2_RT_generic1, w, h, D3DFMT_A8R8G8B8, 1);
 		rt_Generic.create(r2_RT_generic, w, h, D3DFMT_A8R8G8B8, 1);
 
+
+		rt_fakescope.create(r2_RT_scopert, w, h, D3DFMT_A8R8G8B8, 1); //crookr fakescope
+
+		//--DSR-- HeatVision_start
+		rt_Heat.create(r2_RT_heat, w, h, D3DFMT_A8R8G8B8, SampleCount);
+		//--DSR-- HeatVision_end
+
         if (RImplementation.o.dx10_msaa)
             rt_Generic_temp.create("$user$generic_temp", w, h, D3DFMT_A8R8G8B8, SampleCount);
         else
@@ -479,6 +488,10 @@ CRenderTarget::CRenderTarget()
 	s_gasmask_drops.create(b_gasmask_drops, "r2\\gasmask_drops");
 	s_gasmask_dudv.create(b_gasmask_dudv, "r2\\gasmask_dudv");
 	s_nightvision.create(b_nightvision, "r2\\nightvision");
+
+	s_fakescope.create(b_fakescope, "r2\\fakescope"); //crookr
+
+	s_heatvision.create(b_heatvision, "r2\\heatvision"); //--DSR-- HeatVision
 	s_lut.create(b_lut, "r2\\lut");	
 	// OCCLUSION
 	s_occq.create(b_occq, "r2\\occq");
@@ -1156,6 +1169,8 @@ CRenderTarget::~CRenderTarget()
 	xr_delete(b_gasmask_drops);
 	xr_delete(b_gasmask_dudv);
 	xr_delete(b_nightvision);
+	xr_delete(b_fakescope); //crookr
+	xr_delete(b_heatvision); //--DSR-- HeatVision
 	xr_delete(b_lut);	
 	xr_delete(b_smaa);
 
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget.h b/src/Layers/xrRenderPC_R4/r4_rendertarget.h
index 37da92e..846ab97 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget.h
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget.h
@@ -58,6 +58,8 @@ public:
 	IBlender* b_gasmask_drops;
 	IBlender* b_gasmask_dudv;
 	IBlender* b_nightvision;
+	IBlender* b_fakescope; //crookr
+	IBlender* b_heatvision; //--DSR-- HeatVision
 	IBlender* b_lut;
 	IBlender* b_smaa;
 	// compute shader for hdao
@@ -83,6 +85,10 @@ public:
 	ref_rt rt_Position; // 64bit,	fat	(x,y,z,?)				(eye-space)
 	ref_rt rt_Color; // 64/32bit,fat	(r,g,b,specular-gloss)	(or decompressed MET-8-8-8-8)
 
+	//--DSR-- HeatVision_start
+	ref_rt rt_Heat;
+	//--DSR-- HeatVision_end
+
 	// 
 	ref_rt rt_Accumulator; // 64bit		(r,g,b,specular)
 	ref_rt rt_Accumulator_temp; // only for HW which doesn't feature fp16 blend
@@ -95,6 +101,9 @@ public:
 	
 	ref_rt rt_secondVP;	// 32bit		(r,g,b,a) --//#SM+#-- +SecondVP+
 
+
+	ref_rt rt_fakescope;	// crookr fakescope
+
 	ref_rt rt_dof;
 	ref_rt rt_ui_pda;
 	
@@ -174,7 +183,9 @@ private:
 	ref_shader s_pp_bloom;	
 	ref_shader s_gasmask_drops;
 	ref_shader s_gasmask_dudv;
-	ref_shader s_nightvision;	
+	ref_shader s_nightvision;
+	ref_shader s_fakescope; //crookr
+	ref_shader s_heatvision; //--DSR-- HeatVision
 	ref_shader s_smaa;
 
 	ref_shader s_lut;
@@ -300,6 +311,8 @@ public:
 	void phase_gasmask_drops();
 	void phase_gasmask_dudv();
 	void phase_nightvision();
+	void phase_fakescope(); //crookr
+	void phase_heatvision(); //--DSR-- HeatVision
 	void phase_lut();		
 	void phase_smaa();
 	void phase_scene_prepare();
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp
index 875ae48..3124093 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp
@@ -290,10 +290,12 @@ void CRenderTarget::phase_combine()
 	// Forward rendering
 	{
 		PIX_EVENT(Forward_rendering);
+		//--DSR-- HeatVision_start
 		if (!RImplementation.o.dx10_msaa)
-			u_setrt(rt_Generic_0, 0, 0, HW.pBaseZB); // LDR RT
+			u_setrt(rt_Generic_0, rt_Heat, 0, HW.pBaseZB); // LDR RT
 		else
-			u_setrt(rt_Generic_0_r, 0, 0, RImplementation.Target->rt_MSAADepth->pZRT); // LDR RT
+			u_setrt(rt_Generic_0_r, rt_Heat, 0, RImplementation.Target->rt_MSAADepth->pZRT); // LDR RT
+		//--DSR-- HeatVision_end
 		RCache.set_CullMode(CULL_CCW);
 		RCache.set_Stencil(FALSE);
 		RCache.set_ColorWriteEnable();
@@ -396,6 +398,16 @@ void CRenderTarget::phase_combine()
 	if(ps_r2_nightvision > 0)
 		phase_nightvision();
 	
+	//--DSR-- HeatVision_start
+	if (ps_r2_heatvision > 0)
+		phase_heatvision();
+	//--DSR-- HeatVision_end
+
+	if (scope_fake_enabled)
+	{
+		phase_fakescope(); //crookr
+	}
+
     //SMAA
 	if (ps_smaa_quality)
 	{
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_scene.cpp b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_scene.cpp
index 0b59b29..2d6adab 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_scene.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_scene.cpp
@@ -13,6 +13,9 @@ void CRenderTarget::phase_scene_prepare()
 
 		FLOAT ColorRGBA[4] = {0.0f, 0.0f, 0.0f, 0.0f};
 		HW.pContext->ClearRenderTargetView(rt_Position->pRT, ColorRGBA);
+		//--DSR-- HeatVision_start
+		HW.pContext->ClearRenderTargetView(rt_Heat->pRT, ColorRGBA);
+		//--DSR-- HeatVision_end
 
 		if (!RImplementation.o.dx10_msaa)
 			HW.pContext->ClearDepthStencilView(HW.pBaseZB, D3D_CLEAR_DEPTH | D3D_CLEAR_STENCIL, 1.0f, 0);
@@ -39,8 +42,10 @@ void CRenderTarget::phase_scene_begin()
 
 	// Targets, use accumulator for temporary storage
 	{
-		if (RImplementation.o.albedo_wo) u_setrt(rt_Position, rt_Accumulator, pZB);
-		else u_setrt(rt_Position, rt_Color, pZB);
+		//--DSR-- HeatVision_start
+		if (RImplementation.o.albedo_wo) u_setrt(rt_Position, rt_Accumulator, rt_Heat, pZB);
+		else u_setrt(rt_Position, rt_Color, rt_Heat, pZB);
+		//--DSR-- HeatVision_end
 	}
 
 
diff --git a/src/build_config_defines.h b/src/build_config_defines.h
index 3f15b2c..8158b52 100644
--- a/src/build_config_defines.h
+++ b/src/build_config_defines.h
@@ -6,7 +6,7 @@
 #define INVENTORY_UPGRADE_CALLBACKS						// calls lua function inventory_upgrades.effect_upgrade_item
 #define ACTOR_BEFORE_DEATH_CALLBACK						// For extending the life of the actor to fake death or do other tasks that need to happen before actor is dead
 #define INPUT_CALLBACKS									// (eKeyPress, eKeyRelease, eKeyHold)
-//#define MOUSE_INPUT_CALLBACKS							// (eMouseMove, eMouseWheel)
+#define MOUSE_INPUT_CALLBACKS							// (eMouseMove, eMouseWheel)
 #define ENGINE_LUA_ALIFE_STORAGE_MANAGER_CALLBACKS		// calls lua functions from engine in a script named alife_storage_manager.script  (alife_storage_manager.CALifeStorageManager_save) and (alife_storage_manager.CALifeStorageManager_load)
 #define ENGINE_LUA_ALIFE_UPDAGE_MANAGER_CALLBACKS		// calls lua function named on_before_change_level and on_after_new_game in _G.script when enabled
 //-CALLBACKS
diff --git a/src/xrCore/Xr_ini.cpp b/src/xrCore/Xr_ini.cpp
index 3f5ac84..cce213c 100644
--- a/src/xrCore/Xr_ini.cpp
+++ b/src/xrCore/Xr_ini.cpp
@@ -3,6 +3,14 @@
 
 #include "fs_internal.h"
 
+#include <functional>
+#include <regex>
+#include <unordered_map>
+#include <unordered_set>
+#include <vector>
+#include <algorithm>
+#include "mezz_stringbuffer.h"
+
 XRCORE_API CInifile const* pSettings = NULL;
 XRCORE_API CInifile const* pSettingsAuth = NULL;
 
@@ -177,8 +185,19 @@ CInifile::~CInifile()
 		xr_delete(*I);
 }
 
+std::unordered_map<std::string, std::vector<CInifile::Item>> OverrideModifyListData;
+
 static void insert_item(CInifile::Sect* tgt, const CInifile::Item& I)
 {
+	// demonized
+	// DLTX: add or remove item from the section parameter if it has a structure of "name = item1, item2, item3, ..."
+	// >name = item will add item to the list
+	// <name = item will remove item from the list
+	if (*I.first && (I.first.c_str()[0] == '<' || I.first.c_str()[0] == '>')) {
+		OverrideModifyListData[std::string(tgt->Name.c_str())].push_back(I);
+		return;
+	}
+
 	CInifile::SectIt_ sect_it = std::lower_bound(tgt->Data.begin(), tgt->Data.end(), *I.first, item_pred);
 	if (sect_it != tgt->Data.end() && sect_it->first.equal(I.first))
 	{
@@ -210,212 +229,750 @@ void CInifile::Load(IReader* F, LPCSTR path
 )
 {
 	R_ASSERT(F);
-	Sect* Current = 0;
-	string4096 str;
-	string4096 str2;
 
-	BOOL bInsideSTR = FALSE;
+	std::string DLTX_DELETE = "DLTX_DELETE";
 
-	while (!F->eof())
+	std::function<void(std::vector<std::string>*, std::vector<std::string>*, bool)> MergeParentSet = [](std::vector<std::string>* ParentsBase, std::vector<std::string>* ParentsOverride, bool bIncludeRemovers)
 	{
-		F->r_string(str, sizeof(str));
-		_Trim(str);
-		LPSTR comm = strchr(str, ';');
-		LPSTR comm_1 = strchr(str, '/');
-
-		if (comm_1 && (*(comm_1 + 1) == '/') && ((!comm) || (comm && (comm_1 < comm))))
+		for (std::string CurrentParent : *ParentsOverride)
 		{
-			comm = comm_1;
+			bool bIsParentRemoval = CurrentParent[0] == '!';
+
+			std::string StaleParentString = (!bIsParentRemoval ? "!" : "") + CurrentParent.substr(1);
+
+			for (auto It = ParentsBase->rbegin(); It != ParentsBase->rend(); It++)
+			{
+				if (*It == StaleParentString)
+				{
+					ParentsBase->erase(std::next(It).base());
+				}
+			}
+
+			if (bIncludeRemovers || !bIsParentRemoval)
+			{
+				ParentsBase->insert(ParentsBase->end(), CurrentParent);
+			}
 		}
+	};
+
+	string_path currentFileName;
+	std::unordered_map<std::string, std::unordered_map<std::string, bool>> OverrideToFilename;
+	std::unordered_map<std::string, std::string> SectionToFilename;
+
+	std::function<void
+		(
+		IReader*,
+		LPCSTR,
+		std::unordered_map<std::string, Sect>*,
+		std::unordered_map<std::string, std::vector<std::string>>*,
+		BOOL,
+		BOOL
+		)
+	> LTXLoad = [&]
+		(
+		IReader* F,
+		LPCSTR path,
+		std::unordered_map<std::string, Sect>* OutputData,
+		std::unordered_map<std::string, std::vector<std::string>>* ParentDataMap,
+		BOOL bOverridesOnly,
+		BOOL bIsRootFile
+		)
+	{
+		Sect* Current = 0;
+		MezzStringBuffer str;
+		MezzStringBuffer str2;
 
-#ifdef DEBUG
-        LPSTR comment = 0;
-#endif
-		if (comm)
+		BOOL bInsideSTR = FALSE;
+
+		BOOL bIsCurrentSectionOverride = FALSE;
+		BOOL bHasLoadedModFiles = FALSE;
+
+		std::function<std::vector<std::string>*(std::string)> GetParentStrings = [&](std::string SectionName)
 		{
-			//."bla-bla-bla;nah-nah-nah"
-			char quot = '"';
-			bool in_quot = false;
+			auto It = ParentDataMap->find(SectionName);
 
-			LPCSTR q1 = strchr(str, quot);
-			if (q1 && q1 < comm)
+			if (It == ParentDataMap->end())
 			{
-				LPCSTR q2 = strchr(++q1, quot);
-				if (q2 && q2 > comm)
-					in_quot = true;
+				ParentDataMap->insert(std::pair<std::string, std::vector<std::string>>(SectionName, std::vector<std::string>()));
+
+				It = ParentDataMap->find(SectionName);
 			}
 
-			if (!in_quot)
+			return &It->second;
+		};
+
+		auto GetParentsSetFromString = [&](const char* ParentString)
+		{
+			std::vector<std::string> ParentSet = std::vector<std::string>();
+
+			u32 ItemCount = _GetItemCount(ParentString);
+
+			for (u32 i = 0; i < ItemCount; i++)
 			{
-				*comm = 0;
-#ifdef DEBUG
-                comment = comm + 1;
-#endif
+				_GetItem(ParentString, i, str2, str2.GetSize());
+
+				ParentSet.insert(ParentSet.end(), str2.GetBuffer());
 			}
-		}
 
+			return ParentSet;
+		};
+
+		auto GetRegexMatch = [](std::string InputString, std::string PatternString)
+		{
+			std::regex Pattern = std::regex(PatternString);
+			std::smatch MatchResult;
+
+			std::regex_search(InputString, MatchResult, Pattern);
+
+			if (MatchResult.begin() == MatchResult.end())
+			{
+				return std::string();
+			}
+
+			return MatchResult.begin()->str();
+		};
+
+		auto IsFullRegexMatch = [](std::string InputString, std::string PatternString)
+		{
+			return std::regex_match(InputString, std::regex(PatternString));
+		};
 
-		if (str[0] && (str[0] == '#') && strstr(str, "#include")) //handle includes
+		const auto loadFile = [&, LTXLoad](const string_path _fn, const string_path inc_path, const string_path name)
 		{
-			string_path inc_name;
-			R_ASSERT(path&&path[0]);
-			if (_GetItem(str, 1, inc_name, '"'))
+			if (!allow_include_func || allow_include_func(_fn))
 			{
-				string_path fn, inc_path, folder;
-				strconcat(sizeof(fn), fn, path, inc_name);
-				_splitpath(fn, inc_path, folder, 0, 0);
-				xr_strcat(inc_path, sizeof(inc_path), folder);
+				IReader* I = FS.r_open(_fn);
+				R_ASSERT3(I, "Can't find include file:", name);
+
+				strcpy(currentFileName, name);
 
-				const auto loadFile = [&](const string_path _fn, const string_path name)
+				LTXLoad(I, inc_path, OutputData, ParentDataMap, bOverridesOnly, false);
+
+				FS.r_close(I);
+			}
+		};
+
+		auto StashCurrentSection = [&]()
+		{
+			if (Current && bIsCurrentSectionOverride == bOverridesOnly)
+			{
+				//store previous section
+				auto SectIt = OutputData->find(std::string(Current->Name.c_str()));
+				if (SectIt != OutputData->end())
 				{
-					if (!allow_include_func || allow_include_func(_fn))
+					if (!bIsCurrentSectionOverride)
 					{
-						IReader* I = FS.r_open(_fn);
-						R_ASSERT3(I, "Can't find include file:", name);
-						Load(I, inc_path, allow_include_func);
-						FS.r_close(I);
-					}
-				};
 
-				if (strstr(inc_name, "*.ltx"))
-				{
-					FS_FileSet fset;
-					FS.file_list(fset, inc_path, FS_ListFiles, inc_name);
+						Debug.fatal(DEBUG_INFO, "Duplicate section '%s' wasn't marked as an override.\n\nOverride section by prefixing it with '!' (![%s]) or give it a unique name.\n\nCheck this file and its DLTX mods:\n\"%s\",\nfile with section \"%s\",\nfile with duplicate \"%s\"", *Current->Name, *Current->Name, m_file_name, SectionToFilename[std::string(Current->Name.c_str())].c_str(), currentFileName);
+					}
 
-					for (FS_FileSet::iterator it = fset.begin(); it != fset.end(); it++)
+					//Overwrite existing override data
+					for (Item CurrentItem : Current->Data)
 					{
-						LPCSTR _name = it->name.c_str();
-						string_path _fn;
-						strconcat(sizeof(_fn), _fn, inc_path, _name);
-						loadFile(_fn, _name);
+						insert_item(&SectIt->second, CurrentItem);
 					}
+
+					OverrideToFilename[SectIt->first][currentFileName] = true;
 				}
 				else
-					loadFile(fn, inc_name);
+				{
+					OutputData->emplace(std::pair<std::string, Sect>(std::string(Current->Name.c_str()), *Current));
+					OverrideToFilename[std::string(Current->Name.c_str())][currentFileName] = true;
+					SectionToFilename[std::string(Current->Name.c_str())] = currentFileName;
+				}
 			}
-		}
-		else if (str[0] && (str[0] == '[')) //new section ?
+
+			Current = NULL;
+		};
+
+		std::unordered_set<std::string> sectionsMarkedForCreate;
+
+		while (!F->eof() || (bIsRootFile && !bHasLoadedModFiles))
 		{
-			// insert previous filled section
-			if (Current)
+			if (!F->eof())
 			{
-				//store previous section
-				RootIt I = std::lower_bound(DATA.begin(), DATA.end(), *Current->Name, sect_pred);
-				if ((I != DATA.end()) && ((*I)->Name == Current->Name))
-					Debug.fatal(DEBUG_INFO, "Duplicate section '%s' found.", *Current->Name);
-				DATA.insert(I, Current);
+				F->r_string(str, str.GetSize());
+				_Trim(str);
+			}
+			else if (!bHasLoadedModFiles && bIsRootFile)
+			{
+				StashCurrentSection();
+				bHasLoadedModFiles = TRUE;
+
+				if (!m_file_name[0])
+				{
+					continue;
+				}
+
+				//Assemble paths and filename
+				MezzStringBuffer split_drive;
+				MezzStringBuffer split_dir;
+				MezzStringBuffer split_name;
+
+				_splitpath_s(m_file_name, split_drive, split_drive.GetSize(), split_dir, split_dir.GetSize(), split_name, split_name.GetSize(), NULL, 0);
+
+				std::string FilePath = std::string(split_drive) + std::string(split_dir);
+				std::string FileName = split_name;
+
+				//Collect all files that could potentially be confused as a root file by our mod files
+				FS_FileSet AmbiguousFiles;
+				FS.file_list(AmbiguousFiles, FilePath.c_str(), FS_ListFiles, (FileName + "_*.ltx").c_str());
+
+				//Collect all matching mod files
+				FS_FileSet ModFiles;
+				FS.file_list(ModFiles, FilePath.c_str(), FS_ListFiles, ("mod_" + FileName + "_*.ltx").c_str());
+
+				for (auto It = ModFiles.begin(); It != ModFiles.end(); ++It)
+				{
+					std::string ModFileName = It->name.c_str();
+
+					//Determine if we should load this mod file, or if it's meant for a different root file
+					BOOL bIsModfileMeantForMe = [&]()
+					{
+						for (auto It2 = AmbiguousFiles.begin(); It2 != AmbiguousFiles.end(); ++It2)
+						{
+							std::string AmbiguousFileName = GetRegexMatch(It2->name.c_str(), "^.+(?=.ltx$)");
+							std::string AmbiguousFileMatchPattern = std::string("mod_") + AmbiguousFileName + std::string("_.+.ltx");
+
+							if (IsFullRegexMatch(ModFileName, AmbiguousFileMatchPattern))
+							{
+								return false;
+							}
+						}
+
+						return true;
+					}();
+
+					if (!bIsModfileMeantForMe)
+					{
+						continue;
+					}
+
+					loadFile((FilePath + ModFileName).c_str(), FilePath.c_str(), ModFileName.c_str());
+				}
+
+				continue;
+			}
+
+			LPSTR comm = strchr(str, ';');
+			LPSTR comm_1 = strchr(str, '/');
+
+			if (comm_1 && (*(comm_1 + 1) == '/') && ((!comm) || (comm && (comm_1 < comm))))
+			{
+				comm = comm_1;
+			}
+
+#ifdef DEBUG
+			LPSTR comment = 0;
+#endif
+			if (comm)
+			{
+				//."bla-bla-bla;nah-nah-nah"
+				char quot = '"';
+				bool in_quot = false;
+
+				LPCSTR q1 = strchr(str, quot);
+				if (q1 && q1 < comm)
+				{
+					LPCSTR q2 = strchr(++q1, quot);
+					if (q2 && q2 > comm)
+						in_quot = true;
+				}
+
+				if (!in_quot)
+				{
+					*comm = 0;
+#ifdef DEBUG
+					comment = comm + 1;
+#endif
+				}
 			}
-			Current = xr_new<Sect>();
-			Current->Name = 0;
-			// start new section
-			R_ASSERT3(strchr(str, ']'), "Bad ini section found: ", str);
-			LPCSTR inherited_names = strstr(str, "]:");
-			if (0 != inherited_names)
+
+			_Trim(str);
+
+			auto isOverrideSection = [](char* str) {
+				return strstr(str, "![") == &str[0];
+			};
+
+			auto isSafeOverrideSection = [](char* str) {
+				return strstr(str, "@[") == &str[0];
+			};
+
+			auto isModSection = [isOverrideSection, isSafeOverrideSection](char* str) {
+				return isOverrideSection(str) || isSafeOverrideSection(str);
+			};
+
+			if (str[0] && (str[0] == '#') && strstr(str, "#include")) //handle includes
 			{
-				VERIFY2(m_flags.test(eReadOnly), "Allow for readonly mode only.");
-				inherited_names += 2;
-				u32 cnt = _GetItemCount(inherited_names);
-				u32 total_count = 0;
-				u32 k = 0;
-				for (k = 0; k < cnt; ++k)
+				string_path inc_name;
+				R_ASSERT(path && path[0]);
+				if (_GetItem(str, 1, inc_name, '"'))
 				{
-					string512 tmp;
-					_GetItem(inherited_names, k, tmp);
-					Sect& inherited_section = r_section(tmp);
-					total_count += inherited_section.Data.size();
+					string_path fn, inc_path, folder;
+					strconcat(sizeof(fn), fn, path, inc_name);
+					_splitpath(fn, inc_path, folder, 0, 0);
+					xr_strcat(inc_path, sizeof(inc_path), folder);
+
+
+					if (strstr(inc_name, "*.ltx"))
+					{
+						FS_FileSet fset;
+						FS.file_list(fset, inc_path, FS_ListFiles, inc_name);
+
+						for (FS_FileSet::iterator it = fset.begin(); it != fset.end(); it++)
+						{
+							LPCSTR _name = it->name.c_str();
+							string_path _fn;
+							strconcat(sizeof(_fn), _fn, inc_path, _name);
+							loadFile(_fn, inc_path, _name);
+						}
+					}
+					else
+						loadFile(fn, inc_path, inc_name);
 				}
 
-				Current->Data.reserve(Current->Data.size() + total_count);
+				continue;
+			}
+			else if (str[0] && strstr(str, "!![") == &str[0])	//Section delete
+			{
+				StashCurrentSection();
 
-				for (k = 0; k < cnt; ++k)
+				if (!bOverridesOnly)
 				{
-					string512 tmp;
-					_GetItem(inherited_names, k, tmp);
-					Sect& inherited_section = r_section(tmp);
-					for (SectIt_ it = inherited_section.Data.begin(); it != inherited_section.Data.end(); it++)
-						insert_item(Current, *it);
+					continue;
 				}
+
+				Current = xr_new<Sect>();
+				*strchr(str, ']') = 0;
+				Current->Name = strlwr(&str[3]);
+
+				bIsCurrentSectionOverride = true;
+
+				Item DeleteItem;
+				DeleteItem.first = DLTX_DELETE.c_str();
+				DeleteItem.second = "";
+
+				insert_item(Current, DeleteItem);
+
+				continue;
 			}
-			*strchr(str, ']') = 0;
-			Current->Name = strlwr(str + 1);
-		}
-		else // name = value
-		{
-			if (Current)
+			else if ((str[0] && (str[0] == '[')) || isModSection(str)) //new section ?
+			{
+				// insert previous filled section
+				StashCurrentSection();
+
+				u32 SectionNameStartPos = (isModSection(str) ? 2 : 1);
+				std::string SecName = std::string(str).substr(SectionNameStartPos, strchr(str, ']') - str - SectionNameStartPos).c_str();
+				for (auto i = SecName.begin(); i != SecName.end(); ++i)
+				{
+					*i = tolower(*i);
+				}
+				
+				if (isOverrideSection(str)) { //Used to detect bad or unintended overrides
+					bIsCurrentSectionOverride = true;
+				} else if (isSafeOverrideSection(str)) { // Create section if it doesnt exist, override if it does
+					bIsCurrentSectionOverride = true;
+					if (bOverridesOnly) {
+						// Msg("using @[, override existing section %s", SecName.c_str());
+					} else {
+						auto SectIt = OutputData->find(SecName);
+						if (SectIt != OutputData->end()) {
+							// Msg("using @[, override existing section %s", SecName.c_str());
+						} else {
+							// Msg("using @[, create new section %s", SecName.c_str());
+							sectionsMarkedForCreate.insert(SecName);
+						}
+					}
+				} else {
+					bIsCurrentSectionOverride = false;
+				}
+
+				Current = xr_new<Sect>();
+				Current->Name = SecName.c_str();
+
+				// start new section
+				R_ASSERT3(strchr(str, ']'), "Bad ini section found: ", str);
+
+				if (bIsCurrentSectionOverride == bOverridesOnly)
+				{
+					LPCSTR inherited_names = strstr(str, "]:");
+					if (0 != inherited_names)
+					{
+						VERIFY2(m_flags.test(eReadOnly), "Allow for readonly mode only.");
+						inherited_names += 2;
+
+						std::vector<std::string> CurrentParents = GetParentsSetFromString(inherited_names);
+						std::vector<std::string>* SectionParents = GetParentStrings(Current->Name.c_str());
+
+						MergeParentSet(SectionParents, &CurrentParents, true);
+					}
+				}
+
+				continue;
+			}
+			else // name = value
 			{
-				string4096 value_raw;
-				char* name = str;
-				char* t = strchr(name, '=');
-				if (t)
+				if (Current && bIsCurrentSectionOverride == bOverridesOnly)
 				{
-					*t = 0;
-					_Trim(name);
-					++t;
-					xr_strcpy(value_raw, sizeof(value_raw), t);
-					bInsideSTR = _parse(str2, value_raw);
-					if (bInsideSTR) //multiline str value
+					bool bIsDelete = str[0] == '!';
+
+					MezzStringBuffer value_raw;
+					char* name = (char*) (str + (bIsDelete ? 1 : 0));
+					char* t = strchr(name, '=');
+					if (t)
 					{
-						while (bInsideSTR)
+						*t = 0;
+						_Trim(name);
+						++t;
+						xr_strcpy(value_raw, value_raw.GetSize(), t);
+						bInsideSTR = _parse(str2, value_raw);
+						if (bInsideSTR) //multiline str value
 						{
-							xr_strcat(value_raw, sizeof(value_raw), "\r\n");
-							string4096 str_add_raw;
-							F->r_string(str_add_raw, sizeof(str_add_raw));
-							R_ASSERT2(
-								xr_strlen(value_raw) + xr_strlen(str_add_raw) < sizeof(value_raw),
-								make_string(
-									"Incorrect inifile format: section[%s], variable[%s]. Odd number of quotes (\") found, but should be even."
-									,
-									Current->Name.c_str(),
-									name
-								)
-							);
-							xr_strcat(value_raw, sizeof(value_raw), str_add_raw);
-							bInsideSTR = _parse(str2, value_raw);
-							if (bInsideSTR)
+							while (bInsideSTR)
 							{
-								if (is_empty_line_now(F))
-									xr_strcat(value_raw, sizeof(value_raw), "\r\n");
+								xr_strcat(value_raw, value_raw.GetSize(), "\r\n");
+								MezzStringBuffer str_add_raw;
+								F->r_string(str_add_raw, str_add_raw.GetSize());
+								R_ASSERT2(
+									xr_strlen(value_raw) + xr_strlen(str_add_raw) < value_raw.GetSize(),
+									make_string(
+										"Incorrect inifile format: section[%s], variable[%s]. Odd number of quotes (\") found, but should be even."
+										,
+										Current->Name.c_str(),
+										name
+									)
+								);
+								xr_strcat(value_raw, value_raw.GetSize(), str_add_raw);
+								bInsideSTR = _parse(str2, value_raw);
+								if (bInsideSTR)
+								{
+									if (is_empty_line_now(F))
+										xr_strcat(value_raw, value_raw.GetSize(), "\r\n");
+								}
 							}
 						}
 					}
+					else
+					{
+						_Trim(name);
+						str2[0] = 0;
+					}
+
+					Item I;
+					I.first = (name[0] ? name : NULL);
+					I.second = bIsDelete ? DLTX_DELETE.c_str() : (str2[0] ? str2.GetBuffer() : NULL);
+
+					if (*I.first || *I.second)
+					{
+						insert_item(Current, I);
+					}
+				}
+
+				continue;
+			}
+		}
+
+		StashCurrentSection();
+
+		// Create empty sections that were marked with @[ and weren't defined normally
+		if (!bOverridesOnly) {
+			for (auto& SecName : sectionsMarkedForCreate) {
+				auto SectIt = OutputData->find(SecName);
+				if (SectIt == OutputData->end()) {
+					// Msg("section %s does not exist but was marked as @[, creating", SecName.c_str());
+					Current = xr_new<Sect>();
+					Current->Name = SecName.c_str();
+					OutputData->emplace(std::pair<std::string, Sect>(std::string(Current->Name.c_str()), *Current));
+					OverrideToFilename[std::string(Current->Name.c_str())][currentFileName] = true;
+					SectionToFilename[std::string(Current->Name.c_str())] = currentFileName;
+					Current = NULL;
+				}
+			}
+		}
+	};
+
+	std::unordered_map<std::string, std::vector<std::string>> BaseParentDataMap;
+	std::unordered_map<std::string, Sect> BaseData;
+
+	std::unordered_map<std::string, std::vector<std::string>> OverrideParentDataMap;
+	std::unordered_map<std::string, Sect> OverrideData;
+
+	std::unordered_map<std::string, Sect> FinalData;
+
+	std::unordered_set<std::string> FinalizedSections;
+
+	enum InsertType
+	{
+		Override,
+		Base,
+		Parent
+	};
+
+	std::function<void(std::string, std::vector<std::string>*)> EvaluateSection = [&](std::string SectionName, std::vector<std::string>* PreviousEvaluations)
+	{
+		if (FinalizedSections.find(SectionName) != FinalizedSections.end())
+		{
+			return;
+		}
+
+		PreviousEvaluations->insert(PreviousEvaluations->end(), SectionName);
+
+		std::vector<std::string>* BaseParents = &BaseParentDataMap.find(SectionName)->second;
+		std::vector<std::string>* OverrideParents = &OverrideParentDataMap.find(SectionName)->second;
+
+		BOOL bDeleteSectionIfEmpty = FALSE;
+
+		MergeParentSet(BaseParents, OverrideParents, false);
+
+		std::pair<std::string, Sect> CurrentSecPair = std::pair<std::string, Sect>(SectionName, Sect());
+		Sect* CurrentSect = &CurrentSecPair.second;
+		CurrentSect->Name = SectionName.c_str();
+
+		auto IsStringDLTXDelete = [&](shared_str str)
+		{
+			const char* RawString = str.c_str();
+
+			return RawString && std::string(RawString) == DLTX_DELETE;
+		};
+
+		auto InsertItemWithDelete = [&](Item CurrentItem, InsertType Type)
+		{
+			if (IsStringDLTXDelete(CurrentItem.first))
+			{
+				//Delete section
+				bDeleteSectionIfEmpty = TRUE;
+			}
+			else
+			{
+				//Insert item if variable isn't already set
+				CInifile::SectIt_ sect_it = std::lower_bound(CurrentSect->Data.begin(), CurrentSect->Data.end(), *CurrentItem.first, item_pred);
+				if (sect_it != CurrentSect->Data.end() && sect_it->first.equal(CurrentItem.first))
+				{
+					bool bShouldInsert = [&]()
+					{
+						switch (Type)
+						{
+						case InsertType::Override:		return true;
+						case InsertType::Base:			return false;
+						case InsertType::Parent:		return IsStringDLTXDelete(sect_it->second);
+						}
+					}();
+
+					if (bShouldInsert)
+					{
+						sect_it->second = CurrentItem.second;
+					}
 				}
 				else
 				{
-					_Trim(name);
-					str2[0] = 0;
+					CurrentSect->Data.insert(sect_it, CurrentItem);
 				}
+			}
+		};
 
-				Item I;
-				I.first = (name[0] ? name : NULL);
-				I.second = (str2[0] ? str2 : NULL);
-				//#ifdef DEBUG
-				// I.comment = m_flags.test(eReadOnly)?0:comment;
-				//#endif
+		//Insert variables of own data
+		auto InsertData = [&](std::unordered_map<std::string, Sect>* Data, BOOL bIsBase)
+		{
+			auto It = Data->find(SectionName);
 
-				if (m_flags.test(eReadOnly))
+			if (It != Data->end())
+			{
+				Sect* DataSection = &It->second;
+				for (Item CurrentItem : DataSection->Data)
 				{
-					if (*I.first) insert_item(Current, I);
+					InsertItemWithDelete(CurrentItem, bIsBase ? Base : Override);
 				}
-				else
+
+				if (!bIsBase)
 				{
-					if (
-						*I.first
-						|| *I.second
-							//#ifdef DEBUG
-							// || *I.comment
-							//#endif
-					)
-						insert_item(Current, I);
+					Data->erase(It);
+				}
+			}
+		};
+
+		InsertData(&OverrideData, false);
+		InsertData(&BaseData, true);
+
+		//Insert variables from parents
+		for (auto It = BaseParents->rbegin(); It != BaseParents->rend(); ++It)
+		{
+			std::string ParentSectionName = *(It.base() - 1);
+
+			for (auto It = PreviousEvaluations->begin(); It != PreviousEvaluations->end(); ++It)
+			{
+				if (ParentSectionName == *It)
+				{
+					Debug.fatal(DEBUG_INFO, "Section '%s' has cyclical dependencies. Ensure that sections with parents don't inherit in a loop. Check this file and its DLTX mods: %s, mod file %s", ParentSectionName.c_str(), m_file_name, currentFileName);
+				}
+			}
+
+			EvaluateSection(ParentSectionName, PreviousEvaluations);
+
+			auto ParentIt = FinalData.find(ParentSectionName);
+
+			if (ParentIt == FinalData.end())
+			{
+				Debug.fatal(DEBUG_INFO, "Section '%s' inherits from non-existent section '%s'. Check this file and its DLTX mods: %s, mod file %s", SectionName.c_str(), ParentSectionName.c_str(), m_file_name, currentFileName);
+			}
+
+			Sect* ParentSec = &ParentIt->second;
+
+			for (Item CurrentItem : ParentSec->Data)
+			{
+				InsertItemWithDelete(CurrentItem, Parent);
+			}
+		}
+
+		//Delete entries that are still marked DLTX_DELETE
+		for (auto It = CurrentSect->Data.rbegin(); It != CurrentSect->Data.rend(); ++It)
+		{
+			if (IsStringDLTXDelete(It->second))
+			{
+				CurrentSect->Data.erase(It.base() - 1);
+			}
+		}
+
+		// If there is data to modify parameters lists
+		if (OverrideModifyListData.find(std::string(CurrentSect->Name.c_str())) != OverrideModifyListData.end()) {
+			for (auto It = OverrideModifyListData[std::string(CurrentSect->Name.c_str())].begin(); It != OverrideModifyListData[std::string(CurrentSect->Name.c_str())].end(); ++It) {
+				CInifile::Item &I = *It;
+
+				// If section exists with item list, split list and perform operation
+				char dltx_listmode = I.first[0];
+				I.first = I.first.c_str() + 1;
+
+				CInifile::SectIt_ sect_it = std::lower_bound(CurrentSect->Data.begin(), CurrentSect->Data.end(), *I.first, item_pred);
+				if (sect_it != CurrentSect->Data.end() && sect_it->first.equal(I.first)) {
+
+					//Msg("%s has dltx_listmode %s", I.first.c_str(), std::string(1, dltx_listmode).c_str());
+
+					if (dltx_listmode && sect_it->second != NULL) {
+						// Split list 
+						auto split_list = [](const std::string items, const std::string delimiter = ",") {
+							std::string i = items;
+							std::vector<std::string> vec;
+							size_t pos = 0;
+							std::string token;
+							while ((pos = i.find(delimiter)) != std::string::npos) {
+								token = i.substr(0, pos);
+								vec.push_back(token);
+								i.erase(0, pos + delimiter.length());
+							}
+							vec.push_back(i);
+
+							auto trim = [](std::string &s, const char* t = " \t\n\r\f\v") {
+								s.erase(s.find_last_not_of(t) + 1);
+								s.erase(0, s.find_first_not_of(t));
+							};
+							for (auto &item : vec) {
+								trim(item);
+							}
+							return vec;
+						};
+						std::vector<std::string> sect_it_items_vec = split_list(sect_it->second.c_str());
+						std::vector<std::string> I_items_vec = split_list(I.second.c_str());
+
+						// Add or remove to the list
+						auto find_and_store_index = [](const std::vector<std::string> &items_vec, const std::string item, int &vec_index) {
+							auto it = std::find(items_vec.begin(), items_vec.end(), item);
+							if (it != items_vec.end()) {
+								vec_index = it - items_vec.begin();
+								return true;
+							}
+							else {
+								vec_index = -1;
+								return false;
+							}
+						};
+						int vec_index = -1;
+						for (const auto &item : I_items_vec) {
+							if (dltx_listmode == '>') {
+								sect_it_items_vec.push_back(item);
+							}
+							else if (dltx_listmode == '<') {
+								while (find_and_store_index(sect_it_items_vec, item, vec_index)) {
+									sect_it_items_vec.erase(sect_it_items_vec.begin() + vec_index);
+								}
+							}
+						}
+
+						// Store result back
+						auto join_list = [](const std::vector<std::string> &items_vec, const std::string delimiter = ",") {
+							std::string ret;
+							for (const auto &i : items_vec) {
+								if (!ret.empty()) {
+									ret += delimiter;
+								}
+								ret += i;
+							}
+							return ret;
+						};
+
+						/*std::string c(1, dltx_listmode);
+						Msg("%s has dltx_listmode %s, %s items", I.first.c_str(), c.c_str(), dltx_listmode == '>' ? "adding" : "removing");
+						Msg("old %s", sect_it->second.c_str());
+						Msg("new %s", join_list(sect_it_items_vec).c_str());*/
+
+						sect_it->second = join_list(sect_it_items_vec, ",").c_str();
+					}
 				}
 			}
 		}
+		
+
+		//Pop from stack
+		auto LastElement = PreviousEvaluations->end();
+		LastElement--;
+
+		PreviousEvaluations->erase(LastElement);
+
+		//Finalize
+		if (!bDeleteSectionIfEmpty || CurrentSecPair.second.Data.size())
+		{
+			FinalData.emplace(CurrentSecPair);
+		}
+
+		FinalizedSections.insert(SectionName);
+	};
+
+	//Read contents of root file
+	LTXLoad(F, path, &OverrideData, &OverrideParentDataMap, true, true);
+	F->seek(0);
+	LTXLoad(F, path, &BaseData, &BaseParentDataMap, false, true);
+
+	//Merge base and override data together
+	std::vector<std::string> PreviousEvaluations = std::vector<std::string>();
+
+	for (std::pair<std::string, Sect> SectPair : BaseData)
+	{
+		EvaluateSection(SectPair.first, &PreviousEvaluations);
+	}
+
+	//Insert all finalized sections into final container
+	for (std::pair<std::string, Sect> SectPair : FinalData)
+	{
+		Sect* NewSect = xr_new<Sect>();
+		*NewSect = SectPair.second;
+
+		RootIt I = std::lower_bound(DATA.begin(), DATA.end(), SectPair.first.c_str(), sect_pred);
+		DATA.insert(I, NewSect);
 	}
-	if (Current)
+
+	// Clean modifiers of parameters' lists
+	OverrideModifyListData.clear();
+
+	//throw errors if there are overrides that never got used
+	if (OverrideData.size())
 	{
-		RootIt I = std::lower_bound(DATA.begin(), DATA.end(), *Current->Name, sect_pred);
-		if ((I != DATA.end()) && ((*I)->Name == Current->Name))
-			Debug.fatal(DEBUG_INFO, "Duplicate section '%s' found.", *Current->Name);
-		DATA.insert(I, Current);
+		//Debug.fatal(DEBUG_INFO, "Attemped to override section '%s', which doesn't exist. Ensure that a base section with the same name is loaded first. Check this file and its DLTX mods: %s", OverrideData.begin()->first.c_str(), m_file_name);
+		for (auto i = OverrideData.begin(); i != OverrideData.end(); i++) {
+			auto override_filenames = OverrideToFilename.find(i->first);
+			if (override_filenames != OverrideToFilename.end()) {
+				for (auto &override_filename : override_filenames->second) {
+					Msg("!!!DLTX ERROR Attemped to override section '%s', which doesn't exist. Ensure that a base section with the same name is loaded first. Check this file and its DLTX mods: %s, mod file %s", i->first.c_str(), m_file_name, override_filename.first.c_str());
+				}
+			}
+		}
 	}
 }
 
diff --git a/src/xrCore/mezz_stringbuffer.cpp b/src/xrCore/mezz_stringbuffer.cpp
new file mode 100644
index 0000000..13f0470
--- /dev/null
+++ b/src/xrCore/mezz_stringbuffer.cpp
@@ -0,0 +1,26 @@
+#include "stdafx.h"
+
+#include "mezz_stringbuffer.h"
+
+MezzStringBuffer::MezzStringBuffer(uint32_t Size)
+{
+	StringBuffer = std::make_unique<char[]>(Size);
+	BufferRaw = StringBuffer.get();
+
+	BufferSize = Size;
+}
+
+char* MezzStringBuffer::GetBuffer() const
+{
+	return BufferRaw;
+}
+
+uint32_t MezzStringBuffer::GetSize() const
+{
+	return BufferSize;
+}
+
+MezzStringBuffer::operator char* () const
+{
+	return BufferRaw;
+}
\ No newline at end of file
diff --git a/src/xrCore/mezz_stringbuffer.h b/src/xrCore/mezz_stringbuffer.h
new file mode 100644
index 0000000..9f42203
--- /dev/null
+++ b/src/xrCore/mezz_stringbuffer.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include <memory>
+#include <cstdint>
+
+class MezzStringBuffer
+{
+public:
+	MezzStringBuffer(uint32_t Size = 4096);
+
+	char* GetBuffer() const;
+	uint32_t GetSize() const;
+
+	operator char* () const;
+
+private:
+	std::unique_ptr<char[]> StringBuffer;
+
+	char* BufferRaw;
+	uint32_t BufferSize;
+};
\ No newline at end of file
diff --git a/src/xrCore/xrCore.vcxproj b/src/xrCore/xrCore.vcxproj
index 209d066..2d57efb 100644
--- a/src/xrCore/xrCore.vcxproj
+++ b/src/xrCore/xrCore.vcxproj
@@ -330,6 +330,7 @@
     <ClCompile Include="memory_allocation_stats.cpp" />
     <ClCompile Include="memory_monitor.cpp" />
     <ClCompile Include="memory_usage.cpp" />
+    <ClCompile Include="mezz_stringbuffer.cpp" />
     <ClCompile Include="Model.cpp">
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
       </PrecompiledHeader>
@@ -443,6 +444,7 @@
     <ClInclude Include="lzhuf.h" />
     <ClInclude Include="lzo_compressor.h" />
     <ClInclude Include="memory_monitor.h" />
+    <ClInclude Include="mezz_stringbuffer.h" />
     <ClInclude Include="net_utils.h" />
     <ClInclude Include="os_clipboard.h" />
     <ClInclude Include="PPMd.h" />
diff --git a/src/xrCore/xrCore.vcxproj.filters b/src/xrCore/xrCore.vcxproj.filters
index dd3958c..f39a6c6 100644
--- a/src/xrCore/xrCore.vcxproj.filters
+++ b/src/xrCore/xrCore.vcxproj.filters
@@ -280,6 +280,7 @@
     <ClCompile Include="ScopeLock.cpp">
       <Filter>Threading</Filter>
     </ClCompile>
+    <ClCompile Include="mezz_stringbuffer.cpp" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="FTimer.h">
@@ -589,6 +590,7 @@
     <ClInclude Include="ScopeLock.hpp">
       <Filter>Threading</Filter>
     </ClInclude>
+    <ClInclude Include="mezz_stringbuffer.h" />
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="xrCore.rc">
diff --git a/src/xrCore/xrDebugNew.cpp b/src/xrCore/xrDebugNew.cpp
index dd65e49..1c3a710 100644
--- a/src/xrCore/xrDebugNew.cpp
+++ b/src/xrCore/xrDebugNew.cpp
@@ -67,6 +67,20 @@ XRCORE_API xrDebug Debug;
 
 static bool error_after_dialog = false;
 
+namespace crash_saving
+{
+    void (*save_impl)() = nullptr;
+	BOOL enabled = TRUE;
+
+    void save()
+    {
+        if (enabled && save_impl != nullptr)
+        {
+            (*save_impl)();
+        }
+    }
+}
+
 //extern void BuildStackTrace();
 //extern char g_stackTrace[100][4096];
 //extern int g_stackTraceCount;
@@ -206,6 +220,9 @@ void xrDebug::do_exit(const std::string& message)
 void xrDebug::backend(const char* expression, const char* description, const char* argument0, const char* argument1,
                       const char* file, int line, const char* function, bool& ignore_always)
 {
+    // we save first
+    crash_saving::save();
+    
 	static xrCriticalSection CS
 #ifdef PROFILE_CRITICAL_SECTIONS
         (MUTEX_PROFILE_ID(xrDebug::backend))
@@ -232,7 +249,7 @@ void xrDebug::backend(const char* expression, const char* description, const cha
 	ShowCursor(true);
 	ShowWindow(GetActiveWindow(), SW_FORCEMINIMIZE);
 	MessageBox(
-		GetTopWindow(NULL),
+		NULL,
 		assertion_info,
 		"Fatal Error",
 		MB_OK | MB_ICONERROR | MB_SYSTEMMODAL
diff --git a/src/xrEngine/CameraManager.cpp b/src/xrEngine/CameraManager.cpp
index 4eb5146..206b3ac 100644
--- a/src/xrEngine/CameraManager.cpp
+++ b/src/xrEngine/CameraManager.cpp
@@ -225,6 +225,21 @@ void CCameraManager::RemoveCamEffector(ECamEffectorType type)
 		}
 }
 
+// demonized: removecameffector by pointer
+void CCameraManager::RemoveCamEffector(CEffectorCam* ef)
+{
+	for (EffectorCamIt it = m_EffectorsCam.begin(); it != m_EffectorsCam.end(); it++)
+	{
+		CEffectorCam* cam = (*it);
+		if (cam == ef)
+		{
+			OnEffectorReleased(cam);
+			m_EffectorsCam.erase(it);
+			return;
+		}
+	}
+}
+
 CEffectorPP* CCameraManager::GetPPEffector(EEffectorPPType type)
 {
 	for (EffectorPPIt it = m_EffectorsPP.begin(); it != m_EffectorsPP.end(); it++)
diff --git a/src/xrEngine/CameraManager.h b/src/xrEngine/CameraManager.h
index ca5bd2f..649a183 100644
--- a/src/xrEngine/CameraManager.h
+++ b/src/xrEngine/CameraManager.h
@@ -154,6 +154,9 @@ public:
 	CEffectorCam* GetCamEffector(ECamEffectorType type);
 	void RemoveCamEffector(ECamEffectorType type);
 
+	// demonized: removecameffector by pointer
+	void RemoveCamEffector(CEffectorCam* ef);
+
 	ECamEffectorType RequestCamEffectorId();
 	EEffectorPPType RequestPPEffectorId();
 	CEffectorPP* GetPPEffector(EEffectorPPType type);
diff --git a/src/xrEngine/Environment_misc.cpp b/src/xrEngine/Environment_misc.cpp
index bb5c882..eca3900 100644
--- a/src/xrEngine/Environment_misc.cpp
+++ b/src/xrEngine/Environment_misc.cpp
@@ -14,6 +14,7 @@
 
 extern float ps_r2_sun_shafts_min;
 extern float ps_r2_sun_shafts_value;
+extern Fvector3 ssfx_wetness_multiplier;
 
 void CEnvModifier::load(IReader* fs, u32 version)
 {
@@ -505,9 +506,9 @@ void CEnvDescriptorMixer::lerp(CEnvironment* env, CEnvDescriptor& A, CEnvDescrip
 	sun_color.lerp(A.sun_color, B.sun_color, f);
 
 	if (rain_density > 0.f)
-		env->wetness_factor += rain_density / 10000.f;
+		env->wetness_factor += ( rain_density * ssfx_wetness_multiplier.x) / 10000.f;
 	else
-		env->wetness_factor -= 0.00001f;
+		env->wetness_factor -= 0.0001f * ssfx_wetness_multiplier.y;
 
 	clamp(env->wetness_factor, 0.f, 1.f);
 
diff --git a/src/xrEngine/FDemoRecord.cpp b/src/xrEngine/FDemoRecord.cpp
index aa96cfb..0499b90 100644
--- a/src/xrEngine/FDemoRecord.cpp
+++ b/src/xrEngine/FDemoRecord.cpp
@@ -20,7 +20,8 @@ BOOL stored_cross;
 BOOL stored_red_text;
 
 CDemoRecord* xrDemoRecord = 0;
-CDemoRecord::force_position CDemoRecord::g_position = {false, {0, 0, 0}};
+CDemoRecord::force_position CDemoRecord::g_position = { false, {0, 0, 0} };
+CDemoRecord::force_direction CDemoRecord::g_direction = {false, {0, 0, 0}};
 
 Fbox curr_lm_fbox;
 
@@ -77,6 +78,8 @@ CDemoRecord::CDemoRecord(const char* name, float life_time) : CEffectorCam(cefDe
 	m_b_redirect_input_to_level = false;
 	_unlink(name);
 	file = FS.w_open(name);
+	isInputBlocked = FALSE;
+	pDemoRecords = nullptr;
 	if (file)
 	{
 		g_position.set_position = false;
@@ -123,6 +126,23 @@ CDemoRecord::CDemoRecord(const char* name, float life_time) : CEffectorCam(cefDe
 	}
 }
 
+CDemoRecord::CDemoRecord(const char* name, std::unordered_set<CDemoRecord*>* pDemoRecords, BOOL isInputBlocked, float life_time) : CDemoRecord(name, life_time)
+{
+	pDemoRecords->insert(this);
+	this->pDemoRecords = pDemoRecords;
+	this->isInputBlocked = isInputBlocked;
+	if (!file) {
+		StopDemo();
+	}
+}
+
+void CDemoRecord::StopDemo() {
+	fLifeTime = -1;
+	if (pDemoRecords) {
+		pDemoRecords->erase(this);
+	}
+}
+
 CDemoRecord::~CDemoRecord()
 {
 	if (file)
@@ -130,6 +150,9 @@ CDemoRecord::~CDemoRecord()
 		IR_Release(); // release input
 		FS.w_close(file);
 	}
+	if (pDemoRecords) {
+		pDemoRecords->erase(this);
+	}
 	g_bDisableRedText = stored_red_text;
 
 	Device.seqRender.Remove(this);
@@ -372,6 +395,13 @@ BOOL CDemoRecord::ProcessCam(SCamEffectorInfo& info)
 		}
 		else
 			g_position.p.set(m_Position);
+
+		if (g_direction.set_direction)
+		{
+			m_HPB.set(g_direction.d);
+			g_direction.set_direction = false;
+		} else
+			g_direction.d.set(m_Position);
 		// move
 		Fvector vmove;
 
@@ -399,6 +429,9 @@ BOOL CDemoRecord::ProcessCam(SCamEffectorInfo& info)
 		info.p.set(m_Camera.c);
 
 		fLifeTime -= Device.fTimeDelta;
+		if (fLifeTime < 0) {
+			StopDemo();
+		}
 
 		m_vT.set(0, 0, 0);
 		m_vR.set(0, 0, 0);
@@ -420,43 +453,54 @@ void CDemoRecord::IR_OnMouseRelease(int btn)
 
 void CDemoRecord::IR_OnKeyboardPress(int dik)
 {
-	if (dik == DIK_MULTIPLY) m_b_redirect_input_to_level = !m_b_redirect_input_to_level;
-
-	if (m_b_redirect_input_to_level)
-	{
-		g_pGameLevel->IR_OnKeyboardPress(dik);
-		return;
-	}
-	if (dik == DIK_GRAVE)
-		Console->Show();
-	if (dik == DIK_SPACE) RecordKey();
-	if (dik == DIK_BACK) MakeCubemap();
-	if (dik == DIK_F11) MakeLevelMapScreenshot(IR_GetKeyState(DIK_LCONTROL));
-	if (dik == DIK_F12) MakeScreenshot();
-	if (dik == DIK_ESCAPE) fLifeTime = -1;
-
-	//Alundaio: Teleport to demo cam
-	//#ifndef MASTER_GOLD
-	if (dik == DIK_RETURN)
-	{
-		if (strstr(Core.Params, "-dbg"))
+	if (isInputBlocked) {
+		if (dik == DIK_PAUSE)
+			Device.Pause(!Device.Paused(), TRUE, TRUE, "demo_record");
+		if (dik == DIK_GRAVE)
+			Console->Show();
+		if (dik == DIK_ESCAPE)
+			Console->Execute("main_menu on");
+	} else {
+		if (dik == DIK_MULTIPLY) m_b_redirect_input_to_level = !m_b_redirect_input_to_level;
+
+		if (m_b_redirect_input_to_level)
 		{
-			if (g_pGameLevel->CurrentEntity())
+			g_pGameLevel->IR_OnKeyboardPress(dik);
+			return;
+		}
+		if (dik == DIK_GRAVE)
+			Console->Show();
+		if (dik == DIK_SPACE) RecordKey();
+		if (dik == DIK_BACK) MakeCubemap();
+		if (dik == DIK_F11) MakeLevelMapScreenshot(IR_GetKeyState(DIK_LCONTROL));
+		if (dik == DIK_F12) MakeScreenshot();
+		if (dik == DIK_ESCAPE) StopDemo();
+
+		//Alundaio: Teleport to demo cam
+		//#ifndef MASTER_GOLD
+		if (dik == DIK_RETURN)
+		{
+			if (strstr(Core.Params, "-dbg"))
 			{
-				g_pGameLevel->CurrentEntity()->ForceTransform(m_Camera);
-				fLifeTime = -1;
+				if (g_pGameLevel->CurrentEntity())
+				{
+					g_pGameLevel->CurrentEntity()->ForceTransform(m_Camera);
+					StopDemo();
+				}
 			}
 		}
-	}
-	//#endif // #ifndef MASTER_GOLD
-	//-Alundaio
+		//#endif // #ifndef MASTER_GOLD
+		//-Alundaio
 
-	if (dik == DIK_PAUSE)
-		Device.Pause(!Device.Paused(), TRUE, TRUE, "demo_record");
+		if (dik == DIK_PAUSE)
+			Device.Pause(!Device.Paused(), TRUE, TRUE, "demo_record");
+	}
+	
 }
 
 void CDemoRecord::IR_OnKeyboardRelease(int dik)
 {
+	if (isInputBlocked) return;
 	if (m_b_redirect_input_to_level)
 		g_pGameLevel->IR_OnKeyboardRelease(dik);
 }
@@ -471,6 +515,7 @@ static void update_whith_timescale(Fvector& v, const Fvector& v_delta)
 
 void CDemoRecord::IR_OnKeyboardHold(int dik)
 {
+	if (isInputBlocked) return;
 	if (m_b_redirect_input_to_level)
 	{
 		g_pGameLevel->IR_OnKeyboardHold(dik);
@@ -526,6 +571,7 @@ void CDemoRecord::IR_OnKeyboardHold(int dik)
 
 void CDemoRecord::IR_OnMouseMove(int dx, int dy)
 {
+	if (isInputBlocked) return;
 	if (m_b_redirect_input_to_level)
 	{
 		g_pGameLevel->IR_OnMouseMove(dx, dy);
@@ -545,6 +591,7 @@ void CDemoRecord::IR_OnMouseMove(int dx, int dy)
 
 void CDemoRecord::IR_OnMouseHold(int btn)
 {
+	if (isInputBlocked) return;
 	if (m_b_redirect_input_to_level)
 	{
 		g_pGameLevel->IR_OnMouseHold(btn);
diff --git a/src/xrEngine/FDemoRecord.h b/src/xrEngine/FDemoRecord.h
index 2e8de06..5890079 100644
--- a/src/xrEngine/FDemoRecord.h
+++ b/src/xrEngine/FDemoRecord.h
@@ -6,6 +6,8 @@
 #include "iinputreceiver.h"
 #include "effector.h"
 
+#include <unordered_set>
+
 class ENGINE_API CDemoRecord :
 	public CEffectorCam,
 	public IInputReceiver,
@@ -18,6 +20,12 @@ private:
 		Fvector p;
 	} g_position;
 
+	static struct force_direction
+	{
+		bool set_direction;
+		Fvector d;
+	} g_direction;
+
 	int iCount;
 	IWriter* file;
 	Fvector m_HPB;
@@ -44,6 +52,9 @@ private:
 	float m_fAngSpeed2;
 	float m_fAngSpeed3;
 
+	BOOL isInputBlocked;
+	std::unordered_set<CDemoRecord*>* pDemoRecords;
+
 	void MakeCubeMapFace(Fvector& D, Fvector& N);
 	void MakeLevelMapProcess();
 	void MakeScreenshotFace();
@@ -53,6 +64,7 @@ private:
 	void MakeLevelMapScreenshot(BOOL bHQ);
 public:
 	CDemoRecord(const char* name, float life_time = 60 * 60 * 1000);
+	CDemoRecord(const char* name, std::unordered_set<CDemoRecord*>* pDemoRecords, BOOL isInputBlocked = 0, float life_time = 60 * 60 * 1000);
 	virtual ~CDemoRecord();
 
 	virtual void IR_OnKeyboardPress(int dik);
@@ -62,10 +74,13 @@ public:
 	virtual void IR_OnMouseHold(int btn);
 	virtual void IR_OnMousePress(int btn);
 	virtual void IR_OnMouseRelease(int btn);
+	void StopDemo();
 
 	virtual BOOL ProcessCam(SCamEffectorInfo& info);
 	static void SetGlobalPosition(const Fvector& p) { g_position.p.set(p), g_position.set_position = true; }
 	static void GetGlobalPosition(Fvector& p) { p.set(g_position.p); }
+	static void SetGlobalDirection(const Fvector& d) { g_direction.d.set(d), g_direction.set_direction = true; }
+	static void GetGlobalDirection(Fvector& d) { d.set(g_direction.d); }
 	BOOL m_b_redirect_input_to_level;
 	virtual void OnRender();
 };
diff --git a/src/xrEngine/IGame_Persistent.cpp b/src/xrEngine/IGame_Persistent.cpp
index b31df1e..8a9ecae 100644
--- a/src/xrEngine/IGame_Persistent.cpp
+++ b/src/xrEngine/IGame_Persistent.cpp
@@ -11,6 +11,7 @@
 # include "Render.h"
 # include "ps_instance.h"
 # include "CustomHUD.h"
+# include "perlin.h"
 #endif
 
 #ifdef _EDITOR
@@ -21,6 +22,8 @@ bool g_dedicated_server = false;
 # include "editor_environment_manager.hpp"
 #endif // INGAME_EDITOR
 
+extern Fvector4 ps_ssfx_grass_interactive;
+
 ENGINE_API IGame_Persistent* g_pGamePersistent = NULL;
 
 bool IsMainMenuActive()
@@ -39,6 +42,10 @@ IGame_Persistent::IGame_Persistent()
 
 	m_pMainMenu = NULL;
 
+	PerlinNoise1D = xr_new<CPerlinNoise1D>(Random.randI(0, 0xFFFF));
+	PerlinNoise1D->SetOctaves(2);
+	PerlinNoise1D->SetAmplitude(0.66666f);
+
 #ifndef INGAME_EDITOR
 #ifndef _EDITOR
 	pEnvironment = xr_new<CEnvironment>();
@@ -53,6 +60,7 @@ IGame_Persistent::IGame_Persistent()
 
 IGame_Persistent::~IGame_Persistent()
 {
+	xr_delete(PerlinNoise1D);
 	RDEVICE.seqFrame.Remove(this);
 	RDEVICE.seqAppStart.Remove(this);
 	RDEVICE.seqAppEnd.Remove(this);
@@ -338,3 +346,305 @@ void IGame_Persistent::OnAssetsChanged()
 	Device.m_pRender->OnAssetsChanged(); //Resources->m_textures_description.Load();
 #endif
 }
+
+void IGame_Persistent::GrassBendersUpdate(u16 id, u8& data_idx, u32& data_frame, Fvector& position, float init_radius, float init_str, bool CheckDistance)
+{
+	// Interactive grass disabled
+	if (ps_ssfx_grass_interactive.y < 1)
+		return;
+
+	// Just update position if not NULL
+	if (data_idx != NULL)
+	{
+		// Explosions can take the mem spot, unassign and try to get a spot later.
+		if (grass_shader_data.id[data_idx] != id)
+		{
+			data_idx = NULL;
+			data_frame = RDEVICE.dwFrame + Random.randI(10, 35);
+		}
+		else
+		{
+			grass_shader_data.pos[data_idx] = position;
+		}
+	}
+
+	if (RDEVICE.dwFrame < data_frame)
+		return;
+
+	// Wait some random frames to split the checks
+	data_frame = RDEVICE.dwFrame + Random.randI(10, 35);
+
+	// Check Distance
+	if (CheckDistance)
+	{
+		if (position.distance_to_xz_sqr(Device.vCameraPosition) > ps_ssfx_grass_interactive.z)
+		{
+			GrassBendersRemoveByIndex(data_idx);
+			return;
+		}
+	}
+
+	CFrustum& view_frust = ::Render->ViewBase;
+	u32 mask = 0xff;
+	float rad = data_idx == NULL ? 1.0 : std::max(1.0f, grass_shader_data.radius_curr[data_idx] + 0.5f);
+
+	// In view frustum?
+	if (!view_frust.testSphere(position, rad, mask))
+	{
+		GrassBendersRemoveByIndex(data_idx);
+		return;
+	}
+
+	// Empty slot, let's use this
+	if (data_idx == NULL)
+	{
+		u8 idx = grass_shader_data.index + 1;
+
+		// Add to grass blenders array
+		if (grass_shader_data.id[idx] == NULL)
+		{
+			data_idx = idx;
+			GrassBendersSet(idx, id, position, Fvector3().set(0, -99, 0), 0, 0, 0.0f, init_radius, BENDER_ANIM_DEFAULT, true);
+
+			grass_shader_data.str_target[idx] = init_str;
+			grass_shader_data.radius_curr[idx] = init_radius;
+		}
+		// Back to 0 when the array limit is reached
+		grass_shader_data.index = idx < ps_ssfx_grass_interactive.y ? idx : 0;
+	}
+	else
+	{
+		// Already inview, let's add more time to re-check
+		data_frame += 60;
+		grass_shader_data.pos[data_idx] = position;
+	}
+}
+
+void IGame_Persistent::GrassBendersAddExplosion(u16 id, Fvector position, Fvector3 dir, float fade, float speed, float intensity, float radius)
+{
+	if (ps_ssfx_grass_interactive.y < 1)
+		return;
+
+	for (int idx = 1; idx < ps_ssfx_grass_interactive.y + 1; idx++)
+	{
+		// Add explosion to any spot not already taken by an explosion.
+		if (grass_shader_data.anim[idx] != BENDER_ANIM_EXPLOSION)
+		{
+			// Add 99 to the ID to avoid conflicts between explosions and basic benders happening at the same time with the same ID.
+			GrassBendersSet(idx, id + 99, position, dir, fade, speed, intensity, radius, BENDER_ANIM_EXPLOSION, true);
+			grass_shader_data.str_target[idx] = intensity;
+			break;
+		}
+	}
+}
+
+void IGame_Persistent::GrassBendersAddShot(u16 id, Fvector position, Fvector3 dir, float fade, float speed, float intensity, float radius)
+{
+	// Is disabled?
+	if (ps_ssfx_grass_interactive.y < 1 || intensity <= 0.0f)
+		return;
+
+	// Check distance
+	if (position.distance_to_xz_sqr(Device.vCameraPosition) > ps_ssfx_grass_interactive.z)
+		return;
+
+	int AddAt = -1;
+
+	// Look for a spot
+	for (int idx = 1; idx < ps_ssfx_grass_interactive.y + 1; idx++)
+	{
+		// Already exist, just update and increase intensity
+		if (grass_shader_data.id[idx] == id)
+		{
+			float currentSTR = grass_shader_data.str[idx];
+			GrassBendersSet(idx, id, position, dir, fade, speed, currentSTR, radius, BENDER_ANIM_EXPLOSION, false);
+			grass_shader_data.str_target[idx] += intensity;
+			AddAt = -1;
+			break;
+		}
+		else
+		{
+			// Check all indexes and keep usable index to use later if needed...
+			if (AddAt == -1 && grass_shader_data.radius[idx] == NULL)
+				AddAt = idx;
+		}
+	}
+
+	// We got an available index... Add bender at AddAt
+	if (AddAt != -1)
+	{
+		GrassBendersSet(AddAt, id, position, dir, fade, speed, 0.001f, radius, BENDER_ANIM_EXPLOSION, true);
+		grass_shader_data.str_target[AddAt] = intensity;
+	}
+}
+
+void IGame_Persistent::GrassBendersUpdateAnimations()
+{
+	for (int idx = 1; idx < ps_ssfx_grass_interactive.y + 1; idx++)
+	{
+		if (grass_shader_data.id[idx] != NULL)
+		{
+			switch (grass_shader_data.anim[idx])
+			{
+			case BENDER_ANIM_EXPLOSION: // Internal Only ( You can use BENDER_ANIM_PULSE for anomalies )
+			{
+				// Radius
+				grass_shader_data.time[idx] += Device.fTimeDelta * grass_shader_data.speed[idx];
+				grass_shader_data.radius_curr[idx] = grass_shader_data.radius[idx] * std::min(1.0f, grass_shader_data.time[idx]);
+
+				grass_shader_data.str_target[idx] = std::min(1.0f, grass_shader_data.str_target[idx]);
+
+				// Easing
+				float diff = abs(grass_shader_data.str[idx] - grass_shader_data.str_target[idx]);
+				diff = std::max(0.1f, diff);
+
+				// Intensity
+				if (grass_shader_data.str_target[idx] <= grass_shader_data.str[idx])
+				{
+					grass_shader_data.str[idx] -= Device.fTimeDelta * grass_shader_data.fade[idx] * diff;
+				}
+				else
+				{
+					grass_shader_data.str[idx] += Device.fTimeDelta * grass_shader_data.speed[idx] * diff;
+
+					if (grass_shader_data.str[idx] >= grass_shader_data.str_target[idx])
+						grass_shader_data.str_target[idx] = 0;
+				}
+
+				// Remove Bender
+				if (grass_shader_data.str[idx] < 0.0f)
+					GrassBendersReset(idx);
+			}
+			break;
+
+			case BENDER_ANIM_WAVY:
+			{
+				// Anim Speed
+				grass_shader_data.time[idx] += Device.fTimeDelta * 1.5f * grass_shader_data.speed[idx];
+
+				// Curve
+				float curve = sin(grass_shader_data.time[idx]);
+
+				// Intensity using curve
+				grass_shader_data.str[idx] = curve * cos(curve * 1.4f) * 1.8f * grass_shader_data.str_target[idx];
+			}
+
+			break;
+
+			case BENDER_ANIM_SUCK:
+			{
+				// Anim Speed
+				grass_shader_data.time[idx] += Device.fTimeDelta * grass_shader_data.speed[idx];
+
+				// Perlin Noise
+				float curve = clampr(PerlinNoise1D->GetContinious(grass_shader_data.time[idx]) + 0.5f, 0.f, 1.f) * -1.0;
+
+				// Intensity using Perlin
+				grass_shader_data.str[idx] = curve * grass_shader_data.str_target[idx];
+			}
+			break;
+
+			case BENDER_ANIM_BLOW:
+			{
+				// Anim Speed
+				grass_shader_data.time[idx] += Device.fTimeDelta * 1.2f * grass_shader_data.speed[idx];
+
+				// Perlin Noise
+				float curve = clampr(PerlinNoise1D->GetContinious(grass_shader_data.time[idx]) + 1.0f, 0.f, 2.0f) * 0.25f;
+
+				// Intensity using Perlin
+				grass_shader_data.str[idx] = curve * grass_shader_data.str_target[idx];
+			}
+			break;
+
+			case BENDER_ANIM_PULSE:
+			{
+				// Anim Speed
+				grass_shader_data.time[idx] += Device.fTimeDelta * grass_shader_data.speed[idx];
+
+				// Radius
+				grass_shader_data.radius_curr[idx] = grass_shader_data.radius[idx] * std::min(1.0f, grass_shader_data.time[idx]);
+
+				// Diminish intensity when radius target is reached
+				if (grass_shader_data.radius_curr[idx] >= grass_shader_data.radius[idx])
+					grass_shader_data.str[idx] += GrassBenderToValue(grass_shader_data.str[idx], 0.0f, grass_shader_data.speed[idx] * 0.6f, true);
+
+				// Loop when intensity is <= 0
+				if (grass_shader_data.str[idx] <= 0.0f)
+				{
+					grass_shader_data.str[idx] = grass_shader_data.str_target[idx];
+					grass_shader_data.radius_curr[idx] = 0.0f;
+					grass_shader_data.time[idx] = 0.0f;
+				}
+
+			}
+			break;
+
+			case BENDER_ANIM_DEFAULT:
+
+				// Just fade to target strength
+				grass_shader_data.str[idx] += GrassBenderToValue(grass_shader_data.str[idx], grass_shader_data.str_target[idx], 2.0f, true);
+
+				break;
+			}
+		}
+	}
+}
+
+void IGame_Persistent::GrassBendersRemoveByIndex(u8& idx)
+{
+	if (idx != NULL)
+	{
+		GrassBendersReset(idx);
+		idx = NULL;
+	}
+}
+
+void IGame_Persistent::GrassBendersRemoveById(u16 id)
+{
+	// Search by Object ID ( Used when removing benders CPHMovementControl::DestroyCharacter() )
+	for (int i = 1; i < ps_ssfx_grass_interactive.y + 1; i++)
+		if (grass_shader_data.id[i] == id)
+			GrassBendersReset(i);
+}
+
+void IGame_Persistent::GrassBendersReset(u8 idx)
+{
+	// Reset Everything
+	GrassBendersSet(idx, NULL, Fvector3().set(0, 0, 0), Fvector3().set(0, -99, 0), 0, 0, 0, 0, BENDER_ANIM_DEFAULT, true);
+	grass_shader_data.str_target[idx] = 0;
+}
+
+void IGame_Persistent::GrassBendersSet(u8 idx, u16 id, Fvector position, Fvector3 dir, float fade, float speed, float intensity, float radius, GrassBenders_Anim anim, bool resetTime)
+{
+	// Set values
+	grass_shader_data.anim[idx] = anim;
+	grass_shader_data.pos[idx] = position;
+	grass_shader_data.id[idx] = id;
+	grass_shader_data.radius[idx] = radius;
+	grass_shader_data.str[idx] = intensity;
+	grass_shader_data.fade[idx] = fade;
+	grass_shader_data.speed[idx] = speed;
+	grass_shader_data.dir[idx] = dir;
+
+	if (resetTime)
+	{
+		grass_shader_data.radius_curr[idx] = 0.01f;
+		grass_shader_data.time[idx] = 0;
+	}
+}
+
+float IGame_Persistent::GrassBenderToValue(float& current, float go_to, float intensity, bool use_easing)
+{
+	float diff = abs(current - go_to);
+
+	float r_value = Device.fTimeDelta * intensity * (use_easing ? std::min(0.5f, diff) : 1.0f);
+
+	if (diff - r_value <= 0)
+	{
+		current = go_to;
+		return 0;
+	}
+
+	return current < go_to ? r_value : -r_value;
+}
\ No newline at end of file
diff --git a/src/xrEngine/IGame_Persistent.h b/src/xrEngine/IGame_Persistent.h
index a39152f..9a88fc8 100644
--- a/src/xrEngine/IGame_Persistent.h
+++ b/src/xrEngine/IGame_Persistent.h
@@ -64,6 +64,44 @@ public:
 	xr_set<CPS_Instance*> ps_active;
 	xr_vector<CPS_Instance*> ps_destroy;
 	xr_vector<CPS_Instance*> ps_needtoplay;
+public:
+	enum GrassBenders_Anim
+	{
+		BENDER_ANIM_EXPLOSION = 0,
+		BENDER_ANIM_DEFAULT = 1,
+		BENDER_ANIM_WAVY = 2,
+		BENDER_ANIM_SUCK = 3,
+		BENDER_ANIM_BLOW = 4,
+		BENDER_ANIM_PULSE = 5,
+	}; 
+
+	void GrassBendersUpdateAnimations();
+	void GrassBendersAddExplosion(u16 id, Fvector position, Fvector3 dir, float fade, float speed, float intensity, float radius);
+	void GrassBendersAddShot(u16 id, Fvector position, Fvector3 dir, float fade, float speed, float intensity, float radius);
+	void GrassBendersRemoveById(u16 id);
+	void GrassBendersRemoveByIndex(u8& idx);
+	void GrassBendersUpdate(u16 id, u8& data_idx, u32& data_frame, Fvector& position, float radius, float str, bool CheckDistance );
+	void GrassBendersReset(u8 idx);
+	void GrassBendersSet(u8 idx, u16 id, Fvector position, Fvector3 dir, float fade, float speed, float str, float radius, GrassBenders_Anim anim, bool resetTime);
+	float GrassBenderToValue(float& current, float go_to, float intensity, bool use_easing);
+
+	CPerlinNoise1D* PerlinNoise1D;
+
+	struct grass_data
+	{
+		u8 index;
+		s8 anim[16];
+		u16 id[16];
+		Fvector pos[16];
+		Fvector3 dir[16];
+		float radius[16];
+		float radius_curr[16];
+		float str[16];
+		float str_target[16];
+		float time[16];
+		float fade[16];
+		float speed[16];
+	} grass_shader_data;
 
 public:
 	void destroy_particles(const bool& all_particles);
diff --git a/src/xrEngine/IRenderable.h b/src/xrEngine/IRenderable.h
index 040868a..b7c60d3 100644
--- a/src/xrEngine/IRenderable.h
+++ b/src/xrEngine/IRenderable.h
@@ -24,6 +24,11 @@ public:
 	virtual void renderable_Render() = 0;
 	virtual BOOL renderable_ShadowGenerate() { return FALSE; };
 	virtual BOOL renderable_ShadowReceive() { return FALSE; };
+
+	//--DSR-- HeatVision_start
+	virtual float GetHotness() { return 0.0; }
+	virtual float GetTransparency() { return 0.0; }
+	//--DSR-- HeatVision_end
 };
 
 #endif // IRENDERABLE_H_INCLUDED
diff --git a/src/xrEngine/Render.h b/src/xrEngine/Render.h
index df52521..29b8b22 100644
--- a/src/xrEngine/Render.h
+++ b/src/xrEngine/Render.h
@@ -283,6 +283,9 @@ public:
 	virtual void add_StaticWallmark(const wm_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V) = 0;
 	// Prefer this function when possible
 	virtual void add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl = 0.f, bool ignore_opt = false, bool random_rotation = true) = 0;
+
+	// demonized: add user defined rotation to wallmark
+	virtual void add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, float rotation) = 0;
 	virtual void clear_static_wallmarks() = 0;
 	//virtual void add_SkeletonWallmark (intrusive_ptr<CSkeletonWallmark> wm) = 0;
 	//virtual void add_SkeletonWallmark (const Fmatrix* xf, CKinematics* obj, ref_shader& sh, const Fvector& start, const Fvector& dir, float size)=0;
diff --git a/src/xrEngine/xr_ioc_cmd.cpp b/src/xrEngine/xr_ioc_cmd.cpp
index a1ec515..21a3385 100644
--- a/src/xrEngine/xr_ioc_cmd.cpp
+++ b/src/xrEngine/xr_ioc_cmd.cpp
@@ -596,6 +596,21 @@ public:
 	}
 };
 
+extern void updateCurrentScope();
+class CCC_ScopeFactor : public CCC_Float
+{
+public:
+	CCC_ScopeFactor(LPCSTR N, float* V) : CCC_Float(N, V, 0.01f, 1.0f)
+	{
+	}
+
+	virtual void Execute(LPCSTR args)
+	{
+		CCC_Float::Execute(args);
+		updateCurrentScope();
+	}
+};
+
 //-----------------------------------------------------------------------
 /*
 #ifdef DEBUG
@@ -833,6 +848,18 @@ public:
 	}
 };
 
+class CCC_SoundParamsSmoothing : public CCC_Integer
+{
+public:
+	CCC_SoundParamsSmoothing(LPCSTR N, int* V, int _min = 0, int _max = 999) : CCC_Integer(N, V, _min, _max) {};
+
+	virtual void Execute(LPCSTR args)
+	{
+		CCC_Integer::Execute(args);
+		soundSmoothingParams::alpha = soundSmoothingParams::getAlpha();
+	}
+};
+
 ENGINE_API float psHUD_FOV_def = 0.45f;
 ENGINE_API float psHUD_FOV = psHUD_FOV_def;
 
@@ -864,6 +891,23 @@ Ivector4 g_crosshair_color_temp;
 float g_freelook_z_offset;
 float g_ironsights_factor = 1.25f;
 
+// crookr fake scope params (sorry)
+float scope_fog_interp = 0.15f;
+float scope_fog_travel = 0.25f;
+float scope_fog_attack = 0.66f;
+float scope_fog_mattack = 0.25f;
+//float scope_drift_amount = 1.f;
+float scope_ca = 0.003f;
+float scope_outerblur = 1.0f;
+float scope_innerblur = 0.1f;
+float scope_scrollpower = 0.66f;
+float scope_brightness = 1.0f;
+float scope_radius = 0.f;
+float scope_fog_radius = 1.25f;
+float scope_fog_sharp = 4.0f;
+int scope_2dtexactive = 0.0;
+Fvector3 ssfx_wetness_multiplier = Fvector3().set(1.0f, 0.3f, 0.0f);
+
 void CCC_Register()
 {
 	// General
@@ -965,6 +1009,9 @@ void CCC_Register()
 	CMD3(CCC_Mask, "snd_efx", &psSoundFlags, ss_EAX);
 	CMD4(CCC_Integer, "snd_targets", &psSoundTargets, 32, 1024);
 	CMD4(CCC_Integer, "snd_cache_size", &psSoundCacheSizeMB, 8, 256);
+	// Doppler effect power
+	CMD4(CCC_Float, "snd_doppler_power", &soundSmoothingParams::power, 0.f, 5.f);
+	CMD4(CCC_SoundParamsSmoothing, "snd_doppler_smoothing", &soundSmoothingParams::steps, 1, 100);
 
 #ifdef DEBUG
     CMD3(CCC_Mask, "snd_stats", &g_stats_flags, st_sound);
@@ -1023,7 +1070,26 @@ void CCC_Register()
 		CMD4(CCC_Float, "g_freelook_z_offset_factor", &g_freelook_z_offset, -3.f, 3.f);
 
 	CMD4(CCC_Float, "g_ironsights_zoom_factor", &g_ironsights_factor, 1.f, 2.f);
+	CMD4(CCC_Vector3, "ssfx_wetness_multiplier", &ssfx_wetness_multiplier, Fvector3().set(0.1f, 0.1f, 0.0f), Fvector3().set(20.0f, 20.0f, 0.0f));
 	
+	// - CrookR
+	CMD2(CCC_Float, "scope_blur_outer", &scope_outerblur);
+	CMD2(CCC_Float, "scope_blur_inner", &scope_innerblur);
+	CMD2(CCC_ScopeFactor, "scope_factor", &scope_scrollpower);
+	CMD2(CCC_Float, "scope_brightness", &scope_brightness);
+
+	CMD2(CCC_Float, "scope_fog_interp", &scope_fog_interp);
+	CMD4(CCC_Float, "scope_fog_travel", &scope_fog_travel, 0.f, 5.f);
+	CMD4(CCC_Float, "scope_fog_swayAim", &scope_fog_attack, -999.f, 999.f);
+	CMD4(CCC_Float, "scope_fog_swayMove", &scope_fog_mattack, -999.f, 999.f);
+	//CMD4(CCC_Float, "scope_drift_amount", &scope_drift_amount, -999.f, 999.f);
+
+	CMD2(CCC_Float, "scope_ca", &scope_ca);
+	CMD4(CCC_Float, "scope_radius", &scope_radius, 0, 2);
+	CMD4(CCC_Float, "scope_fog_radius", &scope_fog_radius, 0, 1000);
+	CMD4(CCC_Float, "scope_fog_sharp", &scope_fog_sharp, 0, 1000);
+	CMD2(CCC_Integer, "scope_2dtexactive", &scope_2dtexactive);
+
 #ifdef DEBUG
     extern BOOL debug_destroy;
     CMD4(CCC_Integer, "debug_destroy", &debug_destroy, FALSE, TRUE);
diff --git a/src/xrGame/Actor.cpp b/src/xrGame/Actor.cpp
index 899a940..9bf276b 100644
--- a/src/xrGame/Actor.cpp
+++ b/src/xrGame/Actor.cpp
@@ -246,6 +246,8 @@ CActor::CActor() : CEntityAlive(), current_ik_cam_shift(0)
 	m_bSafemode = false;
 
 	m_bDelayDrawPickupItems = false;
+
+	m_FPCam = NULL;
 }
 
 
@@ -829,6 +831,7 @@ void CActor::HitSignal(float perc, Fvector& vLocalDir, CObject* who, s16 element
 }
 
 void start_tutorial(LPCSTR name);
+extern BOOL firstPersonDeath;
 
 void CActor::Die(CObject* who)
 {
@@ -920,11 +923,25 @@ void CActor::Die(CObject* who)
 
 	if (IsGameTypeSingle())
 	{
-#ifdef FP_DEATH
-        cam_Set(eacFirstEye);
-#else
-		cam_Set(eacFreeLook);
-#endif // FP_DEATH
+		// demonized: First Person Death
+		if (firstPersonDeath) {
+			cam_Set(eacFirstEye);
+			initFPCam();
+			Fvector pos = Device.vCameraPosition;
+			Fvector hpb;
+			hpb.set(
+				Device.vCameraDirection.getH(),
+				Device.vCameraDirection.getP(),
+				0
+			);
+			m_FPCam->m_Position.set(pos);
+			m_FPCam->m_HPB.set(hpb);
+			m_FPCam->m_Camera.setHPB(hpb.x, hpb.y, hpb.z).translate_over(pos);
+			m_FPCam->m_customSmoothing = 0;
+		}
+		else
+			cam_Set(eacFreeLook);
+
 		CurrentGameUI()->HideShownDialogs();
 
 		/* avo: attempt to set camera on timer */
@@ -1566,8 +1583,26 @@ void CActor::shedule_Update(u32 DT)
 		if (bHudView)
 		{
 			CInventoryItem* pInvItem = inventory().ActiveItem();
-			if (!pInvItem)
+			if (pInvItem)
+			{
+				CHudItem* pHudItem = smart_cast<CHudItem*>(pInvItem);
+				if (pHudItem)
+				{
+					if (pHudItem->IsHidden())
+					{
+						g_player_hud->detach_item(pHudItem);
+					}
+					else
+					{
+						g_player_hud->attach_item(pHudItem);
+					}
+				}
+			}
+			else
+			{
 				g_player_hud->detach_item_idx(0);
+				//Msg("---No active item in inventory(), item 0 detached.");
+			}
 		}
 		else
 		{
@@ -1933,7 +1968,8 @@ extern	BOOL	g_ShowAnimationInfo		;
 void CActor::OnHUDDraw(CCustomHUD*)
 {
 	R_ASSERT(IsFocused());
-	if (!((mstate_real & mcLookout) && !IsGameTypeSingle()))
+	//demonized: disable hud when FPCam is on
+	if (!((mstate_real & mcLookout) && !IsGameTypeSingle()) && !m_FPCam)
 		g_player_hud->render_hud();
 
 
@@ -2675,3 +2711,20 @@ void CActor::SwitchNightVision(bool vision_on, bool use_sounds, bool send_event)
 		//Msg("GE_TRADER_FLAGS event sent %d", m_trader_flags.get());
 	}
 }
+
+// demonized: First Person Death
+void CActor::initFPCam()
+{
+	if (!m_FPCam) {
+		m_FPCam = xr_new<CFPCamEffector>();
+		Cameras().AddCamEffector(m_FPCam);
+	}
+}
+
+void CActor::removeFPCam() 
+{
+	if (m_FPCam) {
+		Cameras().RemoveCamEffector(m_FPCam);
+		m_FPCam = NULL;
+	}
+}
diff --git a/src/xrGame/Actor.h b/src/xrGame/Actor.h
index 1440969..eee4444 100644
--- a/src/xrGame/Actor.h
+++ b/src/xrGame/Actor.h
@@ -61,6 +61,7 @@ class CActorStatisticMgr;
 class CLocationManager;
 
 class CNightVisionEffector;
+class CFPCamEffector;
 
 class CActor :
 	public CEntityAlive,
@@ -81,6 +82,14 @@ public:
 	CActor();
 	virtual ~CActor();
 
+// demonized: First Person Death
+public:
+	CFPCamEffector* m_FPCam;
+
+public:
+	void initFPCam();
+	void removeFPCam();
+
 public:
 	virtual BOOL AlwaysTheCrow() { return TRUE; }
 
@@ -458,6 +467,9 @@ public:
 	float m_fRun_StrafeFactor;
 	float m_fSprint_StrafeFactor;
 
+	// demonized: lookout modifier
+	float m_fLookoutFactor = 1;
+
 public:
 	Fvector GetMovementSpeed() { return NET_SavedAccel; };
 	//////////////////////////////////////////////////////////////////////////
diff --git a/src/xrGame/ActorCameras.cpp b/src/xrGame/ActorCameras.cpp
index 19a5c6c..0b324e9 100644
--- a/src/xrGame/ActorCameras.cpp
+++ b/src/xrGame/ActorCameras.cpp
@@ -28,6 +28,9 @@
 #include "player_hud.h"
 #include "Missile.h"
 
+#include "EffectorBobbing.h"
+class CFPCamEffector;
+
 ENGINE_API extern float psHUD_FOV;
 ENGINE_API extern float psHUD_FOV_def;
 
@@ -453,6 +456,14 @@ static const float ik_cam_shift_tolerance = 0.2f;
 static const float ik_cam_shift_speed = 0.01f;
 #endif
 
+BOOL firstPersonDeath = TRUE;
+float offsetH = 0;
+float offsetP = 0;
+float offsetB = 0;
+float offsetX = 0;
+float offsetY = 0;
+float offsetZ = 0;
+float viewportNearOffset = 0;
 void CActor::cam_Update(float dt, float fFOV)
 {
 	if (m_holder) return;
@@ -576,6 +587,53 @@ void CActor::cam_Update(float dt, float fFOV)
 	{
 		collide_camera(*cameras[eacFirstEye], _viewport_near, this);
 	}
+	
+	if (cam_active == eacFirstEye) {
+		if (firstPersonDeath && !g_Alive() && m_FPCam) {
+			IKinematics* k = Visual()->dcast_PKinematics();
+
+			// Get eye bone position
+			CBoneInstance& eyeBone = k->LL_GetBoneInstance(m_eye_right);
+			Fmatrix matrix = Fidentity;
+			matrix.mul_43(XFORM(), eyeBone.mTransform);
+			Fvector camPos = (matrix.c);
+
+			// Get head bone direction, works better for first person death
+			CBoneInstance& headBone = k->LL_GetBoneInstance(m_head);
+			Fmatrix matrixDir = Fidentity;
+			Fvector camDir;
+			matrixDir.mul_43(XFORM(), headBone.mTransform);
+			matrixDir.getHPB(camDir);
+
+			// Adjust camera direction
+			Fvector adjustedCamDir;
+			adjustedCamDir.set(camDir).setHP(
+				camDir.x + deg2rad(8.f) + deg2rad(offsetH),
+				camDir.y - deg2rad(20.f) + deg2rad(offsetP)
+			);
+			camDir.set(
+				adjustedCamDir.getH(),
+				adjustedCamDir.getP(),
+				camDir.z + deg2rad(90.f) + deg2rad(offsetB)
+			);
+			if (camDir.x < 0) {
+				camDir.x = PI_MUL_2 + camDir.x;
+			}
+
+			Fvector dir, dirUp, dirRight;
+			dir.setHP(camDir.x, camDir.y);
+			Fvector::generate_orthonormal_basis_normalized(dir, dirUp, dirRight);
+
+			camPos.mad(dir, -0.04 + offsetZ);
+			camPos.mad(dirUp, offsetY);
+			camPos.mad(dirRight, -0.01 + offsetX);
+
+			m_FPCam->m_HPB.set(camDir);
+			m_FPCam->m_Position.set(camPos);
+			_viewport_near = VIEWPORT_NEAR - 0.08 + viewportNearOffset;
+			//Cameras().ApplyDevice(_viewport_near);
+		}
+	}
 
 	//Alundaio -psp always
 	//if( psActorFlags.test(AF_PSP) )
diff --git a/src/xrGame/ActorInput.cpp b/src/xrGame/ActorInput.cpp
index 8499334..ad4f3ec 100644
--- a/src/xrGame/ActorInput.cpp
+++ b/src/xrGame/ActorInput.cpp
@@ -433,7 +433,7 @@ void CActor::IR_OnMouseMove(int dx, int dy)
 	float LookFactor = GetLookFactor();
 
 	CCameraBase* C = cameras[cam_active];
-	float scale = (C->f_fov / g_fov) * psMouseSens * psMouseSensScale / 50.f / LookFactor;
+    float scale = (C->f_fov / g_fov) * (psMouseSens * sens_multiple) * psMouseSensScale / 50.f / LookFactor;
 	if (dx)
 	{
 		float d = float(dx) * scale;
@@ -592,11 +592,11 @@ void CActor::ActorUse()
 		}
 	}
 }
-
+extern BOOL firstPersonDeath;
 BOOL CActor::HUDview() const
 {
 	return IsFocused() && (cam_active == eacFirstEye) &&
-		((!m_holder) || (m_holder && m_holder->allowWeapon() && m_holder->HUDView()));
+		((!m_holder) || (m_holder && m_holder->allowWeapon() && m_holder->HUDView())) && (firstPersonDeath ? g_Alive() : true);
 }
 
 static u16 SlotsToCheck [] = {
diff --git a/src/xrGame/Actor_Movement.cpp b/src/xrGame/Actor_Movement.cpp
index b95ff6c..b49421b 100644
--- a/src/xrGame/Actor_Movement.cpp
+++ b/src/xrGame/Actor_Movement.cpp
@@ -426,6 +426,9 @@ void CActor::g_Orientate(u32 mstate_rl, float dt)
 	{
 		tgt_roll = (mstate_rl & mcLLookout) ? -ACTOR_LLOOKOUT_ANGLE : ACTOR_RLOOKOUT_ANGLE;
 
+		// demonized: add lookout modifier
+		tgt_roll *= m_fLookoutFactor;
+
 		if ((mstate_rl & mcLLookout) && (mstate_rl & mcRLookout))
 			tgt_roll = 0.0f;
 	}
diff --git a/src/xrGame/Actor_Weapon.cpp b/src/xrGame/Actor_Weapon.cpp
index 14eefbd..931a042 100644
--- a/src/xrGame/Actor_Weapon.cpp
+++ b/src/xrGame/Actor_Weapon.cpp
@@ -287,6 +287,9 @@ void CActor::on_weapon_shot_start(CWeapon* weapon)
 		{
 			effector->Initialize(camera_recoil);
 		}
+		else {
+			effector->UpdateCameraRecoil(camera_recoil);
+		}
 	}
 
 	effector->m_WeaponID = weapon->ID();
diff --git a/src/xrGame/Artefact.h b/src/xrGame/Artefact.h
index 35f5e1c..2298a74 100644
--- a/src/xrGame/Artefact.h
+++ b/src/xrGame/Artefact.h
@@ -70,7 +70,6 @@ protected:
 	float m_fTrailLightRange;
 	u8 m_af_rank;
 	bool m_bLightsEnabled;
-	float m_additional_weight;
 
 	virtual void UpdateLights();
 public:
@@ -91,6 +90,8 @@ public:
 	{
 	};
 
+	float m_additional_weight;
+
 	float AdditionalInventoryWeight() const { return m_additional_weight; }
 	bool m_bCanSpawnZone;
 	float m_fHealthRestoreSpeed;
diff --git a/src/xrGame/CustomOutfit.cpp b/src/xrGame/CustomOutfit.cpp
index 350d6f1..df7f414 100644
--- a/src/xrGame/CustomOutfit.cpp
+++ b/src/xrGame/CustomOutfit.cpp
@@ -110,7 +110,8 @@ void CCustomOutfit::Load(LPCSTR section)
 
 	m_full_icon_name = pSettings->r_string(section, "full_icon_name");
 	m_artefact_count = READ_IF_EXISTS(pSettings, r_u32, section, "artefact_count", 0);
-	clamp(m_artefact_count, (u32)0, (u32)5);
+	//clamp(m_artefact_count, (u32)0, (u32)5);
+	m_artefact_count = _max(m_artefact_count, (u32)0);
 
 	m_BonesProtectionSect = READ_IF_EXISTS(pSettings, r_string, section, "bones_koeff_protection", "");
 	bIsHelmetAvaliable = !!READ_IF_EXISTS(pSettings, r_bool, section, "helmet_avaliable", true);
@@ -363,7 +364,8 @@ bool CCustomOutfit::install_upgrade_impl(LPCSTR section, bool test)
 	clamp(m_fPowerLoss, 0.0f, 1.0f);
 
 	result |= process_if_exists(section, "artefact_count", &CInifile::r_u32, m_artefact_count, test);
-	clamp(m_artefact_count, (u32)0, (u32)5);
+	//clamp(m_artefact_count, (u32)0, (u32)5);
+	m_artefact_count = _max(m_artefact_count, (u32)0);
 
 	return result;
 }
diff --git a/src/xrGame/CustomZone.cpp b/src/xrGame/CustomZone.cpp
index ff568cd..248e7b8 100644
--- a/src/xrGame/CustomZone.cpp
+++ b/src/xrGame/CustomZone.cpp
@@ -22,6 +22,8 @@
 #define WIND_RADIUS (4*Radius())	//расстояние до актера, когда появляется ветер 
 #define FASTMODE_DISTANCE (100.f)	//distance to camera from sphere, when zone switches to fast update sequence
 
+extern Fvector4 ps_ssfx_int_grass_params_1;
+
 CCustomZone::CCustomZone(void)
 {
 	m_zone_flags.zero();
@@ -59,6 +61,7 @@ CCustomZone::CCustomZone(void)
 
 CCustomZone::~CCustomZone(void)
 {
+	g_pGamePersistent->GrassBendersRemoveByIndex(grassbender_id);
 	m_idle_sound.destroy();
 	m_accum_sound.destroy();
 	m_awaking_sound.destroy();
@@ -96,6 +99,59 @@ void CCustomZone::Load(LPCSTR section)
 
 	LPCSTR sound_str = NULL;
 
+	// -- Interactive Grass - IDLE
+	if (pSettings->line_exist(section, "bend_grass_idle_anim"))
+		m_BendGrass_idle_anim = pSettings->r_s8(section, "bend_grass_idle_anim");
+	else
+		m_BendGrass_idle_anim = -1;
+
+	if (pSettings->line_exist(section, "bend_grass_idle_str"))
+		m_BendGrass_idle_str = pSettings->r_float(section, "bend_grass_idle_str");
+	else
+		m_BendGrass_idle_str = 1.0f;
+
+	if (pSettings->line_exist(section, "bend_grass_idle_radius"))
+		m_BendGrass_idle_radius = pSettings->r_float(section, "bend_grass_idle_radius");
+	else
+		m_BendGrass_idle_radius = 1.0f;
+
+	if (pSettings->line_exist(section, "bend_grass_idle_speed"))
+		m_BendGrass_idle_speed = pSettings->r_float(section, "bend_grass_idle_speed");
+	else
+		m_BendGrass_idle_speed = 1.0f;
+
+	// -- Interactive Grass - ACTIVE
+	if (pSettings->line_exist(section, "bend_grass_whenactive_anim"))
+		m_BendGrass_whenactive_anim = pSettings->r_s8(section, "bend_grass_whenactive_anim");
+	else
+		m_BendGrass_whenactive_anim = -1;
+
+	if (pSettings->line_exist(section, "bend_grass_whenactive_speed"))
+		m_BendGrass_whenactive_speed = pSettings->r_float(section, "bend_grass_whenactive_speed");
+	else
+		m_BendGrass_whenactive_speed = -1;
+
+	if (pSettings->line_exist(section, "bend_grass_whenactive_str"))
+		m_BendGrass_whenactive_str = pSettings->r_float(section, "bend_grass_whenactive_str");
+	else
+		m_BendGrass_whenactive_str = -1;
+
+	// -- Interactive Grass - BLOWOUT
+	if (pSettings->line_exist(section, "bend_grass_blowout_duration"))
+		m_BendGrass_Blowout_time = pSettings->r_u32(section, "bend_grass_blowout_duration");
+	else
+		m_BendGrass_Blowout_time = -1;
+
+	if (pSettings->line_exist(section, "bend_grass_blowout"))
+		m_BendGrass_Blowout = pSettings->r_bool(section, "bend_grass_blowout");
+
+	if (pSettings->line_exist(section, "bend_grass_blowout_speed"))
+		m_BendGrass_Blowout_speed = pSettings->r_float(section, "bend_grass_blowout_speed");
+
+	if (pSettings->line_exist(section, "bend_grass_blowout_radius"))
+		m_BendGrass_Blowout_radius = pSettings->r_float(section, "bend_grass_blowout_radius");
+	// --
+
 	if (pSettings->line_exist(section, "idle_sound"))
 	{
 		sound_str = pSettings->r_string(section, "idle_sound");
@@ -582,6 +638,31 @@ void CCustomZone::shedule_Update(u32 dt)
 
 		if (!m_zone_flags.test(eFastMode))
 			UpdateWorkload(dt);
+
+		if (act_distance < ps_ssfx_int_grass_params_1.w)
+			GrassZoneUpdate();
+		else
+		{
+			// Out of range, fadeOut if a grassbender_id is assigned
+			if (grassbender_id)
+			{
+				IGame_Persistent::grass_data& GData = g_pGamePersistent->grass_shader_data;
+
+				// If the ID doesn't match... Just remove the grassbender_id.
+				if (GData.id[grassbender_id] == ID())
+				{
+					GData.str_target[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.str_target[grassbender_id], 0.0f, 4.0f, false);
+
+					// Remove ( Don't worry, GrassBenderToValue() it's going to get the == 0 )
+					if (GData.str_target[grassbender_id] == 0)
+						g_pGamePersistent->GrassBendersRemoveByIndex(grassbender_id);
+				}
+				else
+				{
+					grassbender_id = NULL;
+				}
+			}
+		}
 	};
 
 	UpdateOnOffState();
@@ -786,6 +867,8 @@ void CCustomZone::PlayBlowoutParticles()
 	pParticles = CParticlesObject::Create(*m_sBlowoutParticles,TRUE);
 	pParticles->UpdateParent(XFORM(), zero_vel);
 	pParticles->Play(false);
+
+	m_fBlowoutTimeLeft = (float)Device.dwTimeGlobal + m_BendGrass_Blowout_time;
 }
 
 void CCustomZone::PlayHitParticles(CGameObject* pObject)
@@ -1125,6 +1208,9 @@ void CCustomZone::UpdateBlowout()
 		m_dwBlowoutExplosionTime < (u32)m_iStateTime)
 	{
 		AffectObjects();
+		
+		if (m_BendGrass_Blowout)
+			g_pGamePersistent->GrassBendersAddExplosion(ID(), Position(), Fvector().set(0, -99, 0), 1.33f, m_BendGrass_Blowout_speed, 1.0f, m_BendGrass_Blowout_radius);
 	}
 }
 
@@ -1158,6 +1244,13 @@ void CCustomZone::OnMove()
 
 		if (m_pIdleLight && m_pIdleLight->get_active())
 			m_pIdleLight->set_position(Position());
+
+		if (grassbender_id)
+		{
+			// Check ID, just in case...
+			if (g_pGamePersistent->grass_shader_data.id[grassbender_id] == ID())
+				g_pGamePersistent->grass_shader_data.pos[grassbender_id] = Position();
+		}
 	}
 }
 
@@ -1597,3 +1690,61 @@ void CCustomZone::load(IReader& input_packet)
 	else
 		m_eZoneState = eZoneStateIdle;
 }
+
+void CCustomZone::GrassZoneUpdate()
+{
+	if (m_BendGrass_idle_anim == -1 && m_BendGrass_whenactive_anim == -1)
+		return;
+
+	IGame_Persistent::grass_data& GData = g_pGamePersistent->grass_shader_data;
+	bool IsActive;
+	s8 targetAnim = -1;
+
+	// If m_BendGrass_Blowout_time is not set, use m_eZoneState to detect activation
+	if (m_BendGrass_Blowout_time <= -1)
+		IsActive = m_eZoneState != eZoneStateIdle;
+	else
+		IsActive = m_fBlowoutTimeLeft > (float)Device.dwTimeGlobal;
+
+	// Target animation depending if Zone is active
+	if (IsActive)
+		targetAnim = (m_BendGrass_whenactive_anim > -1) ? m_BendGrass_whenactive_anim : m_BendGrass_idle_anim;
+	else
+		targetAnim = m_BendGrass_idle_anim;
+
+	// Update grass bender if the animation is > -1
+	if (targetAnim > 0 || (GData.anim[grassbender_id] > 0 && grassbender_id > 0))
+		g_pGamePersistent->GrassBendersUpdate(ID(), grassbender_id, grassbender_frame, Position(), m_BendGrass_idle_radius, 0.0f, false);
+	else
+		g_pGamePersistent->GrassBendersRemoveByIndex(grassbender_id);
+
+	// Return if grassbender_id doesn't exist
+	if (grassbender_id <= 0)
+		return;
+
+	// Animation transition, diminish intensity to 0 and change.
+	if (GData.anim[grassbender_id] != targetAnim)
+	{
+		GData.str_target[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.str_target[grassbender_id], 0.0f, 7.5f, false);
+
+		if (GData.str_target[grassbender_id] <= 0.05f)
+			GData.anim[grassbender_id] = targetAnim;
+
+		return;
+	}
+
+	// Apply settings when needed
+	if (IsActive)
+	{
+		if (m_BendGrass_whenactive_speed >= 0)
+			GData.speed[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.speed[grassbender_id], m_BendGrass_whenactive_speed, 10.0f, true);
+
+		if (m_BendGrass_whenactive_str >= 0)
+			GData.str_target[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.str_target[grassbender_id], m_BendGrass_whenactive_str, 10.0f, true);
+	}
+	else
+	{
+		GData.speed[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.speed[grassbender_id], m_BendGrass_idle_speed, 10.0f, true);
+		GData.str_target[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.str_target[grassbender_id], m_BendGrass_idle_str, 10.0f, true);
+	}
+}
\ No newline at end of file
diff --git a/src/xrGame/CustomZone.h b/src/xrGame/CustomZone.h
index 3baa654..eca8679 100644
--- a/src/xrGame/CustomZone.h
+++ b/src/xrGame/CustomZone.h
@@ -159,6 +159,28 @@ protected:
 	float volumetric_intensity;
 	float volumetric_quality;
 
+	// Interactive grass Settings
+	float m_fBlowoutTimeLeft;
+
+	s8 m_BendGrass_idle_anim;
+	float m_BendGrass_idle_radius;
+	float m_BendGrass_idle_speed;
+	float m_BendGrass_idle_str;
+
+	s8 m_BendGrass_whenactive_anim;
+	float m_BendGrass_whenactive_speed;
+	float m_BendGrass_whenactive_str;
+
+	bool m_BendGrass_Blowout;
+	s32 m_BendGrass_Blowout_time;
+	float m_BendGrass_Blowout_speed;
+	float m_BendGrass_Blowout_radius;
+
+	u8 grassbender_id;
+	u32 grassbender_frame;
+
+	void GrassZoneUpdate();
+
 	//массив с временами, сколько каждое состояние должно 
 	//длиться (если 0, то мгновенно -1 - бесконечность, 
 	//-2 - вообще не должно вызываться)
diff --git a/src/xrGame/EffectorBobbing.cpp b/src/xrGame/EffectorBobbing.cpp
index ffd7c19..4ac05a2 100644
--- a/src/xrGame/EffectorBobbing.cpp
+++ b/src/xrGame/EffectorBobbing.cpp
@@ -113,3 +113,56 @@ BOOL CEffectorBobbing::ProcessCam(SCamEffectorInfo& info)
 	//	}
 	return TRUE;
 }
+
+// demonized: First Person Death (Cam Effector, can be used in scripts any time to set custom position and direction)
+CFPCamEffector::CFPCamEffector() : CEffectorCam(eCEUser, INT_MAX) {
+	m_Camera.identity();
+	m_Camera.setHPB(0, 0, 0);
+	m_HPB.set(0, 0, 0);
+	m_Position.set(0, 0, 0);
+	m_customSmoothing = 0;
+}
+
+// EMA smoothing for changing values, frame independent
+int firstPersonDeathPositionSmoothing = 6;
+int firstPersonDeathDirectionSmoothing = 12;
+
+void CFPCamEffector::ema(Fvector &current, Fvector &target, unsigned int steps) {
+	float smoothing_alpha = 2.0 / (steps + 1);
+	float delta = Device.dwTimeDelta;
+
+	if (fis_zero(current.x) && fis_zero(current.y) && fis_zero(current.z)) {
+		current.x = target.x;
+		current.y = target.y;
+		current.z = target.z;
+		return;
+	}
+
+	current.x = current.x + min(1.f, smoothing_alpha * (delta / steps)) * (target.x - current.x);
+	current.y = current.y + min(1.f, smoothing_alpha * (delta / steps)) * (target.y - current.y);
+	current.z = current.z + min(1.f, smoothing_alpha * (delta / steps)) * (target.z - current.z);
+}
+
+BOOL CFPCamEffector::ProcessCam(SCamEffectorInfo& info)
+{
+	// Set target camera
+	Fmatrix temp;
+	temp.identity().setHPB(m_HPB.x, m_HPB.y, m_HPB.z).translate_over(m_Position);
+
+	// Smooth out transition between current camera and target
+	if (m_customSmoothing) {
+		ema(m_Camera.j, temp.j, m_customSmoothing);
+		ema(m_Camera.k, temp.k, m_customSmoothing);
+		ema(m_Camera.c, temp.c, m_customSmoothing);
+	} else {
+		ema(m_Camera.j, temp.j, firstPersonDeathDirectionSmoothing);
+		ema(m_Camera.k, temp.k, firstPersonDeathDirectionSmoothing);
+		ema(m_Camera.c, temp.c, firstPersonDeathPositionSmoothing);
+	}
+
+	// update camera
+	info.n.set(m_Camera.j);
+	info.d.set(m_Camera.k);
+	info.p.set(m_Camera.c);
+	return TRUE;
+}
\ No newline at end of file
diff --git a/src/xrGame/EffectorBobbing.h b/src/xrGame/EffectorBobbing.h
index 854b7a7..e202596 100644
--- a/src/xrGame/EffectorBobbing.h
+++ b/src/xrGame/EffectorBobbing.h
@@ -33,3 +33,19 @@ public:
 };
 
 #endif //_EFFECTOR_BOBBING_H
+
+// demonized: First Person Death Cam Effector
+class CFPCamEffector : public CEffectorCam
+{
+public:
+	Fvector m_Position;
+	Fvector m_HPB;
+	Fmatrix m_Camera;
+	unsigned int m_customSmoothing; // 0 - use FPDeath smoothing params, no custom smoothing
+	virtual void ema(Fvector& current, Fvector& target, unsigned int steps);
+	
+public:
+	CFPCamEffector();
+	virtual BOOL ProcessCam(SCamEffectorInfo& info);
+
+};
diff --git a/src/xrGame/EffectorShot.cpp b/src/xrGame/EffectorShot.cpp
index 8ac8fa4..a7ae406 100644
--- a/src/xrGame/EffectorShot.cpp
+++ b/src/xrGame/EffectorShot.cpp
@@ -21,6 +21,11 @@ void CWeaponShotEffector::Initialize(const CameraRecoil& cam_recoil)
 	Reset();
 }
 
+void CWeaponShotEffector::UpdateCameraRecoil(const CameraRecoil& cam_recoil)
+{
+	m_cam_recoil.Clone(cam_recoil);
+}
+
 void CWeaponShotEffector::Reset()
 {
 	m_angle_vert = 0.0f;
diff --git a/src/xrGame/EffectorShot.h b/src/xrGame/EffectorShot.h
index 451d458..500db02 100644
--- a/src/xrGame/EffectorShot.h
+++ b/src/xrGame/EffectorShot.h
@@ -45,6 +45,7 @@ public:
 	};
 
 	void Initialize(const CameraRecoil& cam_recoil);
+	void UpdateCameraRecoil(const CameraRecoil& cam_recoil);
 	void Reset();
 
 	IC bool IsActive() { return m_actived; }
diff --git a/src/xrGame/EliteDetector.cpp b/src/xrGame/EliteDetector.cpp
index add236a..d5b0641 100644
--- a/src/xrGame/EliteDetector.cpp
+++ b/src/xrGame/EliteDetector.cpp
@@ -146,12 +146,7 @@ void CUIArtefactDetectorElite::Draw()
 	Fmatrix LM;
 	GetUILocatorMatrix(LM);
 
-	IUIRender::ePointType bk = UI().m_currentPointType;
-
-	UI().m_currentPointType = IUIRender::pttLIT;
-
 	UIRender->CacheSetXformWorld(LM);
-	UIRender->CacheSetCullMode(IUIRender::cmNONE);
 
 	CUIWindow::Draw();
 
@@ -193,7 +188,7 @@ void CUIArtefactDetectorElite::Draw()
 		}
 	}
 
-	UI().m_currentPointType = bk;
+	UI().ScreenFrustumLIT().Clear();
 }
 
 void CUIArtefactDetectorElite::GetUILocatorMatrix(Fmatrix& _m)
diff --git a/src/xrGame/Entity.cpp b/src/xrGame/Entity.cpp
index 70a5767..11b4e80 100644
--- a/src/xrGame/Entity.cpp
+++ b/src/xrGame/Entity.cpp
@@ -401,3 +401,24 @@ void CEntity::ChangeTeam(int team, int squad, int group)
 	Level().seniority_holder().team(g_Team()).squad(g_Squad()).group(g_Group()).register_member(this);
 	on_after_change_team();
 }
+
+//--DSR-- HeatVision_start
+u32 clampU(u32 x, u32 a, u32 b) {
+	if (x < a) return a;
+	else if (x > b) return b;
+	return x;
+}
+
+float CEntity::GetHotness() {
+	if (AlreadyDie() || !g_Alive())
+		return 1.0f - (float)clampU(Device.dwTimeGlobal - m_level_death_time, 0, 20000) / 20000.0f;
+	return 1.0f;
+}
+
+void CEntity::OnChangeVisual()
+{
+	inherited::OnChangeVisual();
+	if (renderable.visual != 0)
+		renderable.visual->MarkAsHot(true);
+}
+//--DSR-- HeatVision_end
diff --git a/src/xrGame/Entity.h b/src/xrGame/Entity.h
index c5697ab..b21f2ec 100644
--- a/src/xrGame/Entity.h
+++ b/src/xrGame/Entity.h
@@ -82,6 +82,11 @@ public:
 	/*	virtual*/
 	IC void SetMaxHealth(float v) { m_entity_condition->max_health() = v; }
 
+	//--DSR-- HeatVision_start
+	virtual float GetHotness();
+	virtual void  OnChangeVisual();
+	//--DSR-- HeatVision_end
+
 	/*virtual*/
 	IC BOOL g_Alive() const { return GetfHealth() > 0; }
 	virtual BOOL g_State(SEntityState&) const { return FALSE; }
diff --git a/src/xrGame/Explosive.cpp b/src/xrGame/Explosive.cpp
index ef648e9..4154e12 100644
--- a/src/xrGame/Explosive.cpp
+++ b/src/xrGame/Explosive.cpp
@@ -341,6 +341,11 @@ void CExplosive::Explode()
 		DBG_DrawPoint(pos,0.3f,D3DCOLOR_XRGB(255,0,0));
 	}
 #endif
+	
+	// Interactive Grass FX
+	extern Fvector4 ps_ssfx_int_grass_params_2;
+	g_pGamePersistent->GrassBendersAddExplosion(cast_game_object()->ID(), pos, Fvector().set(0, -99, 0), 1.33f, ps_ssfx_int_grass_params_2.y, ps_ssfx_int_grass_params_2.x, m_fBlastRadius * 2.0f);
+	
 	//	Msg("---------CExplosive Explode [%d] frame[%d]",cast_game_object()->ID(), Device.dwFrame);
 	OnBeforeExplosion();
 	//играем звук взрыва
diff --git a/src/xrGame/GameObject.cpp b/src/xrGame/GameObject.cpp
index 1516f8d..1ce2261 100644
--- a/src/xrGame/GameObject.cpp
+++ b/src/xrGame/GameObject.cpp
@@ -116,6 +116,13 @@ void CGameObject::net_Destroy()
 #endif
 
 	VERIFY(m_spawned);
+
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.CGameObject_NetDestroy", funct))
+	{
+		funct(this->lua_game_object());
+	}
+
 	if (m_anim_mov_ctrl)
 		destroy_anim_mov_ctrl();
 
@@ -441,6 +448,11 @@ BOOL CGameObject::net_Spawn(CSE_Abstract* DC)
 	}
 	BOOL ret =CScriptBinder::net_Spawn(DC);
 #else
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.CGameObject_NetSpawn", funct))
+	{
+		funct(this->lua_game_object());
+	}
 	return (CScriptBinder::net_Spawn(DC));
 #endif
 
diff --git a/src/xrGame/GamePersistent.cpp b/src/xrGame/GamePersistent.cpp
index 7087c3a..a45da94 100644
--- a/src/xrGame/GamePersistent.cpp
+++ b/src/xrGame/GamePersistent.cpp
@@ -529,6 +529,14 @@ void CGamePersistent::game_loaded()
 			m_intro->Start("game_loaded");
 			Msg("intro_start game_loaded");
 			m_intro->m_on_destroy_event.bind(this, &CGamePersistent::update_game_loaded);
+
+			// demonized
+			// Callback for when loading screen happens and "Press Any Key to Continue" prompt appears
+			luabind::functor<void> funct;
+			if (ai().script_engine().functor("_G.OnLoadingScreenKeyPrompt", funct))
+			{
+				funct();
+			}
 		}
 		m_intro_event = 0;
 	}
@@ -539,6 +547,14 @@ void CGamePersistent::update_game_loaded()
 	xr_delete(m_intro);
 	Msg("intro_delete ::update_game_loaded");
 	start_game_intro();
+
+	// demonized
+	// Callback for when player dismisses loading screen after "Press Any Key to Continue" pressed
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.OnLoadingScreenDismissed", funct))
+	{
+		funct();
+	}
 }
 
 void CGamePersistent::start_game_intro()
diff --git a/src/xrGame/HudItem.cpp b/src/xrGame/HudItem.cpp
index 85bf746..01c90a3 100644
--- a/src/xrGame/HudItem.cpp
+++ b/src/xrGame/HudItem.cpp
@@ -596,7 +596,7 @@ void CHudItem::on_a_hud_attach()
 
 void CHudItem::render_item_3d_ui()
 {
-	if (render_item_3d_ui_query() && script_ui)
+	if (script_ui)
 	{
 		Fmatrix LM;
 		Fmatrix trans = HudItemData()->m_item_transform;
@@ -618,17 +618,9 @@ void CHudItem::render_item_3d_ui()
 		else
 			LM.mulB_43(script_ui_matrix);
 
-		IUIRender::ePointType bk = UI().m_currentPointType;
-		UI().m_currentPointType = IUIRender::pttLIT;
 		UIRender->CacheSetXformWorld(LM);
-		UIRender->CacheSetCullMode(IUIRender::cmNONE);
-		UI().ScreenFrustumLIT().Clear();
 		script_ui->Draw();
-		UI().m_currentPointType = bk;
 	}
-
-	//	Restore cull mode
-	UIRender->CacheSetCullMode(IUIRender::cmCCW);
 }
 
 extern float g_end_modif;
diff --git a/src/xrGame/Level.cpp b/src/xrGame/Level.cpp
index 2f93a35..b1e4c6a 100644
--- a/src/xrGame/Level.cpp
+++ b/src/xrGame/Level.cpp
@@ -96,6 +96,74 @@ u16	GetSpawnInfo(NET_Packet &P, u16 &parent_id)
 #endif
 //-AVO
 
+namespace crash_saving {
+	extern void(*save_impl)();
+	static bool g_isSaving = false;
+	int saveCountMax = 10;
+
+	void _save_impl()
+	{
+		if (g_isSaving) return;
+		if (saveCountMax <= 0) return;
+
+		int saveCount = -1;
+		g_isSaving = true;
+		NET_Packet net_packet;
+		net_packet.w_begin(M_SAVE_GAME);
+
+		std::string path = "fatal_ctd_save_";
+		std::string path_mask(path);
+		std::string path_ext = ".scop";
+		path_mask.append("*").append(path_ext);
+
+		FS_FileSet fset_temp;
+		FS.file_list(fset_temp, "$game_saves$", FS_ListFiles | FS_RootOnly, path_mask.c_str());
+
+		std::vector<FS_File> fset(fset_temp.begin(), fset_temp.end());
+		struct {
+			bool operator()(FS_File& a, FS_File& b) {
+				return a.time_write > b.time_write;
+			}
+		} sortFilesDesc;
+		std::sort(fset.begin(), fset.end(), sortFilesDesc);
+
+		//Msg("save mask %s", path_mask.c_str());
+
+		for (auto &file : fset)
+		{
+			string128 name;
+			xr_strcpy(name, sizeof(name), file.name.c_str());
+			std::string name_string(name);
+			name_string.erase(name_string.length() - path_ext.length());
+
+			//Msg("found save file %s, save_name %s", name, name_string.c_str());
+
+			try {
+				//Msg("save number %s", name_string.substr(path.length()).c_str());
+				int name_count = std::stoi(name_string.substr(path.length()));
+				saveCount = name_count;
+				break;
+			} catch (...) {
+				Msg("!error getting save number from %s", name);
+			}
+		}
+
+		saveCount++;
+		if (saveCount >= saveCountMax) {
+			saveCount = 0;
+		}
+
+		path.append(std::to_string(saveCount));
+		net_packet.w_stringZ(path.c_str());
+		net_packet.w_u8(1);
+		CLevel& level = Level();
+		if (&level != nullptr)
+		{
+			level.Send(net_packet, net_flags(1));
+		}
+
+	}
+}
 
 CLevel::CLevel() :
 	IPureClient(Device.GetTimerGlobal())
@@ -141,12 +209,14 @@ CLevel::CLevel() :
 	g_player_hud = xr_new<player_hud>();
 	g_player_hud->load_default();
 	Msg("%s", Core.Params);
+	crash_saving::save_impl = crash_saving::_save_impl; // CLevel ready, we can save now
 }
 
 extern CAI_Space* g_ai_space;
 
 CLevel::~CLevel()
 {
+	crash_saving::save_impl = nullptr; // CLevel not available, disable crash save
 	xr_delete(g_player_hud);
 	delete_data(hud_zones_list);
 	hud_zones_list = nullptr;
diff --git a/src/xrGame/Level_Bullet_Manager.cpp b/src/xrGame/Level_Bullet_Manager.cpp
index c68bb69..7e3b612 100644
--- a/src/xrGame/Level_Bullet_Manager.cpp
+++ b/src/xrGame/Level_Bullet_Manager.cpp
@@ -12,6 +12,7 @@
 #include "game_cl_base_weapon_usage_statistic.h"
 #include "game_cl_mp.h"
 #include "reward_event_generator.h"
+#include "material_manager.h"
 
 #include "../Include/xrRender/UIRender.h"
 #include "../Include/xrRender/Kinematics.h"
@@ -41,6 +42,7 @@ SBullet::~SBullet()
 {
 }
 
+u32 SBullet::bulletCount = 0;
 
 void SBullet::Init(const Fvector& position,
                    const Fvector& direction,
@@ -106,6 +108,37 @@ void SBullet::Init(const Fvector& position,
 
 	targetID = 0;
 	density_mode = 0;
+
+	catridgeSection = cartridge.m_ammoSect.c_str();
+	bulletId = bulletCount++;
+}
+
+// demonized: construct bullet table for Lua
+void populateBulletTable (
+	luabind::object& table,
+	const Fvector& position,
+	const Fvector& direction,
+	float speed,
+	float fly_dist,
+	LPCSTR catridgeSection,
+	u32 bulletId,
+	u16 weaponId,
+	u16 parentId,
+	u16 targetId,
+	LPCSTR materialName,
+	float life_time
+) {
+	table["position"] = position;
+	table["direction"] = direction;
+	table["speed"] = speed;
+	table["distance"] = fly_dist;
+	table["section"] = catridgeSection;
+	table["bullet_id"] = bulletId;
+	table["weapon_id"] = weaponId;
+	table["parent_id"] = parentId;
+	table["target_id"] = targetId;
+	table["material"] = materialName;
+	table["life_time"] = life_time;
 }
 
 
@@ -229,6 +262,28 @@ void CBulletManager::AddBullet(const Fvector& position,
 	            e_hit_type, maximum_distance, cartridge, air_resistance_factor, SendHit, iShotNum);
 	//	bullet.frame_num			= Device.dwFrame;
 	bullet.flags.aim_bullet = AimBullet;
+
+	// demonized - bullet on init callback
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.CBulletOnInit", funct)) {
+		luabind::object table = luabind::newtable(ai().script_engine().lua());
+		populateBulletTable(
+			table,
+			position,
+			direction,
+			starting_speed,
+			0,
+			bullet.catridgeSection,
+			bullet.bulletId,
+			bullet.weapon_id,
+			bullet.parent_id,
+			65535,
+			NULL,
+			bullet.life_time
+		);
+		funct(table);
+	}
+
 	if (!IsGameTypeSingle())
 	{
 		if (SendHit)
@@ -836,6 +891,13 @@ bool CBulletManager::trajectory_check_error(
 	bullet.start_velocity = Fvector().mul(bullet.dir, bullet.speed);
 	bullet.born_time += iFloor(data.collide_time * 1000.f);
 	bullet.life_time = 0.f;
+
+	// Add RQ range to the bullet fly dist
+	for (auto i = storage.r_begin(); i != storage.r_end();) {
+		bullet.fly_dist += i->range;
+		break;
+	}
+	
 	return (false);
 }
 
@@ -867,6 +929,41 @@ static bool try_update_bullet(SBullet& bullet, Fvector const& gravity, float con
 	bullet.bullet_pos = new_position;
 	bullet.dir = Fvector(new_velocity).normalize_safe();
 	bullet.life_time = time;
+
+	// demonized: bullet on update callback
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.CBulletOnUpdate", funct)) {
+		luabind::object table = luabind::newtable(ai().script_engine().lua());
+		populateBulletTable(
+			table,
+			bullet.bullet_pos,
+			bullet.dir,
+			bullet.speed,
+			bullet.fly_dist,
+			bullet.catridgeSection,
+			bullet.bulletId,
+			bullet.weapon_id,
+			bullet.parent_id,
+			65535,
+			NULL,
+			bullet.life_time
+		);
+		funct(table);
+
+		/*
+		luabind::object output = funct(table);
+
+		if (output && output.type() == LUA_TTABLE) {
+			bullet.bullet_pos = luabind::object_cast<Fvector>(table["position"]);
+			bullet.dir = luabind::object_cast<Fvector>(table["direction"]);
+			bullet.speed = luabind::object_cast<float>(table["speed"]);
+			bullet.fly_dist = luabind::object_cast<float>(table["distance"]);
+			bullet.weapon_id = luabind::object_cast<u16>(table["weapon_id"]);
+			bullet.parent_id = luabind::object_cast<u16>(table["parent_id"]);
+		}
+		*/
+	}
+
 	return (true);
 }
 
@@ -1108,16 +1205,62 @@ void CBulletManager::CommitEvents() // @ the start of frame
 	for (u32 _it = 0; _it < m_Events.size(); _it++)
 	{
 		_event& E = m_Events[_it];
+		SBullet* bullet = &E.bullet;
+		Fvector& end_point = E.point;
+		SGameMtl* mt = GMLib.GetMaterialByIdx(E.tgt_material);
 		switch (E.Type)
 		{
 		case EVENT_HIT:
 			{
+				// demonized: bullet on impact callback
+				luabind::functor<void> funct;
+				if (ai().script_engine().functor("_G.CBulletOnImpact", funct)) {
+					luabind::object table = luabind::newtable(ai().script_engine().lua());
+					populateBulletTable(
+						table,
+						!fis_zero(end_point.x) && !fis_zero(end_point.y) && !fis_zero(end_point.z) ? end_point : bullet->bullet_pos,
+						bullet->dir,
+						bullet->speed,
+						bullet->fly_dist + E.R.range,
+						bullet->catridgeSection,
+						bullet->bulletId,
+						bullet->weapon_id,
+						bullet->parent_id,
+						E.dynamic && E.R.O ? E.R.O->ID() : 65535,
+						mt ? mt->m_Name.c_str() : NULL,
+						bullet->life_time
+					);
+					funct(table);
+				}
+
 				if (E.dynamic) DynamicObjectHit(E);
 				else StaticObjectHit(E);
 			}
+
 			break;
 		case EVENT_REMOVE:
 			{
+				// demonized: bullet on remove callback
+				luabind::functor<void> funct;
+				if (ai().script_engine().functor("_G.CBulletOnRemove", funct)) {
+					luabind::object table = luabind::newtable(ai().script_engine().lua());
+					populateBulletTable(
+						table,
+						!fis_zero(end_point.x) && !fis_zero(end_point.y) && !fis_zero(end_point.z) ? end_point : bullet->bullet_pos,
+						bullet->dir,
+						bullet->speed,
+						bullet->fly_dist,
+						bullet->catridgeSection,
+						bullet->bulletId,
+						bullet->weapon_id,
+						bullet->parent_id,
+						65535,
+						NULL,
+						bullet->life_time
+					);
+					funct(table);
+				}
+
 				if (E.bullet.flags.allow_sendhit && GameID() != eGameIDSingle)
 					Game().m_WeaponUsageStatistic->OnBullet_Remove(&E.bullet);
 				m_Bullets[E.tgt_material] = m_Bullets.back();
diff --git a/src/xrGame/Level_Bullet_Manager.h b/src/xrGame/Level_Bullet_Manager.h
index 80938ef..5fb4aab 100644
--- a/src/xrGame/Level_Bullet_Manager.h
+++ b/src/xrGame/Level_Bullet_Manager.h
@@ -45,6 +45,9 @@ struct SBullet
 
 	u16 parent_id; //ID персонажа который иницировал действие
 	u16 weapon_id; //ID оружия из которого была выпущены пуля
+	LPCSTR catridgeSection;
+	static u32 bulletCount;
+	u32 bulletId;
 
 	float fly_dist; //дистанция которую пуля пролетела
 	Fvector tracer_start_position;
diff --git a/src/xrGame/Level_input.cpp b/src/xrGame/Level_input.cpp
index 3d06b55..a410863 100644
--- a/src/xrGame/Level_input.cpp
+++ b/src/xrGame/Level_input.cpp
@@ -56,7 +56,18 @@ void CLevel::IR_OnMouseWheel(int direction)
 
 	/* avo: script callback */
 #ifdef MOUSE_INPUT_CALLBACKS
-    if (g_actor) g_actor->callback(GameObject::eMouseWheel)(direction);
+    if (g_actor) {
+        // demonized: add mouse wheel callback with consuming input
+        luabind::functor<bool> funct;
+        if (ai().script_engine().functor("_G.COnMouseWheel", funct))
+        {
+            if (!funct(direction))
+            {
+                return;
+            }
+        }
+        //g_actor->callback(GameObject::eMouseWheel)(direction);
+    }
 #endif
 	/* avo: end */
 
diff --git a/src/xrGame/NewZoomFlag.h b/src/xrGame/NewZoomFlag.h
new file mode 100644
index 0000000..ec29839
--- /dev/null
+++ b/src/xrGame/NewZoomFlag.h
@@ -0,0 +1,13 @@
+#pragma once
+//New_zoom
+enum
+{
+	NEW_ZOOM = (1 << 0),
+	SDS_ZOOM = (1 << 1),
+	SDS_SPEED = (1 << 3),
+	SDS = (1 << 4),
+
+};
+
+extern Flags32 zoomFlags;
+//
\ No newline at end of file
diff --git a/src/xrGame/PHMovementControl.cpp b/src/xrGame/PHMovementControl.cpp
index 7836b3c..b8be9d8 100644
--- a/src/xrGame/PHMovementControl.cpp
+++ b/src/xrGame/PHMovementControl.cpp
@@ -1125,6 +1125,11 @@ void CPHMovementControl::PHReleaseObject()
 void CPHMovementControl::DestroyCharacter()
 {
 	VERIFY(m_character);
+
+	// Remove Grass bender if PHCharacter is not NULL
+	if (m_character->PhysicsRefObject() != NULL)
+		g_pGamePersistent->GrassBendersRemoveById(m_character->PhysicsRefObject()->ObjectID());
+
 	m_character->Destroy();
 	phcapture_destroy(m_capture);
 	//xr_delete(m_capture);
diff --git a/src/xrGame/ScriptXMLInit.cpp b/src/xrGame/ScriptXMLInit.cpp
index 3c89e6d..6e490ca 100644
--- a/src/xrGame/ScriptXMLInit.cpp
+++ b/src/xrGame/ScriptXMLInit.cpp
@@ -37,6 +37,29 @@ void _attach_child(CUIWindow* _child, CUIWindow* _parent)
 		_parent->AttachChild(_child);
 }
 
+// demonized
+// Clear XML from BOM
+LPCSTR clearBOM(LPCSTR s) {
+	if (s[0] == (char)0xEF && s[1] == (char)0xBB && s[2] == (char)0xBF) {
+		LPCSTR new_s = s + 3;
+		return new_s;
+	}
+	return s;
+}
+
+// demonized
+// Send XML file contents to Lua for edit
+void XMLLuaCallback(CXml &m_xml, LPCSTR xml_string) {
+	xml_string = clearBOM(xml_string);
+	luabind::functor<LPCSTR> funct;
+	if (ai().script_engine().functor("_G.COnXmlRead", funct))
+	{
+		LPCSTR res = funct(m_xml.m_xml_file_name, xml_string);
+		//Msg("XMLLuaCallback, xml %s, contents %s", m_xml.m_xml_file_name, res);
+		m_xml.LoadFromString(res);
+	}
+}
+
 void CScriptXmlInit::ParseFile(LPCSTR xml_file)
 {
 	m_xml.Load(CONFIG_PATH, UI_PATH, xml_file);
diff --git a/src/xrGame/UIDosimeter.cpp b/src/xrGame/UIDosimeter.cpp
index 4bc899a..9088514 100644
--- a/src/xrGame/UIDosimeter.cpp
+++ b/src/xrGame/UIDosimeter.cpp
@@ -105,19 +105,9 @@ void CUIDosimeter::Draw()
 {
 	Fmatrix LM;
 	GetUILocatorMatrix(LM);
-
-	IUIRender::ePointType bk = UI().m_currentPointType;
-
-	UI().m_currentPointType = IUIRender::pttLIT;
-
 	UIRender->CacheSetXformWorld(LM);
-	UIRender->CacheSetCullMode(IUIRender::cmNONE);
-
-	UI().ScreenFrustumLIT().Clear();
-
 	CUIWindow::Draw();
-
-	UI().m_currentPointType = bk;
+	UI().ScreenFrustumLIT().Clear();
 }
 
 void CUIDosimeter::GetUILocatorMatrix(Fmatrix& _m)
diff --git a/src/xrGame/Weapon.cpp b/src/xrGame/Weapon.cpp
index 080f84d..29a56ee 100644
--- a/src/xrGame/Weapon.cpp
+++ b/src/xrGame/Weapon.cpp
@@ -42,6 +42,47 @@
 float f_weapon_deterioration = 1.0f;
 extern CUIXml* pWpnScopeXml;
 
+//////////
+extern float scope_radius;
+
+Flags32 zoomFlags = {};
+extern float n_zoom_step_count;
+float sens_multiple = 1.0f;
+
+
+float CWeapon::SDS_Radius(bool alt) {
+	shared_str scope_tex_name;
+	if (m_zoomtype == 0 && zoomFlags.test(SDS))
+	{
+		if (0 != (m_flagsAddOnState & CSE_ALifeItemWeapon::eWeaponAddonScope) && m_scopes.size())
+		{
+			scope_tex_name = pSettings->r_string(GetScopeName(), alt ? "scope_texture_alt" : "scope_texture");
+		}
+		else
+		{
+			scope_tex_name = READ_IF_EXISTS(pSettings, r_string, cNameSect(), alt ? "scope_texture_alt" : "scope_texture", NULL);
+		}
+
+		if (scope_tex_name != 0) {
+			auto item = listScopeRadii.find(scope_tex_name);
+			if (item != listScopeRadii.end()) {
+				return item->second;
+			}
+			else {
+				return 0.0;
+			}
+		}
+		else {
+			return 0.0;
+		}
+	}
+	else {
+		return 0.0;
+	}
+}
+
+//////////
+
 CWeapon::CWeapon()
 {
 	SetState(eHidden);
@@ -101,8 +142,13 @@ CWeapon::CWeapon()
 
 	//PP.RQ.range = 0.f;
 	//PP.RQ.set(NULL, 0.f, -1);
+
+	bHasBulletsToHide = false;
+	bullet_cnt = 0;
+	IsCustomReloadAvaible = false;
 }
 
+extern int scope_2dtexactive; //crookr
 CWeapon::~CWeapon()
 {
 	xr_delete(m_UIScope);
@@ -218,8 +264,32 @@ void CWeapon::UpdateFireDependencies_internal()
 	}
 }
 
-void CWeapon::UpdateUIScope()
-{
+void updateCurrentScope() {
+	if (!g_pGameLevel) return;
+
+	CInventoryOwner* pGameObject = smart_cast<CInventoryOwner*>(Level().Objects.net_Find(0));
+	if (pGameObject) {
+		if (pGameObject->inventory().ActiveItem()) {
+			CWeapon* weapon = smart_cast<CWeapon*>(pGameObject->inventory().ActiveItem());
+			if (weapon) {
+				weapon->UpdateZoomParams();
+			}
+		}
+	}
+}
+
+void CWeapon::UpdateZoomParams() {
+	//////////
+	m_zoom_params.m_fMinBaseZoomFactor = READ_IF_EXISTS(pSettings, r_float, cNameSect(), "min_scope_zoom_factor", 200.0f);
+
+
+	float zoom_multiple = 1.0f;
+	if (zoomFlags.test(SDS_ZOOM) && (SDS_Radius() > 0.0)) {
+		zoom_multiple = scope_scrollpower;
+	}
+
+	//////////
+
 	// Load scopes.xml if it's not loaded
 	if (pWpnScopeXml == nullptr)
 	{
@@ -230,30 +300,47 @@ void CWeapon::UpdateUIScope()
 	// update zoom factor
 	if (m_zoomtype == 2) //GL
 	{
+		m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_GL || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom_gl", false);
 		m_zoom_params.m_fScopeZoomFactor = g_player_hud->m_adjust_mode ? g_player_hud->m_adjust_zoom_factor[1] : READ_IF_EXISTS(pSettings, r_float, cNameSect(), "gl_zoom_factor", 0);
-	}
-	else if (m_zoomtype == 1) //Alt
+	} else if (m_zoomtype == 1) //Alt
 	{
-		m_zoom_params.m_fScopeZoomFactor = g_player_hud->m_adjust_mode ? g_player_hud->m_adjust_zoom_factor[2] : READ_IF_EXISTS(pSettings, r_float, cNameSect(), "scope_zoom_factor_alt", 0);
-	}
-	else //Main Sight
+		m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Alt || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom_alt", false);
+		m_zoom_params.m_fScopeZoomFactor = (g_player_hud->m_adjust_mode ? g_player_hud->m_adjust_zoom_factor[2] : READ_IF_EXISTS(pSettings, r_float, cNameSect(), "scope_zoom_factor_alt", 0)) / (READ_IF_EXISTS(pSettings, r_string, cNameSect(), "scope_texture_alt", NULL) && zoomFlags.test(SDS_ZOOM) && (SDS_Radius(true) > 0.0) ? zoom_multiple : 1);
+	} else //Main Sight
 	{
+		m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Primary || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom", false);
 		if (g_player_hud->m_adjust_mode)
 		{
-			m_zoom_params.m_fScopeZoomFactor = g_player_hud->m_adjust_zoom_factor[0];
-		}
-		else if (ALife::eAddonPermanent != m_eScopeStatus && 0 != (m_flagsAddOnState & CSE_ALifeItemWeapon::eWeaponAddonScope) && m_scopes.size())
+			m_zoom_params.m_fScopeZoomFactor = g_player_hud->m_adjust_zoom_factor[0] / zoom_multiple;
+		} else if (ALife::eAddonPermanent != m_eScopeStatus && 0 != (m_flagsAddOnState & CSE_ALifeItemWeapon::eWeaponAddonScope) && m_scopes.size())
 		{
-			m_zoom_params.m_fScopeZoomFactor = pSettings->r_float(GetScopeName(), "scope_zoom_factor");
-		}
-		else
+			m_zoom_params.m_fScopeZoomFactor = pSettings->r_float(GetScopeName(), "scope_zoom_factor") / zoom_multiple;
+		} else
 		{
-			m_zoom_params.m_fScopeZoomFactor = m_zoom_params.m_fBaseZoomFactor;
+			m_zoom_params.m_fScopeZoomFactor = m_zoom_params.m_fBaseZoomFactor / zoom_multiple;
+		}
+	}
+
+	if (IsZoomed()) {
+		scope_radius = SDS_Radius();
+		if (m_zoomtype == 0 && zoomFlags.test(SDS_SPEED) && (scope_radius > 0.0)) {
+			sens_multiple = scope_scrollpower;
+		} else {
+			sens_multiple = 1.0f;
+		}
+
+
+		if (m_zoom_params.m_bUseDynamicZoom) {
+			SetZoomFactor(m_fRTZoomFactor / zoom_multiple);
+		} else {
+			SetZoomFactor(m_zoom_params.m_fScopeZoomFactor);
 		}
 	}
+}
 
-	if (IsZoomed())
-		m_zoom_params.m_fCurrentZoomFactor = m_zoom_params.m_fScopeZoomFactor;
+void CWeapon::UpdateUIScope()
+{
+	UpdateZoomParams();
 
 	// Change or remove scope texture
 	shared_str scope_tex_name;
@@ -276,6 +363,7 @@ void CWeapon::UpdateUIScope()
 	if (!g_dedicated_server)
 	{
 		xr_delete(m_UIScope);
+		scope_2dtexactive = 0; //crookr
 
 		if (!scope_tex_name || scope_tex_name.equal("none") || g_player_hud->m_adjust_mode)
 			return;
@@ -290,6 +378,7 @@ void CWeapon::SwitchZoomType()
 	if (m_zoomtype == 0 && (m_altAimPos || g_player_hud->m_adjust_mode))
 	{
 		m_zoomtype = 1;
+        m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Alt || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom_alt", false);
 	}
 	else if (IsGrenadeLauncherAttached())
 	{
@@ -299,6 +388,7 @@ void CWeapon::SwitchZoomType()
 	else if (m_zoomtype != 0)
 	{
 		m_zoomtype = 0;
+        m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Primary || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom", false);
 	}
 
 	UpdateUIScope();
@@ -641,6 +731,19 @@ void CWeapon::Load(LPCSTR section)
 	m_shoot_shake_mat.identity();
 }
 
+// demonized: World model on stalkers adjustments
+void CWeapon::set_mFirePoint(Fvector &fire_point) {
+	vLoadedFirePoint = fire_point;
+}
+
+void CWeapon::set_mFirePoint2(Fvector &fire_point) {
+	vLoadedFirePoint2 = fire_point;
+}
+
+void CWeapon::set_mShellPoint(Fvector &fire_point) {
+	vLoadedShellPoint = fire_point;
+}
+
 void CWeapon::LoadFireParams(LPCSTR section)
 {
 	cam_recoil.Dispersion = deg2rad(pSettings->r_float(section, "cam_dispersion"));
@@ -1150,11 +1253,22 @@ bool CWeapon::Action(u16 cmd, u32 flags)
 						{
 							if (pActor && pActor->is_safemode())
 								pActor->set_safemode(false);
+
+							if (GetState() != eAimStart && HudAnimationExist("anm_idle_aim_start"))
+								SwitchState(eAimStart);
+							else if (GetState() != eIdle)
+								SwitchState(eIdle);
+
 							OnZoomIn();
 						}
 					}
 					else
+					{
+						if (GetState() != eAimEnd && HudAnimationExist("anm_idle_aim_end"))
+							SwitchState(eAimEnd);
+
 						OnZoomOut();
+					}
 				}
 			}
 			else
@@ -1165,11 +1279,21 @@ bool CWeapon::Action(u16 cmd, u32 flags)
 					{
 						if (pActor && pActor->is_safemode())
 							pActor->set_safemode(false);
+
+						if (GetState() != eAimStart && HudAnimationExist("anm_idle_aim_start"))
+							SwitchState(eAimStart);
+						else if (GetState() != eIdle)
+							SwitchState(eIdle);
+
 						OnZoomIn();
 					}
 				}
 				else if (IsZoomed())
+				{
+					if (GetState() != eAimEnd && HudAnimationExist("anm_idle_aim_end"))
+						SwitchState(eAimEnd);
 					OnZoomOut();
+				}
 			}
 			return true;
 		}
@@ -1430,6 +1554,30 @@ void CWeapon::Reload()
 	OnZoomOut();
 }
 
+void CWeapon::HUD_VisualBulletUpdate(bool force, int force_idx)
+{
+	if (!bHasBulletsToHide)
+		return;
+
+	if (!GetHUDmode())	return;
+
+	bool hide = true;
+
+	//Msg("Print %d bullets", last_hide_bullet);
+
+	if (last_hide_bullet == bullet_cnt || force) hide = false;
+
+	for (u8 b = 0; b < bullet_cnt; b++)
+	{
+		u16 bone_id = HudItemData()->m_model->LL_BoneID(bullets_bones[b]);
+
+		if (bone_id != BI_NONE)
+			HudItemData()->set_bone_visible(bullets_bones[b], !hide);
+
+		if (b == last_hide_bullet) hide = false;
+	}
+}
+
 bool CWeapon::IsGrenadeLauncherAttached() const
 {
 	return (ALife::eAddonAttachable == m_eGrenadeLauncherStatus &&
@@ -1616,11 +1764,22 @@ float CWeapon::CurrentZoomFactor()
 
 void CWeapon::OnZoomIn()
 {
+    //////////
+    scope_radius = SDS_Radius();
+
+	if ((scope_radius > 0.0) && zoomFlags.test(SDS_SPEED)) {
+		sens_multiple = scope_scrollpower;
+	}
+	else {
+		sens_multiple = 1.0f;
+	}
+    //////////
+    
 	m_zoom_params.m_bIsZoomModeNow = true;
 	if (m_zoom_params.m_bUseDynamicZoom)
-		SetZoomFactor(m_fRTZoomFactor);
+		SetZoomFactor(scope_radius > 0.0 ? m_fRTZoomFactor / scope_scrollpower : m_fRTZoomFactor);
 	else
-		m_zoom_params.m_fCurrentZoomFactor = CurrentZoomFactor();
+		SetZoomFactor(CurrentZoomFactor());
 
 	if (m_zoom_params.m_bZoomDofEnabled && !IsScopeAttached())
 		GamePersistent().SetEffectorDOF(m_zoom_params.m_ZoomDof);
@@ -1650,7 +1809,11 @@ void CWeapon::OnZoomIn()
 void CWeapon::OnZoomOut()
 {
 	m_zoom_params.m_bIsZoomModeNow = false;
-	m_fRTZoomFactor = GetZoomFactor(); //store current
+    if (m_zoom_params.m_bUseDynamicZoom)
+    {
+        m_fRTZoomFactor = scope_radius > 0.0 ? GetZoomFactor() * scope_scrollpower : GetZoomFactor(); //store current
+    }
+    
 	m_zoom_params.m_fCurrentZoomFactor = g_fov;
 
 	GamePersistent().RestoreEffectorDOF();
@@ -1668,6 +1831,11 @@ void CWeapon::OnZoomOut()
 	}
 
 	g_player_hud->updateMovementLayerState();
+    
+    scope_radius = 0.0;
+    scope_2dtexactive = 0;
+    sens_multiple = 1.0f;
+
 }
 
 CUIWindow* CWeapon::ZoomTexture()
@@ -1675,7 +1843,10 @@ CUIWindow* CWeapon::ZoomTexture()
 	if (UseScopeTexture())
 		return m_UIScope;
 	else
+	{
+		scope_2dtexactive = 0; //crookr
 		return NULL;
+	}
 }
 
 void CWeapon::SwitchState(u32 S)
@@ -1775,6 +1946,21 @@ void CWeapon::reload(LPCSTR section)
 	m_ef_weapon_type = READ_IF_EXISTS(pSettings, r_u32, section, "ef_weapon_type", u32(-1));
 }
 
+// demonized: World model on stalkers adjustments
+void CWeapon::set_mOffset(Fvector position, Fvector orientation) {
+	orientation.mul(PI / 180.f);
+
+	m_Offset.setHPB(orientation.x, orientation.y, orientation.z);
+	m_Offset.translate_over(position);
+}
+
+void CWeapon::set_mStrapOffset(Fvector position, Fvector orientation) {
+	orientation.mul(PI / 180.f);
+
+	m_StrapOffset.setHPB(orientation.x, orientation.y, orientation.z);
+	m_StrapOffset.translate_over(position);
+}
+
 void CWeapon::create_physic_shell()
 {
 	CPhysicsShellHolder::create_physic_shell();
@@ -2516,6 +2702,9 @@ void CWeapon::render_item_ui()
 
 	ZoomTexture()->Update();
 	ZoomTexture()->Draw();
+
+	//crookr
+	scope_2dtexactive = ZoomTexture()->IsShown() ? 1 : 0;
 }
 
 bool CWeapon::unlimited_ammo()
@@ -2697,16 +2886,46 @@ bool CWeapon::IsHudModeNow()
 	return (HudItemData() != NULL);
 }
 
+void NewGetZoomData(const float scope_factor, float& delta, float& min_zoom_factor, float zoom, float min_zoom)
+{
+	
+	float def_fov = float(g_fov);
+	float min_zoom_k = 0.3f;
+	float delta_factor_total = def_fov - scope_factor;
+	VERIFY(delta_factor_total > 0);
+	float loc_min_zoom_factor = ((atan(tan(def_fov * (0.5 * PI / 180)) / g_ironsights_factor) / (0.5 * PI / 180)) / 0.75f) * (scope_radius > 0.0 ? scope_scrollpower : 1);
+
+	//Msg("min zoom factor %f, min zoom %f, loc min zoom factor %f", min_zoom_factor, min_zoom, loc_min_zoom_factor);
+
+	if (min_zoom < loc_min_zoom_factor) {
+		min_zoom_factor = min_zoom;
+	}
+	else {
+		min_zoom_factor = loc_min_zoom_factor;
+	}
+
+	delta = ((delta_factor_total * (1 - min_zoom_k)) / n_zoom_step_count) * (zoom / def_fov);
+}
+
 void CWeapon::ZoomInc()
 {
 	if (!IsScopeAttached()) return;
 	if (!m_zoom_params.m_bUseDynamicZoom) return;
 	float delta, min_zoom_factor;
-	GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
-
-	float f = GetZoomFactor() - delta;
-	clamp(f, m_zoom_params.m_fScopeZoomFactor, min_zoom_factor);
-	SetZoomFactor(f);
+	float power = scope_radius > 0.0 ? scope_scrollpower : 1;
+	//
+	if (zoomFlags.test(NEW_ZOOM)) {
+		NewGetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor, GetZoomFactor() * power, m_zoom_params.m_fMinBaseZoomFactor);
+	}
+	else {
+        GetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor);
+	}
+	//
+	float f = GetZoomFactor() * power - delta;
+	clamp(f, m_zoom_params.m_fScopeZoomFactor * power, min_zoom_factor);
+	SetZoomFactor(f / power);
+	//
+	m_fRTZoomFactor = GetZoomFactor() * power;
 }
 
 void CWeapon::ZoomDec()
@@ -2714,11 +2933,20 @@ void CWeapon::ZoomDec()
 	if (!IsScopeAttached()) return;
 	if (!m_zoom_params.m_bUseDynamicZoom) return;
 	float delta, min_zoom_factor;
-	GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
-
-	float f = GetZoomFactor() + delta;
-	clamp(f, m_zoom_params.m_fScopeZoomFactor, min_zoom_factor);
-	SetZoomFactor(f);
+	float power = scope_radius > 0.0 ? scope_scrollpower : 1;
+	//
+	if (zoomFlags.test(NEW_ZOOM)) {
+		NewGetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor, GetZoomFactor() * power, m_zoom_params.m_fMinBaseZoomFactor);
+	}
+	else {
+        GetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor);
+	}
+	//
+	float f = GetZoomFactor() * power + delta;
+	clamp(f, m_zoom_params.m_fScopeZoomFactor * power, min_zoom_factor);
+	SetZoomFactor(f / power);
+	//
+	m_fRTZoomFactor = GetZoomFactor() * power;
 }
 
 u32 CWeapon::Cost() const
diff --git a/src/xrGame/Weapon.h b/src/xrGame/Weapon.h
index 9880065..ac0acc3 100644
--- a/src/xrGame/Weapon.h
+++ b/src/xrGame/Weapon.h
@@ -14,6 +14,8 @@
 
 #include "CameraRecoil.h"
 
+#include "NewZoomFlag.h"
+
 class CEntity;
 class ENGINE_API CMotionDef;
 class CSE_ALifeItemWeapon;
@@ -26,6 +28,11 @@ class CNightVisionEffector;
 
 extern float f_weapon_deterioration;
 
+extern std::map<shared_str, float> listScopeRadii;
+
+extern float scope_scrollpower;
+extern float sens_multiple;
+
 struct PickParam
 {
 	collide::rq_result RQ;
@@ -81,6 +88,16 @@ public:
 	IC float GetSecondVPZoomFactor() const { return m_zoom_params.m_fSecondVPFovFactor; }
 	IC float IsSecondVPZoomPresent() const { return GetSecondVPZoomFactor() > 0.005f; }
 
+
+	// Up
+	// Magazine system & etc
+	xr_vector<shared_str> bullets_bones;
+	int bullet_cnt;
+	int last_hide_bullet;
+	bool bHasBulletsToHide;
+
+	virtual void HUD_VisualBulletUpdate(bool force = false, int force_idx = -1);
+
 	void UpdateSecondVP();
 
 	virtual void UpdateCL();
@@ -103,6 +120,14 @@ public:
 
 	virtual void reinit();
 	virtual void reload(LPCSTR section);
+
+	// demonized: World model on stalkers adjustments
+	void set_mOffset(Fvector position, Fvector orientation);
+	void set_mStrapOffset(Fvector position, Fvector orientation);
+	void set_mFirePoint(Fvector &fire_point);
+	void set_mFirePoint2(Fvector &fire_point);
+	void set_mShellPoint(Fvector &fire_point);
+
 	virtual void create_physic_shell();
 	virtual void activate_physic_shell();
 	virtual void setup_physic_shell();
@@ -142,6 +167,8 @@ public:
 		eMisfire,
 		eSwitch,
 		eSwitchMode,
+		eAimStart,
+		eAimEnd,
 	};
 
 	enum EWeaponSubStates
@@ -149,6 +176,7 @@ public:
 		eSubstateReloadBegin = 0,
 		eSubstateReloadInProcess,
 		eSubstateReloadEnd,
+		eSubstateReloadInProcessEmptyEnd,
 	};
 
 	enum
@@ -195,6 +223,8 @@ protected:
 public:
 	u8 m_sub_state;
 
+	bool IsCustomReloadAvaible;
+
 	bool IsGrenadeLauncherAttached() const;
 	bool IsScopeAttached() const;
 	bool IsSilencerAttached() const;
@@ -317,6 +347,7 @@ protected:
 
 	struct SZoomParams
 	{
+        float m_fMinBaseZoomFactor;
 		bool m_bZoomEnabled;
 		bool m_bHideCrosshairInZoom;
 		bool m_bZoomDofEnabled;
@@ -331,6 +362,9 @@ protected:
 		Fvector4 m_ReloadDof;
 		Fvector4 m_ReloadEmptyDof; //Swartz: reload when empty mag. DOF
 		BOOL m_bUseDynamicZoom;
+		BOOL m_bUseDynamicZoom_Primary;
+		BOOL m_bUseDynamicZoom_Alt;
+		BOOL m_bUseDynamicZoom_GL;
 		shared_str m_sUseZoomPostprocess;
 		shared_str m_sUseBinocularVision;
 		CBinocularsVision* m_pVision;
@@ -386,7 +420,16 @@ public:
 	LPCSTR GetScopeNameScript() const { return *GetScopeName(); }
 	float GetFireDispersionScript() const { return fireDispersionBase; }
 	float RPMScript() const { return fOneShotTime; }
+	float RealRPMScript() const { return 60.0f / fOneShotTime; } // Return actual RPM like in configs
 	float ModeRPMScript() const { return fModeShotTime; }
+	float ModeRealRPMScript() const { return 60.0f / fModeShotTime; }
+
+	//Setters
+	void SetFireDispersionScript(float val) { fireDispersionBase = val; }
+	void SetRPM(float newOneShotTime) { fOneShotTime = newOneShotTime; } // Input - time between shots like received from getter
+	void SetRealRPM(float rpm) { fOneShotTime = 60.0f / rpm; } // Input - actual RPM like in configs
+	void SetModeRPM(float newOneShotTime) { fModeShotTime = newOneShotTime; } // Input - time between shots like received from getter
+	void SetModeRealRPM(float rpm) { fModeShotTime = 60.0f / rpm; } // Input - actual RPM like in configs
 
 	virtual float Weight() const;
 	virtual u32 Cost() const;
@@ -452,6 +495,7 @@ public:
 	//virtual collide::rq_result& GetRQ() { return PP.RQ; }
 	//virtual void net_Relcase(CObject* object);
 	Fmatrix m_shoot_shake_mat;
+	void UpdateZoomParams();
 
 protected:
 	virtual void UpdateFireDependencies_internal();
@@ -563,6 +607,42 @@ public:
 	CameraRecoil cam_recoil; // simple mode (walk, run)
 	CameraRecoil zoom_cam_recoil; // using zoom =(ironsight or scope)
 
+	// Getters
+	float GetCamRelaxSpeed() { return cam_recoil.RelaxSpeed; };
+	float GetCamRelaxSpeed_AI() { return cam_recoil.RelaxSpeed_AI; };
+	float GetCamDispersion() { return cam_recoil.Dispersion; };
+	float GetCamDispersionInc() { return cam_recoil.DispersionInc; };
+	float GetCamDispersionFrac() { return cam_recoil.DispersionFrac; };
+	float GetCamMaxAngleVert() { return cam_recoil.MaxAngleVert; };
+	float GetCamMaxAngleHorz() { return cam_recoil.MaxAngleHorz; };
+	float GetCamStepAngleHorz() { return cam_recoil.StepAngleHorz; };
+	float GetZoomCamRelaxSpeed() { return zoom_cam_recoil.RelaxSpeed; };
+	float GetZoomCamRelaxSpeed_AI() { return zoom_cam_recoil.RelaxSpeed_AI; };
+	float GetZoomCamDispersion() { return zoom_cam_recoil.Dispersion; };
+	float GetZoomCamDispersionInc() { return zoom_cam_recoil.DispersionInc; };
+	float GetZoomCamDispersionFrac() { return zoom_cam_recoil.DispersionFrac; };
+	float GetZoomCamMaxAngleVert() { return zoom_cam_recoil.MaxAngleVert; };
+	float GetZoomCamMaxAngleHorz() { return zoom_cam_recoil.MaxAngleHorz; };
+	float GetZoomCamStepAngleHorz() { return zoom_cam_recoil.StepAngleHorz; };
+
+	// Setters
+	void SetCamRelaxSpeed(float val) { cam_recoil.RelaxSpeed = val; };
+	void SetCamRelaxSpeed_AI(float val) { cam_recoil.RelaxSpeed_AI = val; };
+	void SetCamDispersion(float val) { cam_recoil.Dispersion = val; };
+	void SetCamDispersionInc(float val) { cam_recoil.DispersionInc = val; };
+	void SetCamDispersionFrac(float val) { cam_recoil.DispersionFrac = val; };
+	void SetCamMaxAngleVert(float val) { cam_recoil.MaxAngleVert = val; };
+	void SetCamMaxAngleHorz(float val) { cam_recoil.MaxAngleHorz = val; };
+	void SetCamStepAngleHorz(float val) { cam_recoil.StepAngleHorz = val; };
+	void SetZoomCamRelaxSpeed(float val) { zoom_cam_recoil.RelaxSpeed = val; };
+	void SetZoomCamRelaxSpeed_AI(float val) { zoom_cam_recoil.RelaxSpeed_AI = val; };
+	void SetZoomCamDispersion(float val) { zoom_cam_recoil.Dispersion = val; };
+	void SetZoomCamDispersionInc(float val) { zoom_cam_recoil.DispersionInc = val; };
+	void SetZoomCamDispersionFrac(float val) { zoom_cam_recoil.DispersionFrac = val; };
+	void SetZoomCamMaxAngleVert(float val) { zoom_cam_recoil.MaxAngleVert = val; };
+	void SetZoomCamMaxAngleHorz(float val) { zoom_cam_recoil.MaxAngleHorz = val; };
+	void SetZoomCamStepAngleHorz(float val) { zoom_cam_recoil.StepAngleHorz = val; };
+
 protected:
 	//ГґГ ГЄГІГ®Г° ГіГўГҐГ«ГЁГ·ГҐГ­ГЁГї Г¤ГЁГ±ГЇГҐГ°Г±ГЁГЁ ГЇГ°ГЁ Г¬Г ГЄГ±ГЁГ¬Г Г«ГјГ­Г®Г© ГЁГ§Г­Г®ГёГҐГ­Г®Г±ГІГЁ
 	//(Г­Г  Г±ГЄГ®Г«ГјГЄГ® ГЇГ°Г®Г¶ГҐГ­ГІГ®Гў ГіГўГҐГ«ГЁГ·ГЁГІГ±Гї Г¤ГЁГ±ГЇГҐГ°Г±ГЁГї)
@@ -590,6 +670,17 @@ public:
 		return misfireEndCondition;
 	};
 
+	// Setters
+	void SetMisfireStartCondition(float val)
+	{
+		misfireStartCondition = val;
+	};
+
+	void SetMisfireEndCondition(float val)
+	{
+		misfireEndCondition = val;
+	};
+
 protected:
 	struct SPDM
 	{
@@ -750,6 +841,107 @@ public:
 	{
 		return m_first_bullet_controller.get_fire_dispertion();
 	};
+
+	// Setters
+	virtual void Set_PDM_Base(float val) 
+	{
+		m_pdm.m_fPDM_disp_base = val;
+	};
+
+	virtual void Set_Silencer_PDM_Base(float val) 
+	{
+		cur_silencer_koef.pdm_base = val;
+	};
+
+	virtual void Set_Scope_PDM_Base(float val) 
+	{
+		cur_scope_koef.pdm_base = val;
+	};
+
+	virtual void Set_Launcher_PDM_Base(float val) 
+	{
+		cur_launcher_koef.pdm_base = val;
+	};
+
+	virtual void Set_PDM_BuckShot(float val) 
+	{
+		m_pdm.m_fPDM_disp_buckShot = val;
+	};
+
+	virtual void Set_PDM_Vel_F(float val) 
+	{
+		m_pdm.m_fPDM_disp_vel_factor = val;
+	};
+
+	virtual void Set_Silencer_PDM_Vel(float val) 
+	{
+		cur_silencer_koef.pdm_vel = val;
+	};
+
+	virtual void Set_Scope_PDM_Vel(float val) 
+	{
+		cur_scope_koef.pdm_vel = val;
+	};
+
+	virtual void Set_Launcher_PDM_Vel(float val) 
+	{
+		cur_launcher_koef.pdm_vel = val;
+	};
+
+	virtual void Set_PDM_Accel_F(float val) 
+	{
+		m_pdm.m_fPDM_disp_accel_factor = val;
+	};
+
+	virtual void Set_Silencer_PDM_Accel(float val) 
+	{
+		cur_silencer_koef.pdm_accel = val;
+	};
+
+	virtual void Set_Scope_PDM_Accel(float val) 
+	{
+		cur_scope_koef.pdm_accel = val;
+	};
+
+	virtual void Set_Launcher_PDM_Accel(float val) 
+	{
+		cur_launcher_koef.pdm_accel = val;
+	};
+
+	virtual void Set_PDM_Crouch(float val) 
+	{
+		m_pdm.m_fPDM_disp_crouch = val;
+	};
+
+	virtual void Set_PDM_Crouch_NA(float val) 
+	{
+		m_pdm.m_fPDM_disp_crouch_no_acc = val;
+	};
+
+	virtual void SetCrosshairInertion(float val) 
+	{
+		m_crosshair_inertion = val;
+	};
+
+	virtual void Set_Silencer_CrosshairInertion(float val) 
+	{
+		cur_silencer_koef.crosshair_inertion = val;
+	};
+
+	virtual void Set_Scope_CrosshairInertion(float val) 
+	{
+		cur_scope_koef.crosshair_inertion = val;
+	};
+
+	virtual void Set_Launcher_CrosshairInertion(float val)
+	{
+		cur_launcher_koef.crosshair_inertion = val;
+	};
+
+	void SetFirstBulletDisp(float val)
+	{
+		m_first_bullet_controller.set_fire_dispertion(val);
+	};
 protected:
 	int iAmmoElapsed; // ammo in magazine, currently
 	int iMagazineSize; // size (in bullets) of magazine
@@ -795,6 +987,20 @@ public:
 	virtual float GetHitPowerCritical() { return fvHitPowerCritical[g_SingleGameDifficulty]; };
 	virtual float GetHitImpulse() { return fHitImpulse; };
 	virtual float GetFireDistance() { return fireDistance; };
+
+	// Setters
+	virtual void SetHitPower(float val) {
+		for (int i = ESingleGameDifficulty::egdNovice; i < ESingleGameDifficulty::egdCount; i++) {
+			fvHitPower[i] = val;
+		}
+	};
+	virtual void SetHitPowerCritical(float val) {
+		for (int i = ESingleGameDifficulty::egdNovice; i < ESingleGameDifficulty::egdCount; i++) {
+			fvHitPowerCritical[i] = val;
+		}
+	};
+	virtual void SetHitImpulse(float val) { fHitImpulse = val; };
+	virtual void SetFireDistance(float val) { fireDistance = val; };
 	
 	IC u8 GetZoomType() const
 	{
@@ -878,4 +1084,6 @@ public:
 	{
 		return cNameSect();
 	};
+    
+    float SDS_Radius(bool alt = false);
 };
diff --git a/src/xrGame/WeaponAK74.cpp b/src/xrGame/WeaponAK74.cpp
index 6f55903..45f79bc 100644
--- a/src/xrGame/WeaponAK74.cpp
+++ b/src/xrGame/WeaponAK74.cpp
@@ -62,7 +62,9 @@ void CWeaponAK74::script_register	(lua_State *L)
 			.def("GetAmmoType", &CWeapon::GetAmmoType)
 			.def("AmmoTypeForEach", &CWeapon::AmmoTypeForEach)
 			.def("RPM", &CWeapon::RPMScript)
+			.def("RealRPM", &CWeapon::RealRPMScript)
 			.def("ModeRPM", &CWeapon::ModeRPMScript)
+			.def("ModeRealRPM", &CWeapon::ModeRealRPMScript)
 			.def("GetZoomType", &CWeapon::GetZoomType)
 			
 			.def("Get_PDM_Base", &CWeapon::Get_PDM_Base)
@@ -93,6 +95,83 @@ void CWeaponAK74::script_register	(lua_State *L)
 			.def("GetFireMode", &CWeapon::GetCurrentFireMode)
 
 			.def("GetInertionAimFactor", &CWeapon::GetInertionAimFactor)
+
+			// Setters
+			.def("SetFireDispersion", &CWeapon::SetFireDispersionScript)
+			.def("SetMisfireStartCondition", &CWeapon::SetMisfireStartCondition)
+			.def("SetMisfireEndCondition", &CWeapon::SetMisfireEndCondition)
+			.def("SetRPM", &CWeapon::SetRPM)
+			.def("SetRealRPM", &CWeapon::SetRealRPM)
+			.def("SetModeRPM", &CWeapon::SetModeRPM)
+			.def("SetModeRealRPM", &CWeapon::SetModeRealRPM)
+			.def("Set_PDM_Base", &CWeapon::Set_PDM_Base)
+			.def("Set_Silencer_PDM_Base", &CWeapon::Set_Silencer_PDM_Base)
+			.def("Set_Scope_PDM_Base", &CWeapon::Set_Scope_PDM_Base)
+			.def("Set_Launcher_PDM_Base", &CWeapon::Set_Launcher_PDM_Base)
+			.def("Set_PDM_BuckShot", &CWeapon::Set_PDM_BuckShot)
+			.def("Set_PDM_Vel_F", &CWeapon::Set_PDM_Vel_F)
+			.def("Set_Silencer_PDM_Vel", &CWeapon::Set_Silencer_PDM_Vel)
+			.def("Set_Scope_PDM_Vel", &CWeapon::Set_Scope_PDM_Vel)
+			.def("Set_Launcher_PDM_Vel", &CWeapon::Set_Launcher_PDM_Vel)
+			.def("Set_PDM_Accel_F", &CWeapon::Set_PDM_Accel_F)
+			.def("Set_Silencer_PDM_Accel", &CWeapon::Set_Silencer_PDM_Accel)
+			.def("Set_Scope_PDM_Accel", &CWeapon::Set_Scope_PDM_Accel)
+			.def("Set_Launcher_PDM_Accel", &CWeapon::Set_Launcher_PDM_Accel)
+			.def("Set_PDM_Crouch", &CWeapon::Set_PDM_Crouch)
+			.def("Set_PDM_Crouch_NA", &CWeapon::Set_PDM_Crouch_NA)
+			.def("SetCrosshairInertion", &CWeapon::SetCrosshairInertion)
+			.def("Set_Silencer_CrosshairInertion", &CWeapon::Set_Silencer_CrosshairInertion)
+			.def("Set_Scope_CrosshairInertion", &CWeapon::Set_Scope_CrosshairInertion)
+			.def("Set_Launcher_CrosshairInertion", &CWeapon::Set_Launcher_CrosshairInertion)
+			.def("SetFirstBulletDisp", &CWeapon::SetFirstBulletDisp)
+			.def("SetHitPower", &CWeapon::SetHitPower)
+			.def("SetHitPowerCritical", &CWeapon::SetHitPowerCritical)
+			.def("SetHitImpulse", &CWeapon::SetHitImpulse)
+			.def("SetFireDistance", &CWeapon::SetFireDistance)
+
+			// demonized: World model on stalkers adjustments
+			.def("Set_mOffset", &CWeapon::set_mOffset)
+			.def("Set_mStrapOffset", &CWeapon::set_mStrapOffset)
+			.def("Set_mFirePoint", &CWeapon::set_mFirePoint)
+			.def("Set_mFirePoint2", &CWeapon::set_mFirePoint2)
+			.def("Set_mShellPoint", &CWeapon::set_mShellPoint)
+
+			// Cam Recoil
+			// Getters
+			.def("GetCamRelaxSpeed", &CWeapon::GetCamRelaxSpeed)
+			.def("GetCamRelaxSpeed_AI", &CWeapon::GetCamRelaxSpeed_AI)
+			.def("GetCamDispersion", &CWeapon::GetCamDispersion)
+			.def("GetCamDispersionInc", &CWeapon::GetCamDispersionInc)
+			.def("GetCamDispersionFrac", &CWeapon::GetCamDispersionFrac)
+			.def("GetCamMaxAngleVert", &CWeapon::GetCamMaxAngleVert)
+			.def("GetCamMaxAngleHorz", &CWeapon::GetCamMaxAngleHorz)
+			.def("GetCamStepAngleHorz", &CWeapon::GetCamStepAngleHorz)
+			.def("GetZoomCamRelaxSpeed", &CWeapon::GetZoomCamRelaxSpeed)
+			.def("GetZoomCamRelaxSpeed_AI", &CWeapon::GetZoomCamRelaxSpeed_AI)
+			.def("GetZoomCamDispersion", &CWeapon::GetZoomCamDispersion)
+			.def("GetZoomCamDispersionInc", &CWeapon::GetZoomCamDispersionInc)
+			.def("GetZoomCamDispersionFrac", &CWeapon::GetZoomCamDispersionFrac)
+			.def("GetZoomCamMaxAngleVert", &CWeapon::GetZoomCamMaxAngleVert)
+			.def("GetZoomCamMaxAngleHorz", &CWeapon::GetZoomCamMaxAngleHorz)
+			.def("GetZoomCamStepAngleHorz", &CWeapon::GetZoomCamStepAngleHorz)
+
+			// Setters
+			.def("SetCamRelaxSpeed", &CWeapon::SetCamRelaxSpeed)
+			.def("SetCamRelaxSpeed_AI", &CWeapon::SetCamRelaxSpeed_AI)
+			.def("SetCamDispersion", &CWeapon::SetCamDispersion)
+			.def("SetCamDispersionInc", &CWeapon::SetCamDispersionInc)
+			.def("SetCamDispersionFrac", &CWeapon::SetCamDispersionFrac)
+			.def("SetCamMaxAngleVert", &CWeapon::SetCamMaxAngleVert)
+			.def("SetCamMaxAngleHorz", &CWeapon::SetCamMaxAngleHorz)
+			.def("SetCamStepAngleHorz", &CWeapon::SetCamStepAngleHorz)
+			.def("SetZoomCamRelaxSpeed", &CWeapon::SetZoomCamRelaxSpeed)
+			.def("SetZoomCamRelaxSpeed_AI", &CWeapon::SetZoomCamRelaxSpeed_AI)
+			.def("SetZoomCamDispersion", &CWeapon::SetZoomCamDispersion)
+			.def("SetZoomCamDispersionInc", &CWeapon::SetZoomCamDispersionInc)
+			.def("SetZoomCamDispersionFrac", &CWeapon::SetZoomCamDispersionFrac)
+			.def("SetZoomCamMaxAngleVert", &CWeapon::SetZoomCamMaxAngleVert)
+			.def("SetZoomCamMaxAngleHorz", &CWeapon::SetZoomCamMaxAngleHorz)
+			.def("SetZoomCamStepAngleHorz", &CWeapon::SetZoomCamStepAngleHorz)
 			
 			.def("Cost", &CWeapon::Cost)
 			.def("Weight", &CWeapon::Weight)
diff --git a/src/xrGame/WeaponAutomaticShotgun.cpp b/src/xrGame/WeaponAutomaticShotgun.cpp
index 0601295..a8b0d07 100644
--- a/src/xrGame/WeaponAutomaticShotgun.cpp
+++ b/src/xrGame/WeaponAutomaticShotgun.cpp
@@ -26,6 +26,11 @@ void CWeaponAutomaticShotgun::Load(LPCSTR section)
 	{
 		m_bTriStateReload = !!pSettings->r_bool(section, "tri_state_reload");
 	};
+	if (pSettings->line_exist(section, "bas_state_reload"))
+	{
+		IsCustomReloadAvaible = !!pSettings->r_bool(section, "bas_state_reload");
+	}
+	
 	if (m_bTriStateReload)
 	{
 		m_sounds.LoadSound(section, "snd_open_weapon", "sndOpen", false, m_eSoundOpen);
@@ -35,6 +40,8 @@ void CWeaponAutomaticShotgun::Load(LPCSTR section)
 		m_sounds.LoadSound(section, "snd_close_weapon", "sndClose", false, m_eSoundClose);
 
 		m_sounds.LoadSound(section, "snd_close_weapon_empty", "sndCloseEmpty", false, m_eSoundClose);
+
+		m_sounds.LoadSound(section, "snd_shoot_last", "sndShootL", false, m_eSoundShot);
 	};
 }
 
@@ -49,10 +56,11 @@ bool CWeaponAutomaticShotgun::Action(u16 cmd, u32 flags)
 
 	if (m_bTriStateReload && GetState() == eReload &&
 		cmd == kWPN_FIRE && flags & CMD_START &&
-		m_sub_state == eSubstateReloadInProcess) //остановить перезагрузку
-	{
+		m_sub_state == eSubstateReloadInProcess || m_sub_state == eSubstateReloadInProcessEmptyEnd) //пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ
+	{	
 		AddCartridge(1);
 		m_sub_state = eSubstateReloadEnd;
+		if(IsCustomReloadAvaible) SwitchState(eReload);
 		return true;
 	}
 	return false;
@@ -78,16 +86,28 @@ void CWeaponAutomaticShotgun::OnAnimationEnd(u32 state)
 			{
 				m_sub_state = eSubstateReloadEnd;
 			}
+			else if (BeginReloadWasEmpty && IsCustomReloadAvaible)
+			{
+				m_sub_state = eSubstateReloadInProcessEmptyEnd;
+				
+			}
 			SwitchState(eReload);
 		}
 		break;
 
 	case eSubstateReloadEnd:
 		{
+			BeginReloadWasEmpty = false;
 			m_sub_state = eSubstateReloadBegin;
 			SwitchState(eIdle);
 		}
 		break;
+	case eSubstateReloadInProcessEmptyEnd:
+		{
+			m_sub_state = eSubstateReloadBegin;
+			SwitchState(eReload);
+		}
+		break;
 	};
 }
 
@@ -139,9 +159,32 @@ void CWeaponAutomaticShotgun::OnStateSwitch(u32 S, u32 oldState)
 	case eSubstateReloadEnd:
 		switch2_EndReload();
 		break;
+	case eSubstateReloadInProcessEmptyEnd:
+		switch2_EndReload();
+		break;
 	};
 }
 
+void CWeaponAutomaticShotgun::PlaySoundShot()
+{
+	// Temp fix for shotguns last shot
+	if (iAmmoElapsed > 1 || !HudAnimationExist("anm_shot_l"))
+	{
+		inherited::PlaySoundShot();
+	}
+	else
+	{
+		if (m_sounds.FindSoundItem("sndShootL", false))
+		{
+			m_sounds.PlaySound("sndShootL", get_LastFP(), H_Root(), !!GetHUDmode(), false, (u8)-1);
+		}
+		else
+		{
+			inherited::PlaySoundShot();
+		}
+	}
+}
+
 void CWeaponAutomaticShotgun::switch2_StartReload()
 {
 	BeginReloadWasEmpty = !m_magazine.size();
@@ -161,7 +204,6 @@ void CWeaponAutomaticShotgun::switch2_AddCartgidge()
 void CWeaponAutomaticShotgun::switch2_EndReload()
 {
 	SetPending(FALSE);
-
 	if (BeginReloadWasEmpty && m_sounds.FindSoundItem("sndCloseEmpty", false))
 		PlaySound("sndCloseEmpty", get_LastFP());
 	else
@@ -250,7 +292,7 @@ u8 CWeaponAutomaticShotgun::AddCartridge(u8 cnt)
 
 	VERIFY((u32)iAmmoElapsed == m_magazine.size());
 
-	//выкинуть коробку патронов, если она пустая
+	//пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ, пїЅпїЅпїЅпїЅ пїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅ
 	if (m_pCurrentAmmo && !m_pCurrentAmmo->m_boxCurr && OnServer())
 		m_pCurrentAmmo->SetDropManual(TRUE);
 
diff --git a/src/xrGame/WeaponAutomaticShotgun.h b/src/xrGame/WeaponAutomaticShotgun.h
index 6203831..ad2056d 100644
--- a/src/xrGame/WeaponAutomaticShotgun.h
+++ b/src/xrGame/WeaponAutomaticShotgun.h
@@ -31,7 +31,7 @@ protected:
 	virtual void OnAnimationEnd(u32 state);
 	void TriStateReload();
 	virtual void OnStateSwitch(u32 S, u32 oldState);
-
+	virtual void PlaySoundShot();
 	bool HaveCartridgeInInventory(u8 cnt);
 	bool BeginReloadWasEmpty;
 	virtual u8 AddCartridge(u8 cnt);
diff --git a/src/xrGame/WeaponBinoculars.cpp b/src/xrGame/WeaponBinoculars.cpp
index 21be7d1..768462e 100644
--- a/src/xrGame/WeaponBinoculars.cpp
+++ b/src/xrGame/WeaponBinoculars.cpp
@@ -9,6 +9,9 @@
 #include "object_broker.h"
 #include "inventory.h"
 
+extern float n_zoom_step_count;
+float czoom;
+
 CWeaponBinoculars::CWeaponBinoculars()
 {
 	m_binoc_vision = NULL;
@@ -56,6 +59,7 @@ void CWeaponBinoculars::OnZoomIn()
 		}
 	}
 	inherited::OnZoomIn();
+    SetZoomFactor(czoom);
 }
 
 void CWeaponBinoculars::OnZoomOut()
@@ -75,6 +79,7 @@ void CWeaponBinoculars::OnZoomOut()
 
 BOOL CWeaponBinoculars::net_Spawn(CSE_Abstract* DC)
 {
+    czoom = CWeaponBinoculars::m_zoom_params.m_fScopeZoomFactor;
 	return inherited::net_Spawn(DC);
 }
 
@@ -115,24 +120,36 @@ void GetZoomData(const float scope_factor, float& delta, float& min_zoom_factor)
 	delta = (delta_factor_total * (1 - min_zoom_k)) / zoom_step_count;
 }
 
+void newGetZoomData(const float scope_factor, float& delta, float& min_zoom_factor, float c_zoom)
+{
+    float def_fov = float(g_fov);
+    float min_zoom_k = 0.3f;
+    float delta_factor_total = def_fov - scope_factor;
+    VERIFY(delta_factor_total > 0);
+    min_zoom_factor = def_fov - delta_factor_total * min_zoom_k;
+    delta = (delta_factor_total * (1 - min_zoom_k)) / n_zoom_step_count * (c_zoom / def_fov);
+}
+
 void CWeaponBinoculars::ZoomInc()
 {
 	float delta, min_zoom_factor;
-	GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
+    newGetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor, czoom);
 
 	float f = GetZoomFactor() - delta;
 	clamp(f, m_zoom_params.m_fScopeZoomFactor, min_zoom_factor);
 	SetZoomFactor(f);
+    czoom = f;
 }
 
 void CWeaponBinoculars::ZoomDec()
 {
 	float delta, min_zoom_factor;
-	GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
+    newGetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor, czoom);
 
 	float f = GetZoomFactor() + delta;
 	clamp(f, m_zoom_params.m_fScopeZoomFactor, min_zoom_factor);
 	SetZoomFactor(f);
+    czoom = f;
 }
 
 void CWeaponBinoculars::save(NET_Packet& output_packet)
diff --git a/src/xrGame/WeaponFire.cpp b/src/xrGame/WeaponFire.cpp
index 39bbeda..60f4e8c 100644
--- a/src/xrGame/WeaponFire.cpp
+++ b/src/xrGame/WeaponFire.cpp
@@ -130,6 +130,10 @@ void CWeapon::FireTrace(const Fvector& P, const Fvector& D)
 	if (m_bLightShotEnabled)
 		Light_Start();
 
+	// Interactive Grass FX
+	extern Fvector4 ps_ssfx_int_grass_params_2;
+	Fvector ShotPos = Fvector().mad(P, D, 1.5f);
+	g_pGamePersistent->GrassBendersAddShot(cast_game_object()->ID(), ShotPos, D, 3.0f, 20.0f, ps_ssfx_int_grass_params_2.z, ps_ssfx_int_grass_params_2.w);
 
 	// Ammo
 	m_lastCartridge = l_cartridge;
diff --git a/src/xrGame/WeaponMagazineExtended.cpp b/src/xrGame/WeaponMagazineExtended.cpp
new file mode 100644
index 0000000..37fdac9
--- /dev/null
+++ b/src/xrGame/WeaponMagazineExtended.cpp
@@ -0,0 +1,77 @@
+#include "stdafx.h"
+#include "WeaponMagazined.h"
+#include "WeaponMagazinedWGrenade.h"
+
+void CWeaponMagazined::switch2_StartAim()
+{
+	VERIFY(GetState() == eAimStart);
+
+	if(iAmmoElapsed == 0 && HudAnimationExist("anm_idle_aim_start_empty"))
+		PlayHUDMotion("anm_idle_aim_start_empty", TRUE, this, GetState());
+	else
+		PlayHUDMotion("anm_idle_aim_start", TRUE, this, GetState());
+}
+
+void CWeaponMagazined::switch2_EndAim()
+{
+	VERIFY(GetState() == eAimEnd);
+
+	if (iAmmoElapsed == 0 && HudAnimationExist("anm_idle_aim_end_empty"))
+		PlayHUDMotion("anm_idle_aim_end_empty", TRUE, this, GetState());
+	else
+		PlayHUDMotion("anm_idle_aim_end", TRUE, this, GetState());
+}
+
+void CWeaponMagazinedWGrenade::switch2_StartAim()
+{
+	VERIFY(GetState() == eAimStart);
+
+	if (IsGrenadeLauncherAttached())
+	{
+		if (m_bGrenadeMode)
+		{
+			if (iAmmoElapsed == 0 && HudAnimationExist("anm_idle_aim_start_g_empty"))
+				PlayHUDMotion("anm_idle_aim_start_g_empty", TRUE, this, GetState());
+			else
+				PlayHUDMotion("anm_idle_aim_start_g", TRUE, this, GetState());
+		}
+		else
+		{
+			if (iAmmoElapsed == 0 && HudAnimationExist("anm_idle_aim_start_w_gl_empty"))
+				PlayHUDMotion("anm_idle_aim_start_w_gl_empty", TRUE, this, GetState());
+			else
+				PlayHUDMotion("anm_idle_aim_start_w_gl", TRUE, this, GetState());
+		}
+	}
+	else
+		inherited::switch2_StartAim();
+
+
+	
+}
+
+void CWeaponMagazinedWGrenade::switch2_EndAim()
+{
+	VERIFY(GetState() == eAimEnd);
+
+	if (IsGrenadeLauncherAttached())
+	{
+		if (m_bGrenadeMode)
+		{
+			if (iAmmoElapsed == 0 && HudAnimationExist("anm_idle_aim_end_g_empty"))
+				PlayHUDMotion("anm_idle_aim_end_g_empty", TRUE, this, GetState());
+			else
+				PlayHUDMotion("anm_idle_aim_end_g", TRUE, this, GetState());
+		}
+		else
+		{
+			if (iAmmoElapsed == 0 && HudAnimationExist("anm_idle_aim_end_w_gl_empty"))
+				PlayHUDMotion("anm_idle_aim_end_w_gl_empty", TRUE, this, GetState());
+			else
+				PlayHUDMotion("anm_idle_aim_end_w_gl", TRUE, this, GetState());
+		}
+	}
+	else
+		inherited::switch2_EndAim();
+
+}
\ No newline at end of file
diff --git a/src/xrGame/WeaponMagazined.cpp b/src/xrGame/WeaponMagazined.cpp
index b933f2a..3ba166e 100644
--- a/src/xrGame/WeaponMagazined.cpp
+++ b/src/xrGame/WeaponMagazined.cpp
@@ -196,6 +196,20 @@ void CWeaponMagazined::Load(LPCSTR section)
 		empty_click_speed = READ_IF_EXISTS(pSettings, r_float, *hud_sect, "empty_click_anm_speed", 1.f);
 		empty_click_power = READ_IF_EXISTS(pSettings, r_float, *hud_sect, "empty_click_anm_power", 1.f);
 	}
+
+	if (pSettings->line_exist(section, "bullet_bones"))
+	{
+		bHasBulletsToHide = true;
+		LPCSTR str = pSettings->r_string(section, "bullet_bones");
+		for (int i = 0, count = _GetItemCount(str); i < count; ++i)
+		{
+			string128 bullet_bone_name;
+			_GetItem(str, i, bullet_bone_name);
+			bullets_bones.push_back(bullet_bone_name);
+			bullet_cnt++;
+		}
+
+	}
 }
 
 void CWeaponMagazined::FireStart()
@@ -343,8 +357,54 @@ void CWeaponMagazined::OnMagazineEmpty()
 	inherited::OnMagazineEmpty();
 }
 
+int CWeaponMagazined::CheckAmmoBeforeReload(u8& v_ammoType)
+{
+	if (m_set_next_ammoType_on_reload != undefined_ammo_type)
+		v_ammoType = m_set_next_ammoType_on_reload;
+
+	//Msg("Ammo type in next reload : %d", m_set_next_ammoType_on_reload);
+
+	if (m_ammoTypes.size() <= v_ammoType)
+	{
+		//Msg("Ammo type is wrong : %d", v_ammoType);
+		return 0;
+	}
+
+	LPCSTR tmp_sect_name = m_ammoTypes[v_ammoType].c_str();
+
+	if (!tmp_sect_name)
+	{
+		//Msg("Sect name is wrong");
+		return 0;
+	}
+
+	CWeaponAmmo* ammo = smart_cast<CWeaponAmmo*>(m_pInventory->GetAny(tmp_sect_name));
+
+	if (!ammo && !m_bLockType)
+	{
+		for (u8 i = 0; i < u8(m_ammoTypes.size()); ++i)
+		{
+			//РїСЂРѕРІРµСЂРёС‚СЊ РїР°С‚СЂРѕРЅС‹ РІСЃРµС… РїРѕРґС…РѕРґСЏС‰РёС… С‚РёРїРѕРІ
+			ammo = smart_cast<CWeaponAmmo*>(m_pInventory->GetAny(m_ammoTypes[i].c_str()));
+			if (ammo)
+			{
+				v_ammoType = i;
+				break;
+			}
+		}
+	}
+
+	//Msg("Ammo type %d", v_ammoType);
+
+	return GetAmmoCount(v_ammoType);
+
+}
+
 void CWeaponMagazined::UnloadMagazine(bool spawn_ammo)
 {
+	last_hide_bullet = -1;
+	HUD_VisualBulletUpdate();
+
 	xr_map<LPCSTR, u16> l_ammo;
 
 	while (!m_magazine.empty())
@@ -495,6 +555,7 @@ void CWeaponMagazined::ReloadMagazine()
 
 void CWeaponMagazined::OnStateSwitch(u32 S, u32 oldState)
 {
+	HUD_VisualBulletUpdate();
 	inherited::OnStateSwitch(S, oldState);
 	CInventoryOwner* owner = smart_cast<CInventoryOwner*>(this->H_Parent());
 	switch (S)
@@ -509,6 +570,12 @@ void CWeaponMagazined::OnStateSwitch(u32 S, u32 oldState)
 		if (smart_cast<CActor*>(this->H_Parent()) && (Level().CurrentViewEntity() == H_Parent()))
 			CurrentGameUI()->AddCustomStatic("gun_jammed", true);
 		break;
+	case eAimStart:
+		switch2_StartAim();
+		break;
+	case eAimEnd:
+		switch2_EndAim();
+		break;
 	case eReload:
 		if (owner)
 			m_sounds_enabled = owner->CanPlayShHdRldSounds();
@@ -776,6 +843,9 @@ void CWeaponMagazined::OnShot()
 	// Animation
 	PlayAnimShoot();
 
+	// Update bullets
+	HUD_VisualBulletUpdate();
+
 	// Shell Drop
 	Fvector vel;
 	PHGetLinearVell(vel);
@@ -845,6 +915,8 @@ void CWeaponMagazined::OnAnimationEnd(u32 state)
 		break; // End of Show
 	case eIdle: switch2_Idle();
 		break; // Keep showing idle
+	case eAimStart: SwitchState(eIdle);		break;
+	case eAimEnd:   SwitchState(eIdle);		break;
 	case eSwitchMode: UpdateFireMode();
 		SwitchState(eIdle);
 		break; // Back to idle
@@ -1316,6 +1388,7 @@ bool CWeaponMagazined::Detach(const char* item_section_name, bool b_spawn_item)
 		return inherited::Detach(item_section_name, b_spawn_item);;
 }
 
+extern int scope_2dtexactive; //crookr
 void CWeaponMagazined::InitAddons()
 {
 	if (IsScopeAttached())
@@ -1332,6 +1405,7 @@ void CWeaponMagazined::InitAddons()
 			if (m_UIScope)
 			{
 				xr_delete(m_UIScope);
+				scope_2dtexactive = 0;//crookr
 			}
 
 			if (!g_dedicated_server && scope_tex_name != NULL)
@@ -1348,6 +1422,7 @@ void CWeaponMagazined::InitAddons()
 		if (m_eScopeStatus != ALife::eAddonPermanent && m_UIScope)
 		{
 			xr_delete(m_UIScope);
+			scope_2dtexactive = 0;//crookr
 		}
 		ResetScopeKoeffs();
 	}
@@ -1454,6 +1529,9 @@ void CWeaponMagazined::ResetScopeKoeffs()
 
 void CWeaponMagazined::PlayAnimShow()
 {
+
+	HUD_VisualBulletUpdate();
+
 	VERIFY(GetState() == eShowing);
 	iAmmoElapsed == 0 && HudAnimationExist("anm_show_empty")
 		? PlayHUDMotion("anm_show_empty", FALSE, this, GetState(), 1.f, 0.f, false)
@@ -1531,17 +1609,24 @@ void CWeaponMagazined::PlayAnimShoot()
 	VERIFY(GetState() == eFire);
 	if (iAmmoElapsed > 1 || !HudAnimationExist("anm_shot_l"))
 	{
-		PlayHUDMotion("anm_shots", TRUE, this, GetState(), 1.f, 0.f, false);
+		if(!IsZoomed() || !HudAnimationExist("anm_shots_aim"))
+			PlayHUDMotion("anm_shots", TRUE, this, GetState(), 1.f, 0.f, false);
+		else
+			PlayHUDMotion("anm_shots_aim", TRUE, this, GetState(), 1.f, 0.f, false);
 	}
-	else
+	else 
 	{
-		PlayHUDMotion("anm_shot_l", TRUE, this, GetState(), 1.f, 0.f, false);
+		if (!IsZoomed() || !HudAnimationExist("anm_shots_aim_l"))
+			PlayHUDMotion("anm_shot_l", TRUE, this, GetState(), 1.f, 0.f, false);
+		else
+			PlayHUDMotion("anm_shots_aim_l", TRUE, this, GetState(), 1.f, 0.f, false);
 	}
 }
 
 void CWeaponMagazined::OnMotionMark(u32 state, const motion_marks& M)
 {
 	inherited::OnMotionMark(state, M);
+
 	if (state == eReload)
 	{
 		if (bClearJamOnly)
@@ -1550,9 +1635,26 @@ void CWeaponMagazined::OnMotionMark(u32 state, const motion_marks& M)
 			bClearJamOnly = false;
 			return;
 		}
-			
-		if (m_needReload)
-			ReloadMagazine();
+		
+		if (bHasBulletsToHide && xr_strcmp(M.name.c_str(),"lmg_reload")==0)
+		{
+			u8 ammo_type = m_ammoType;
+			int ae = CheckAmmoBeforeReload(ammo_type);
+
+			if (ammo_type == m_ammoType)
+			{
+				ae += iAmmoElapsed;
+			}
+
+			last_hide_bullet = ae >= bullet_cnt ? bullet_cnt : bullet_cnt - ae - 1;
+
+			HUD_VisualBulletUpdate();
+		}
+		else
+		{
+			if (m_needReload)
+				ReloadMagazine();
+		}
 	}
 }
 
@@ -1691,6 +1793,15 @@ bool CWeaponMagazined::GetBriefInfo(II_BriefInfo& info)
 	xr_sprintf(int_str, "%d", ae);
 	info.cur_ammo = int_str;
 
+	if (bHasBulletsToHide)
+	{
+		last_hide_bullet = ae >= bullet_cnt ? bullet_cnt : bullet_cnt - ae - 1;
+
+		if (ae == 0) last_hide_bullet = -1;
+
+		//HUD_VisualBulletUpdate();
+	}
+
 	if (HasFireModes())
 	{
 		if (m_iQueueSize == WEAPON_ININITE_QUEUE)
diff --git a/src/xrGame/WeaponMagazined.h b/src/xrGame/WeaponMagazined.h
index cedd588..e45bdd2 100644
--- a/src/xrGame/WeaponMagazined.h
+++ b/src/xrGame/WeaponMagazined.h
@@ -46,6 +46,9 @@ protected:
 	virtual void switch2_Hidden();
 	virtual void switch2_Showing();
 
+	virtual void switch2_StartAim();
+	virtual void switch2_EndAim();
+
 	virtual void OnShot();
 	virtual void PlaySoundShot();
 
@@ -96,6 +99,7 @@ public:
 	virtual void net_Import(NET_Packet& P);
 
 	virtual void OnMotionMark(u32 state, const motion_marks& M);
+	virtual int     CheckAmmoBeforeReload(u8& v_ammoType);
 
 	virtual void OnH_A_Chield();
 
diff --git a/src/xrGame/WeaponMagazinedWGrenade.cpp b/src/xrGame/WeaponMagazinedWGrenade.cpp
index d46318b..9aa4bd3 100644
--- a/src/xrGame/WeaponMagazinedWGrenade.cpp
+++ b/src/xrGame/WeaponMagazinedWGrenade.cpp
@@ -1,4 +1,4 @@
-п»ї#include "stdafx.h"
+#include "stdafx.h"
 #include "weaponmagazinedwgrenade.h"
 #include "entity.h"
 #include "ParticlesObject.h"
@@ -154,6 +154,36 @@ void CWeaponMagazinedWGrenade::OnShot()
 		inherited::OnShot();
 }
 
+void CWeaponMagazinedWGrenade::PlayAnimFireModeSwitch()
+{
+	if (IsGrenadeLauncherAttached())
+	{
+		if (!m_bGrenadeMode)
+		{
+			if (!m_bHasDifferentFireModes) return;
+			if (m_aFireModes.size() <= 1) return;
+			if (GetState() != eIdle) return;
+
+			if (HudAnimationExist("anm_switch_mode_w_gl"))
+			{
+				SetPending(TRUE);
+				iAmmoElapsed == 0 && HudAnimationExist("anm_switch_mode_w_gl_empty")
+					? PlayHUDMotion("anm_switch_mode_w_gl_empty", TRUE, this, eSwitchMode)
+					: PlayHUDMotion("anm_switch_mode_w_gl", TRUE, this, eSwitchMode);
+			}
+			else
+				UpdateFireMode();
+
+			if (m_sounds.FindSoundItem("sndSwitchMode", false))
+				PlaySound("sndSwitchMode", get_LastFP());
+		}
+	}
+	else
+	{
+		inherited::PlayAnimFireModeSwitch();
+	}
+}
+
 bool CWeaponMagazinedWGrenade::SwitchMode()
 {
 	bool bUsefulStateToSwitch = ((eIdle == GetState()) || (eHidden == GetState()) || (eMisfire == GetState())) && (!IsPending());
@@ -678,6 +708,9 @@ void CWeaponMagazinedWGrenade::PlayAnimShow()
 	VERIFY(GetState() == eShowing);
 	if (IsGrenadeLauncherAttached())
 	{
+		if (!m_bGrenadeMode)
+			HUD_VisualBulletUpdate();
+
 		if (!m_bGrenadeMode)
 			iAmmoElapsed == 0 && HudAnimationExist("anm_show_empty_w_gl")
 			? PlayHUDMotion("anm_show_empty_w_gl", FALSE, this, GetState(), 1.f, 0.f, false)
@@ -856,12 +889,18 @@ void CWeaponMagazinedWGrenade::PlayAnimShoot()
 	{
 		if (iAmmoElapsed > 1 || !HudAnimationExist("anm_shot_g_l"))
 		{
-			PlayHUDMotion("anm_shots_g", TRUE, this, GetState(), 1.f, 0.f, false);
+			if (!IsZoomed() || !HudAnimationExist("anm_shots_g_aim"))
+				PlayHUDMotion("anm_shots_g", TRUE, this, GetState(), 1.f, 0.f, false);
+			else
+				PlayHUDMotion("anm_shots_g_aim", TRUE, this, GetState(), 1.f, 0.f, false);
 		}
 		else
 		{
-			PlayHUDMotion("anm_shot_g_l", TRUE, this, GetState(), 1.f, 0.f, false);
-		}
+			if(!IsZoomed() || !HudAnimationExist("anm_shot_g_l_aim"))
+				PlayHUDMotion("anm_shot_g_l", TRUE, this, GetState(), 1.f, 0.f, false);
+			else
+				PlayHUDMotion("anm_shot_g_l_aim", TRUE, this, GetState(), 1.f, 0.f, false);
+		}		
 	}
 	else
 	{
@@ -869,11 +908,17 @@ void CWeaponMagazinedWGrenade::PlayAnimShoot()
 		if (IsGrenadeLauncherAttached())
 			if (iAmmoElapsed > 1 || !HudAnimationExist("anm_shot_w_gl_l"))
 			{
-				PlayHUDMotion("anm_shots_w_gl", TRUE, this, GetState(), 1.f, 0.f, false);
+				if (!IsZoomed() || !HudAnimationExist("anm_shots_w_gl_aim"))
+					PlayHUDMotion("anm_shots_w_gl", TRUE, this, GetState(), 1.f, 0.f, false);
+				else
+					PlayHUDMotion("anm_shots_w_gl_aim", TRUE, this, GetState(), 1.f, 0.f, false);
 			}
 			else
 			{
-				PlayHUDMotion("anm_shot_w_gl_l", TRUE, this, GetState(), 1.f, 0.f, false);
+				if (!IsZoomed() || !HudAnimationExist("anm_shot_w_gl_l_aim"))
+					PlayHUDMotion("anm_shot_w_gl_l", TRUE, this, GetState(), 1.f, 0.f, false);
+				else
+					PlayHUDMotion("anm_shot_w_gl_l_aim", TRUE, this, GetState(), 1.f, 0.f, false);
 			}
 		else
 			inherited::PlayAnimShoot();
@@ -1116,6 +1161,13 @@ bool CWeaponMagazinedWGrenade::GetBriefInfo(II_BriefInfo& info)
 	int ae = GetAmmoElapsed();
 	xr_sprintf(int_str, "%d", ae);
 	info.cur_ammo._set(int_str);
+
+	if (bHasBulletsToHide && !m_bGrenadeMode)
+	{
+		last_hide_bullet = ae >= bullet_cnt ? bullet_cnt : bullet_cnt - ae - 1;
+		if (ae == 0) last_hide_bullet = -1;
+	}
+
 	if (HasFireModes())
 	{
 		if (m_iQueueSize == WEAPON_ININITE_QUEUE)
diff --git a/src/xrGame/WeaponMagazinedWGrenade.h b/src/xrGame/WeaponMagazinedWGrenade.h
index ec9b0b8..f5e014f 100644
--- a/src/xrGame/WeaponMagazinedWGrenade.h
+++ b/src/xrGame/WeaponMagazinedWGrenade.h
@@ -41,6 +41,10 @@ public:
 	virtual void OnStateSwitch(u32 S, u32 oldState);
 
 	virtual void switch2_Reload();
+	virtual void switch2_StartAim();
+	virtual void switch2_EndAim();
+
+
 	virtual void state_Fire(float dt);
 	virtual void OnShot();
 	virtual void OnEvent(NET_Packet& P, u16 type);
@@ -50,7 +54,7 @@ public:
 
 	virtual void UpdateSounds();
 
-	//переключение в режим подствольника
+	//РїРµСЂРµРєР»СЋС‡РµРЅРёРµ РІ СЂРµР¶РёРј РїРѕРґСЃС‚РІРѕР»СЊРЅРёРєР°
 	virtual bool SwitchMode();
 	void PerformSwitchGL();
 	void OnAnimationEnd(u32 state);
@@ -59,13 +63,14 @@ public:
 
 	virtual bool IsNecessaryItem(const shared_str& item_sect);
 	virtual float Weight() const;
-	//виртуальные функции для проигрывания анимации HUD
+	//РІРёСЂС‚СѓР°Р»СЊРЅС‹Рµ С„СѓРЅРєС†РёРё РґР»СЏ РїСЂРѕРёРіСЂС‹РІР°РЅРёСЏ Р°РЅРёРјР°С†РёРё HUD
 	virtual void PlayAnimShow();
 	virtual void PlayAnimHide();
 	virtual void PlayAnimReload();
 	virtual void PlayAnimIdle();
 	virtual void PlayAnimShoot();
 	virtual void PlayAnimModeSwitch();
+	virtual void PlayAnimFireModeSwitch();
 	virtual bool TryPlayAnimBore();
 
 	//Script exports
@@ -105,8 +110,8 @@ private:
 	virtual bool install_upgrade_ammo_class(LPCSTR section, bool test);
 
 public:
-	//дополнительные параметры патронов 
-	//для подствольника
+	//РґРѕРїРѕР»РЅРёС‚РµР»СЊРЅС‹Рµ РїР°СЂР°РјРµС‚СЂС‹ РїР°С‚СЂРѕРЅРѕРІ 
+	//РґР»СЏ РїРѕРґСЃС‚РІРѕР»СЊРЅРёРєР°
 	//-	CWeaponAmmo*			m_pAmmo2;
 	xr_vector<shared_str> m_ammoTypes2;
 	u8 m_ammoType2;
diff --git a/src/xrGame/WeaponShotgun.cpp b/src/xrGame/WeaponShotgun.cpp
index dfac63a..a930269 100644
--- a/src/xrGame/WeaponShotgun.cpp
+++ b/src/xrGame/WeaponShotgun.cpp
@@ -31,6 +31,10 @@ void CWeaponShotgun::Load(LPCSTR section)
 	{
 		m_bTriStateReload = !!pSettings->r_bool(section, "tri_state_reload");
 	};
+	if (pSettings->line_exist(section, "bas_state_reload"))
+	{
+		IsCustomReloadAvaible = !!pSettings->r_bool(section, "bas_state_reload");
+	}
 	if (m_bTriStateReload)
 	{
 		m_sounds.LoadSound(section, "snd_open_weapon", "sndOpen", false, m_eSoundOpen);
@@ -56,7 +60,7 @@ bool CWeaponShotgun::Action(u16 cmd, u32 flags)
 
 	if (m_bTriStateReload && GetState() == eReload &&
 		cmd == kWPN_FIRE && flags & CMD_START &&
-		m_sub_state == eSubstateReloadInProcess) //остановить перезагрузку
+		m_sub_state == eSubstateReloadInProcess || m_sub_state == eSubstateReloadInProcessEmptyEnd) //пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ
 	{
 		AddCartridge(1);
 		m_sub_state = eSubstateReloadEnd;
@@ -85,16 +89,27 @@ void CWeaponShotgun::OnAnimationEnd(u32 state)
 			{
 				m_sub_state = eSubstateReloadEnd;
 			}
+			else if (BeginReloadWasEmpty && IsCustomReloadAvaible)
+			{
+				m_sub_state = eSubstateReloadInProcessEmptyEnd;
+			}
 			SwitchState(eReload);
 		}
 		break;
 
 	case eSubstateReloadEnd:
 		{
+			BeginReloadWasEmpty = false;
 			m_sub_state = eSubstateReloadBegin;
 			SwitchState(eIdle);
 		}
 		break;
+	case eSubstateReloadInProcessEmptyEnd:
+		{	
+			m_sub_state = eSubstateReloadBegin;
+			SwitchState(eReload);
+		}
+		break;
 	};
 }
 
@@ -146,6 +161,9 @@ void CWeaponShotgun::OnStateSwitch(u32 S, u32 oldState)
 	case eSubstateReloadEnd:
 		switch2_EndReload();
 		break;
+	case eSubstateReloadInProcessEmptyEnd:
+		switch2_EndReload();
+		break;
 	};
 }
 
@@ -257,7 +275,7 @@ u8 CWeaponShotgun::AddCartridge(u8 cnt)
 
 	VERIFY((u32)iAmmoElapsed == m_magazine.size());
 
-	//выкинуть коробку патронов, если она пустая
+	//пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ, пїЅпїЅпїЅпїЅ пїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅ
 	if (m_pCurrentAmmo && !m_pCurrentAmmo->m_boxCurr && OnServer())
 		m_pCurrentAmmo->SetDropManual(TRUE);
 
diff --git a/src/xrGame/WeaponUpgrade.cpp b/src/xrGame/WeaponUpgrade.cpp
index 4b266c9..27af437 100644
--- a/src/xrGame/WeaponUpgrade.cpp
+++ b/src/xrGame/WeaponUpgrade.cpp
@@ -281,6 +281,10 @@ bool CWeapon::install_upgrade_addon(LPCSTR section, bool test)
 	result |= process_if_exists_set(section, "scope_alive_detector", &CInifile::r_string_wb,
 	                                m_zoom_params.m_sUseBinocularVision, test);
 
+	process_if_exists_set(section, "scope_dynamic_zoom", &CInifile::r_bool, m_zoom_params.m_bUseDynamicZoom_Primary, test);
+	process_if_exists_set(section, "scope_dynamic_zoom_alt", &CInifile::r_bool, m_zoom_params.m_bUseDynamicZoom_Alt, test);
+	process_if_exists_set(section, "scope_dynamic_zoom_gl", &CInifile::r_bool, m_zoom_params.m_bUseDynamicZoom_GL, test);
+
 	result |= result2;
 
 	temp_int = (int)m_eSilencerStatus;
diff --git a/src/xrGame/ai/monsters/bloodsucker/bloodsucker.cpp b/src/xrGame/ai/monsters/bloodsucker/bloodsucker.cpp
index 2379645..dcb0f6e 100644
--- a/src/xrGame/ai/monsters/bloodsucker/bloodsucker.cpp
+++ b/src/xrGame/ai/monsters/bloodsucker/bloodsucker.cpp
@@ -505,6 +505,21 @@ CAI_Bloodsucker::visibility_t CAI_Bloodsucker::get_visibility_state() const
 	return m_force_visibility_state != unset ? m_force_visibility_state : m_visibility_state;
 }
 
+//--DSR-- HeatVision_start
+float CAI_Bloodsucker::GetTransparency() 
+{
+	if (m_visibility_state == no_visibility) 
+	{
+		return 1.0f;
+	}
+	else
+	{
+		return 0.0f;
+	}
+
+}
+//--DSR-- HeatVision_end
+
 void CAI_Bloodsucker::set_visibility_state(visibility_t new_state)
 {
 	if (m_force_visibility_state != unset)
@@ -540,6 +555,12 @@ void CAI_Bloodsucker::set_visibility_state(visibility_t new_state)
 	{
 		start_invisible_predator();
 	}
+	//--DSR-- HeatVision_start
+	/*else if (m_visibility_state == no_visibility)
+	{
+		start_invisible_predator();
+	}*/
+	//--DSR-- HeatVision_end
 	else
 	{
 		sound().play(CAI_Bloodsucker::eChangeVisibility);
@@ -856,12 +877,20 @@ void CAI_Bloodsucker::manual_deactivate()
 	setVisible(TRUE);
 }
 
+
+extern int ps_r2_heatvision;
 void CAI_Bloodsucker::renderable_Render()
 {
-	if (m_visibility_state != no_visibility)
-	{
+	//--DSR-- HeatVision_start
+	
+	//if (m_visibility_state != no_visibility)
+	//{
+	//	inherited::renderable_Render();  
+	//}
+
+	if (m_visibility_state != no_visibility || ps_r2_heatvision > 0)
 		inherited::renderable_Render();
-	}
+	//--DSR-- HeatVision_end
 }
 
 bool CAI_Bloodsucker::done_enough_hits_before_vampire()
diff --git a/src/xrGame/ai/monsters/bloodsucker/bloodsucker.h b/src/xrGame/ai/monsters/bloodsucker/bloodsucker.h
index 7fa710b..cffb4ae 100644
--- a/src/xrGame/ai/monsters/bloodsucker/bloodsucker.h
+++ b/src/xrGame/ai/monsters/bloodsucker/bloodsucker.h
@@ -215,6 +215,9 @@ private:
 	TTime m_runaway_invisible_time;
 
 public:
+
+	virtual float GetTransparency(); //--DSR-- HeatVision
+
 	float get_full_visibility_radius();
 	float get_partial_visibility_radius();
 	float get_no_visibility_radius();
diff --git a/src/xrGame/ai/monsters/burer/burer_state_attack_gravi_inline.h b/src/xrGame/ai/monsters/burer/burer_state_attack_gravi_inline.h
index 59ffe28..a25205f 100644
--- a/src/xrGame/ai/monsters/burer/burer_state_attack_gravi_inline.h
+++ b/src/xrGame/ai/monsters/burer/burer_state_attack_gravi_inline.h
@@ -138,4 +138,8 @@ void CStateBurerAttackGravi<Object>::ExecuteGraviFire()
 
 	object->StopGraviPrepare();
 	object->sound().play(CBurer::eMonsterSoundGraviAttack);
+
+	// Interactive Grass FX
+	extern Fvector4 ps_ssfx_grass_interactive;
+	g_pGamePersistent->GrassBendersAddExplosion(object->ID(), from_pos, object->Direction(), 1.33f, 3.0f, ps_ssfx_grass_interactive.w, 13.0f);
 }
diff --git a/src/xrGame/ai/monsters/control_animation_base_accel.cpp b/src/xrGame/ai/monsters/control_animation_base_accel.cpp
index 10bd71f..02d3e9f 100644
--- a/src/xrGame/ai/monsters/control_animation_base_accel.cpp
+++ b/src/xrGame/ai/monsters/control_animation_base_accel.cpp
@@ -136,6 +136,8 @@ bool CControlAnimationBase::accel_check_braking(float before_interval, float nom
 {
 	if (!m_man->path_builder().is_moving_on_path()) return (braking_mode = false);
 	if (!accel_active(eAV_Braking)) return (braking_mode = false);
+	if (m_man->path_builder().detail().path()[m_man->path_builder().detail().curr_travel_point_index()].velocity == MonsterMovement::eVelocityParameterStand)
+		return (braking_mode = false);
 
 	float acceleration = accel_get(eAV_Braking);
 	float braking_dist = (nominal_speed * ((braking_mode) ? nominal_speed : m_man->movement().velocity_current())) / (2
diff --git a/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp b/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp
index 908d83f..bf0aaa1 100644
--- a/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp
+++ b/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp
@@ -17,6 +17,13 @@
 #include "../control_path_builder_base.h"
 #include "inventory_item.h"
 
+#include "script_hit.h"
+#include "pch_script.h"
+#include "../../script_game_object.h"
+
+// demonized: Flag for damaging NPCs and other objects by the stomp attack
+BOOL pseudogiantCanDamageObjects = 1;
+
 
 CPseudoGigant::CPseudoGigant()
 {
@@ -262,6 +269,21 @@ void CPseudoGigant::on_activate_control(ControlCom::EControlType type)
 	{
 		m_sound_start_threaten.play_at_pos(this, get_head_position(this));
 		m_time_next_threaten = time() + Random.randI(m_threaten_delay_min, m_threaten_delay_max);
+
+		// callback for start animation, will be triggered by everyone in radius
+		m_nearest.clear_not_free();
+		Level().ObjectSpace.GetNearest(m_nearest, Position(), 15.f, NULL);
+		for (u32 i = 0; i < m_nearest.size(); i++)
+		{
+			CPhysicsShellHolder* obj = smart_cast<CPhysicsShellHolder*>(m_nearest[i]);
+			if (obj && obj->ID() != 0 && obj->ID() != ID()) {
+				luabind::functor<void> funct;
+				if (ai().script_engine().functor("_G.CPseudoGigant__OnStartStompAnimation", funct))
+				{
+					funct(obj->lua_game_object(), this->lua_game_object());
+				}
+			}
+		}
 	}
 }
 
@@ -274,6 +296,56 @@ void CPseudoGigant::on_threaten_execute()
 	{
 		CPhysicsShellHolder* obj = smart_cast<CPhysicsShellHolder *>(m_nearest[i]);
 		CInventoryItem* itm = smart_cast<CInventoryItem*>(m_nearest[i]);
+
+		if (pseudogiantCanDamageObjects && obj && obj->ID() != 0 && obj->ID() != ID()) {
+			float dist_to_enemy = obj->Position().distance_to(Position());
+			float hit_value;
+			hit_value = m_kick_damage - m_kick_damage * dist_to_enemy / m_threaten_dist_max;
+			clamp(hit_value, 0.f, 1.f);
+
+			SHit HS;
+
+			HS.GenHeader(GE_HIT, obj->ID()); 
+			HS.whoID = ID(); 
+			HS.who = this;
+			HS.weaponID = ID(); 
+			HS.dir = Fvector().set(0.f, 1.f, 0.f); 
+			HS.power = hit_value; 
+			HS.boneID = smart_cast<IKinematics*>(obj->Visual())->LL_GetBoneRoot();
+			HS.p_in_bone_space = Fvector().set(0.f, 0.f, 0.f);
+
+			HS.impulse = obj->cast_entity_alive() && obj->cast_entity_alive()->g_Alive() ? 80 * 80 : 0; // 0 impulse for not alive objects, they will receive the impulse later
+			//HS.impulse = 80 * obj->character_physics_support()->movement()->GetMass();
+
+			HS.hit_type = ALife::eHitTypeStrike;
+
+			bool doHit = true;
+			luabind::functor<bool> funct;
+			CScriptHit tLuaHit(&HS);
+			if (ai().script_engine().functor("_G.CPseudoGigant__BeforeHitCallback", funct))
+			{
+				doHit = funct(obj->lua_game_object(), this->lua_game_object(), &tLuaHit, HS.boneID);
+				if (doHit) {
+					HS.ApplyScriptHit(&tLuaHit);
+				}
+			}
+
+			if (doHit) {
+				//Msg("hit entity %d, name %s, damage %f", obj->ID(), obj->Name(), hit_value);
+				obj->Hit(&HS);
+
+				luabind::functor<void> hitFunct;
+				if (ai().script_engine().functor("_G.CPseudoGigant__HitCallback", hitFunct))
+				{
+					hitFunct(obj->lua_game_object(), this->lua_game_object(), &tLuaHit, HS.boneID);
+				}
+
+				//NET_Packet l_P;
+				//HS.Write_Packet(l_P);
+				//u_EventSend(l_P);
+			}						
+		}
+
 		if (!obj || !obj->m_pPhysicsShell || (itm && itm->IsQuestItem())) continue;
 
 		Fvector dir;
@@ -291,6 +363,10 @@ void CPseudoGigant::on_threaten_execute()
 	pos.y += 0.1f;
 	m_sound_threaten_hit.play_at_pos(this, pos);
 
+	// Interactive Grass FX
+	extern Fvector4 ps_ssfx_grass_interactive;
+	g_pGamePersistent->GrassBendersAddExplosion(ID(), pos, Fvector().set(0, -99, 0), 1.33f, 5.0f, ps_ssfx_grass_interactive.w, 20);
+
 	// играть партиклы
 	PlayParticles(m_kick_particles, pos, Direction());
 
diff --git a/src/xrGame/ai/stalker/ai_stalker.h b/src/xrGame/ai/stalker/ai_stalker.h
index 0409ea5..8b4965f 100644
--- a/src/xrGame/ai/stalker/ai_stalker.h
+++ b/src/xrGame/ai/stalker/ai_stalker.h
@@ -157,6 +157,10 @@ public:
 public:
 	bool m_wounded;
 
+	// demonized: add enabling pathfinding and damage by anomalies flags
+	bool m_enable_anomalies_pathfinding = false;
+	bool m_enable_anomalies_damage = false;
+
 public:
 	CAI_Stalker();
 	virtual ~CAI_Stalker();
diff --git a/src/xrGame/ai/stalker/ai_stalker_events.cpp b/src/xrGame/ai/stalker/ai_stalker_events.cpp
index f38ad85..0c63483 100644
--- a/src/xrGame/ai/stalker/ai_stalker_events.cpp
+++ b/src/xrGame/ai/stalker/ai_stalker_events.cpp
@@ -15,6 +15,7 @@
 #include "../../level.h"
 #include "../../ai_monster_space.h"
 #include "../../characterphysicssupport.h"
+#include "CustomZone.h"
 
 using namespace StalkerSpace;
 using namespace MonsterSpace;
@@ -139,6 +140,7 @@ void CAI_Stalker::UpdateAvailableDialogs(CPhraseDialogManager* partner)
 	CAI_PhraseDialogManager::UpdateAvailableDialogs(partner);
 }
 
+extern BOOL g_ai_die_in_anomaly;
 void CAI_Stalker::feel_touch_new(CObject* O)
 {
 	//	Msg					("FEEL_TOUCH::NEW : %s",*O->cName());
@@ -146,6 +148,14 @@ void CAI_Stalker::feel_touch_new(CObject* O)
 	if (Remote()) return;
 	if ((O->spatial.type | STYPE_VISIBLEFORAI) != O->spatial.type) return;
 
+	// demonized: add g_ai_die_in_anomaly == 0 check
+	if (!(g_ai_die_in_anomaly || m_enable_anomalies_pathfinding)) {
+		CCustomZone* sr = smart_cast<CCustomZone*>(O);
+		if (sr) {
+			return;
+		}
+	}
+
 	// Now, test for game specific logical objects to minimize traffic
 	CInventoryItem* I = smart_cast<CInventoryItem*>(O);
 
diff --git a/src/xrGame/ai/stalker/ai_stalker_feel.cpp b/src/xrGame/ai/stalker/ai_stalker_feel.cpp
index c0d54c9..cd81af1 100644
--- a/src/xrGame/ai/stalker/ai_stalker_feel.cpp
+++ b/src/xrGame/ai/stalker/ai_stalker_feel.cpp
@@ -14,6 +14,7 @@
 #include "../../sight_manager.h"
 #include "../../stalker_movement_manager_smart_cover.h"
 #include "../../stalker_animation_manager.h"
+#include "CustomZone.h"
 
 #ifdef DEBUG
 #	include "../../ai_debug.h"
@@ -56,6 +57,7 @@ bool CAI_Stalker::bfCheckForNodeVisibility(u32 dwNodeID, bool bIfRayPick)
 	return (memory().visual().visible(dwNodeID, movement().m_head.current.yaw, ffGetFov()));
 }
 
+extern BOOL g_ai_die_in_anomaly;
 bool CAI_Stalker::feel_touch_contact(CObject* O)
 {
 	if (!m_take_items_enabled && smart_cast<CInventoryItem*>(O))
@@ -71,6 +73,15 @@ bool CAI_Stalker::feel_touch_contact(CObject* O)
 	if (!game_object)
 		return (false);
 
+	// demonized: add g_ai_die_in_anomaly == 0 and m_enable_anomalies_pathfinding check
+	// when 0 - disable pathfinding around anomaly
+	if (!(g_ai_die_in_anomaly || m_enable_anomalies_pathfinding)) {
+		CCustomZone* sr = smart_cast<CCustomZone*>(O);
+		if (sr && (sr->spatial.type & STYPE_VISIBLEFORAI)) {
+			return false;
+		}
+	}
+
 	return (game_object->feel_touch_on_contact(this));
 }
 
@@ -81,6 +92,15 @@ bool CAI_Stalker::feel_touch_on_contact(CObject* O)
 	if ((O->spatial.type | STYPE_VISIBLEFORAI) != O->spatial.type)
 		return (false);
 
+	// demonized: add g_ai_die_in_anomaly == 0 and m_enable_anomalies_damage check
+	// when 0 - prevent any damage from anomalies
+	if (!(g_ai_die_in_anomaly || m_enable_anomalies_damage)) {
+		CCustomZone* sr = smart_cast<CCustomZone*>(O);
+		if (sr) {
+			return false;
+		}
+	}
+
 	return (inherited::feel_touch_on_contact(O));
 }
 
diff --git a/src/xrGame/alife_simulator_script.cpp b/src/xrGame/alife_simulator_script.cpp
index e5b96f1..34e7719 100644
--- a/src/xrGame/alife_simulator_script.cpp
+++ b/src/xrGame/alife_simulator_script.cpp
@@ -412,6 +412,15 @@ CSE_Abstract* reprocess_spawn(CALifeSimulator* self, CSE_Abstract* object)
 	return (self->server().Process_spawn(packet, clientID));
 }
 
+// demonized: iterate alife objects
+void CALifeSimulator__iterate_objects(const CALifeSimulator* self, luabind::functor<bool> functor)
+{
+	const CALifeObjectRegistry &objects = self->objects();
+	for (const auto& se_obj : objects.objects()) {
+		if (functor(se_obj.second)) break;
+	}
+}
+
 CSE_Abstract* try_to_clone_object(CALifeSimulator* self, CSE_Abstract* object, LPCSTR section, const Fvector& position,
                                   u32 level_vertex_id, GameGraph::_GRAPH_ID game_vertex_id, ALife::_OBJECT_ID id_parent,
                                   bool bRegister = true)
@@ -514,6 +523,9 @@ void CALifeSimulator::script_register(lua_State* L)
 		.def("get_children", &get_children, return_stl_iterator)
 		//Alundaio: END
 
+		// demonized: iterate alife objects
+		.def("iterate_objects", &CALifeSimulator__iterate_objects)
+
 		, def("alife", &alife)
 	];
 
diff --git a/src/xrGame/artefact_script.cpp b/src/xrGame/artefact_script.cpp
index 90f6dcf..c3f787c 100644
--- a/src/xrGame/artefact_script.cpp
+++ b/src/xrGame/artefact_script.cpp
@@ -33,6 +33,7 @@ void CArtefact::script_register(lua_State* L)
 		.def_readwrite("m_fSatietyRestoreSpeed", &CArtefact::m_fSatietyRestoreSpeed)
 		.def_readwrite("m_fPowerRestoreSpeed", &CArtefact::m_fPowerRestoreSpeed)
 		.def_readwrite("m_fBleedingRestoreSpeed", &CArtefact::m_fBleedingRestoreSpeed)
+		.def_readwrite("m_additional_weight", &CArtefact::m_additional_weight)
 		.def("FollowByPath", &CArtefact::FollowByPath)
 		.def("SwitchVisibility", &CArtefact::SwitchVisibility)
 		.def("GetAfRank", &CArtefact::GetAfRank),
diff --git a/src/xrGame/console_commands.cpp b/src/xrGame/console_commands.cpp
index 2841970..5c78962 100644
--- a/src/xrGame/console_commands.cpp
+++ b/src/xrGame/console_commands.cpp
@@ -1,3 +1,4 @@
+#include <unordered_set>
 #include "pch_script.h"
 #include "../xrEngine/xr_ioconsole.h"
 #include "../xrEngine/xr_ioc_cmd.h"
@@ -60,6 +61,9 @@
 
 #include "..\..\xrEngine\x_ray.h"
 
+#include "NewZoomFlag.h"
+float n_zoom_step_count = 3.0f;
+
 string_path g_last_saved_game;
 
 #ifdef DEBUG
@@ -110,6 +114,15 @@ float streff;
 
 extern BOOL g_ai_die_in_anomaly; //Alundaio
 
+//demonized: new console vars
+extern BOOL firstPersonDeath;
+extern BOOL pseudogiantCanDamageObjects;
+extern BOOL use_english_text_for_missing_translations;
+namespace crash_saving {
+	extern BOOL enabled;
+	extern int saveCountMax;
+}
+
 ENGINE_API extern float g_console_sensitive;
 
 u32 g_dead_body_collision = 1;
@@ -458,6 +471,7 @@ public:
 };
 
 //-----------------------------------------------------------------------
+std::unordered_set<CDemoRecord*> pDemoRecords;
 class CCC_DemoRecord : public IConsole_Command
 {
 public:
@@ -482,7 +496,55 @@ public:
 		string_path fn;
 		FS.update_path(fn, "$game_saves$", fn_);
 
-		g_pGameLevel->Cameras().AddCamEffector(xr_new<CDemoRecord>(fn));
+		auto pDemoRecord = xr_new<CDemoRecord>(fn, &pDemoRecords);
+		g_pGameLevel->Cameras().AddCamEffector(pDemoRecord);
+	}
+};
+
+class CCC_DemoRecordBlockedInput : public IConsole_Command
+{
+public:
+
+	CCC_DemoRecordBlockedInput(LPCSTR N) : IConsole_Command(N)
+	{
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+#ifndef	DEBUG
+		//if (GameID() != eGameIDSingle)
+		//{
+		//	Msg("For this game type Demo Record is disabled.");
+		//	return;
+		//};
+#endif
+		Console->Hide();
+
+		LPSTR fn_;
+		STRCONCAT(fn_, args, ".xrdemo");
+		string_path fn;
+		FS.update_path(fn, "$game_saves$", fn_);
+
+		auto pDemoRecord = xr_new<CDemoRecord>(fn, &pDemoRecords, TRUE);
+		g_pGameLevel->Cameras().AddCamEffector(pDemoRecord);
+	}
+};
+
+class CCC_DemoRecordStop : public IConsole_Command
+{
+public:
+
+	CCC_DemoRecordStop(LPCSTR N) : IConsole_Command(N)
+	{
+		bEmptyArgsHandled = true;
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+		for (auto pDemoRecord : pDemoRecords) {
+			pDemoRecord->StopDemo();
+		}
+		pDemoRecords.clear();
 	}
 };
 
@@ -515,6 +577,35 @@ public:
 
 Fvector CCC_DemoRecordSetPos::p = {0, 0, 0};
 
+class CCC_DemoRecordSetDir : public CCC_Vector3
+{
+	static Fvector d;
+public:
+
+	CCC_DemoRecordSetDir(LPCSTR N) : CCC_Vector3(N, &d, Fvector().set(-FLT_MAX, -FLT_MAX, -FLT_MAX),
+		Fvector().set(FLT_MAX, FLT_MAX, FLT_MAX))
+	{
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+#ifndef	DEBUG
+		//if (GameID() != eGameIDSingle)
+		//{
+		//	Msg("For this game type Demo Record is disabled.");
+		//	return;
+		//};
+#endif
+		CDemoRecord::GetGlobalDirection(d);
+		CCC_Vector3::Execute(args);
+		CDemoRecord::SetGlobalDirection(d);
+	}
+
+	virtual void Save(IWriter* F) { ; }
+};
+
+Fvector CCC_DemoRecordSetDir::d = { 0, 0, 0 };
+
 class CCC_DemoPlay : public IConsole_Command
 {
 public:
@@ -555,6 +646,57 @@ public:
 	}
 };
 
+// First Person Death
+extern float offsetH;
+extern float offsetP;
+extern float offsetB;
+extern float offsetX;
+extern float offsetY;
+extern float offsetZ;
+extern float viewportNearOffset;
+extern int firstPersonDeathPositionSmoothing;
+extern int firstPersonDeathDirectionSmoothing;
+
+class CCC_FPDDirectionOffset : public CCC_Vector3
+{
+	static Fvector d;
+public:
+
+	CCC_FPDDirectionOffset(LPCSTR N) : CCC_Vector3(N, &d, Fvector().set(-FLT_MAX, -FLT_MAX, -FLT_MAX),
+		Fvector().set(FLT_MAX, FLT_MAX, FLT_MAX))
+	{
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+		CCC_Vector3::Execute(args);
+		offsetH = d.x;
+		offsetP = d.y;
+		offsetB = d.z;
+	}
+};
+Fvector CCC_FPDDirectionOffset::d = { 0, 0, 0 };
+
+class CCC_FPDPositionOffset : public CCC_Vector3
+{
+	static Fvector d;
+public:
+
+	CCC_FPDPositionOffset(LPCSTR N) : CCC_Vector3(N, &d, Fvector().set(-FLT_MAX, -FLT_MAX, -FLT_MAX),
+		Fvector().set(FLT_MAX, FLT_MAX, FLT_MAX))
+	{
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+		CCC_Vector3::Execute(args);
+		offsetX = d.x;
+		offsetY = d.y;
+		offsetZ = d.z;
+	}
+};
+Fvector CCC_FPDPositionOffset::d = { 0, 0, 0 };
+
 // helper functions --------------------------------------------
 
 bool valid_saved_game_name(LPCSTR file_name)
@@ -2072,7 +2214,10 @@ void CCC_RegisterCommands()
 	//#ifndef MASTER_GOLD
 	CMD1(CCC_DemoPlay, "demo_play");
 	CMD1(CCC_DemoRecord, "demo_record");
+	CMD1(CCC_DemoRecordBlockedInput, "demo_record_blocked_input");
+	CMD1(CCC_DemoRecordStop, "demo_record_stop");
 	CMD1(CCC_DemoRecordSetPos, "demo_set_cam_position");
+	CMD1(CCC_DemoRecordSetDir, "demo_set_cam_direction");
 	//#endif // #ifndef MASTER_GOLD
 
 #ifndef MASTER_GOLD
@@ -2448,6 +2593,8 @@ void CCC_RegisterCommands()
 
 	CMD4(CCC_Integer, "ai_die_in_anomaly", &g_ai_die_in_anomaly, 0, 1); //Alundaio
 
+	CMD4(CCC_Integer, "pseudogiant_can_damage_objects_on_stomp", &pseudogiantCanDamageObjects, 0, 1);
+
 	CMD4(CCC_Float, "ai_aim_predict_time", &g_aim_predict_time, 0.f, 10.f);
 
 	CMD4(CCC_Float, "head_bob_factor", &g_head_bob_factor, 0.f, 2.f);
@@ -2508,8 +2655,35 @@ void CCC_RegisterCommands()
 	CMD3(CCC_Mask, "g_feel_grenade", &psDeviceFlags2, rsFeelGrenade);
 	CMD3(CCC_Mask, "g_always_active", &psDeviceFlags2, rsAlwaysActive);
 
+	// demonized: use_english_text_for_missing_translations
+	CMD4(CCC_Integer, "use_english_text_for_missing_translations", &use_english_text_for_missing_translations, 0, 1);
+
+	//First Person Death
+	CMD4(CCC_Integer, "first_person_death", &firstPersonDeath, 0, 1);
+	CMD1(CCC_FPDDirectionOffset, "first_person_death_direction_offset");
+	CMD1(CCC_FPDPositionOffset, "first_person_death_position_offset");
+	CMD4(CCC_Integer, "first_person_death_position_smoothing", &firstPersonDeathPositionSmoothing, 1, 30);
+	CMD4(CCC_Integer, "first_person_death_direction_smoothing", &firstPersonDeathDirectionSmoothing, 1, 60);
+	CMD4(CCC_Float, "first_person_death_near_plane_offset", &viewportNearOffset, -0.1, 0.5);
+
+	//Toggle crash saving
+	CMD4(CCC_Integer, "crash_save", &crash_saving::enabled, 0, 1);
+	CMD4(CCC_Integer, "crash_save_count", &crash_saving::saveCountMax, 0, 20);
+
 	if (strstr(Core.Params, "-dbgdev"))
 		CMD4(CCC_Float, "g_streff", &streff, -10.f, 10.f);
 	//No need for server commands in a singleplayer-only mod
 	//register_mp_console_commands();
+    
+    zoomFlags.set(NEW_ZOOM, FALSE);
+    zoomFlags.set(SDS_ZOOM, TRUE);
+    zoomFlags.set(SDS_SPEED, TRUE);
+    zoomFlags.set(SDS, TRUE);
+
+    CMD3(CCC_Mask, "new_zoom_enable", &zoomFlags, NEW_ZOOM);
+    CMD3(CCC_Mask, "sds_zoom_enable", &zoomFlags, SDS_ZOOM);
+    CMD3(CCC_Mask, "sds_speed_enable", &zoomFlags, SDS_SPEED);
+    CMD3(CCC_Mask, "sds_enable", &zoomFlags, SDS);
+
+    CMD4(CCC_Float, "zoom_step_count", &n_zoom_step_count, 1.0f, 10.0f);
 }
diff --git a/src/xrGame/death_anims_predicates.cpp b/src/xrGame/death_anims_predicates.cpp
index 05efd48..c9d6437 100644
--- a/src/xrGame/death_anims_predicates.cpp
+++ b/src/xrGame/death_anims_predicates.cpp
@@ -6,6 +6,7 @@
 #include	"ai/stalker/ai_stalker.h"
 #include	"stalker_movement_manager_smart_cover.h"
 #include	"weaponshotgun.h"
+#include	"WeaponAutomaticShotgun.h"
 #include	"explosive.h"
 #include	"weaponmagazined.h"
 #include	"CharacterPhysicsSupport.h"
@@ -177,8 +178,11 @@ class type_motion2 : public type_motion
 			return false;
 		//static_cast<CGameObject*>(O)->cast_weapon()
 		CWeaponShotgun* s = smart_cast<CWeaponShotgun*>(static_cast<CGameObject*>(O));
-		if (!s)
-			return false;
+		if (!s) {
+			CWeaponAutomaticShotgun* s = smart_cast<CWeaponAutomaticShotgun*>(static_cast<CGameObject*>(O));
+			if (!s)
+				return false;
+		}		
 		Fvector p;
 		const float max_distance = 20.f;
 		if (Fvector().sub(H.initiator()->Position(), global_hit_position(p, ea, H)).magnitude() > max_distance)
diff --git a/src/xrGame/first_bullet_controller.h b/src/xrGame/first_bullet_controller.h
index 0d3548b..e55621e 100644
--- a/src/xrGame/first_bullet_controller.h
+++ b/src/xrGame/first_bullet_controller.h
@@ -14,6 +14,7 @@ public:
 	void load(shared_str const& section);
 	bool is_bullet_first(float actor_linear_velocity) const;
 	inline float get_fire_dispertion() const { return m_fire_dispertion; };
+	inline void set_fire_dispertion(float val) { m_fire_dispertion = val; };
 	void make_shot();
 }; //class first_bullet_controller
 
diff --git a/src/xrGame/level_script.cpp b/src/xrGame/level_script.cpp
index c16d21c..14b450b 100644
--- a/src/xrGame/level_script.cpp
+++ b/src/xrGame/level_script.cpp
@@ -50,6 +50,7 @@
 #include "../xrEngine/GameMtlLib.h"
 #include "../xrEngine/xr_input.h"
 #include "script_ini_file.h"
+#include "EffectorBobbing.h"
 
 using namespace luabind;
 
@@ -333,6 +334,12 @@ void map_remove_object_spot(u16 id, LPCSTR spot_type)
 	Level().MapManager().RemoveMapLocation(spot_type, id);
 }
 
+// demonized: remove all map object spots by id
+void map_remove_all_object_spots(u16 id)
+{
+	Level().MapManager().RemoveAllMapLocationsById(id);
+}
+
 u16 map_has_object_spot(u16 id, LPCSTR spot_type)
 {
 	return Level().MapManager().HasMapLocation(spot_type, id);
@@ -626,6 +633,27 @@ float add_cam_effector(LPCSTR fn, int id, bool cyclic, LPCSTR cb_func, float cam
 	return e->GetAnimatorLength();
 }
 
+// demonized: Set custom camera position and direction with movement smoothing (for cutscenes, etc)
+void set_cam_position_direction(Fvector& position, Fvector& direction, unsigned int smoothing)
+{
+	CActor* actor = Actor();
+	actor->initFPCam();
+	actor->m_FPCam->m_HPB.set(direction);
+	actor->m_FPCam->m_Position.set(position);
+	actor->m_FPCam->m_customSmoothing = smoothing;
+}
+
+void set_cam_position_direction(Fvector& position, Fvector& direction)
+{
+	set_cam_position_direction(position, direction, 1);
+}
+
+void remove_cam_position_direction() 
+{
+	CActor* actor = Actor();
+	actor->removeFPCam();
+}
+
 void remove_cam_effector(int id)
 {
 	Actor()->Cameras().RemoveCamEffector((ECamEffectorType)id);
@@ -679,6 +707,15 @@ void set_snd_volume(float v)
 	clamp(psSoundVFactor, 0.0f, 1.0f);
 }
 
+float get_music_volume() {
+	return psSoundVMusicFactor;
+}
+
+void set_music_volume(float v) {
+	psSoundVMusicFactor = v;
+	clamp(psSoundVMusicFactor, 0.0f, 1.0f);
+}
+
 #include "actor_statistic_mgr.h"
 
 void add_actor_points(LPCSTR sect, LPCSTR detail_key, int cnt, int pts)
@@ -1374,6 +1411,98 @@ const Fvector2 world2ui(Fvector pos, bool hud = false)
 	return { x,y };
 }
 
+// demonized: unproject ui coordinates (ie mouse cursor coordinates) to world coordinates
+// returns position and underlying object id if found. If there is no object, obj_id will be 65535
+void ui2world(Fvector2 pos, Fvector& res, u16& obj_id)
+{
+	res.set(0, 0, 0);
+	if (pos.x < 0 || pos.x > UI_BASE_WIDTH || pos.y < 0 || pos.y > UI_BASE_HEIGHT) {
+		return;
+	}
+
+	// Convert to [-1; 1] NDC space
+	pos.x = 2 * pos.x / UI_BASE_WIDTH - 1;
+	pos.y = 1 - 2 * pos.y / UI_BASE_HEIGHT;
+
+	Fmatrix mProject = Device.mFullTransform;
+
+	// 4x4 invert of camera matrix
+	{
+		Fmatrix& m = mProject;
+
+		float mProjectDet = m._11 * (m._22*m._33*m._44 + m._23*m._34*m._42 + m._24*m._32*m._43 - m._24*m._33*m._42 - m._23*m._32*m._44 - m._22*m._34*m._43)
+						-   m._21 * (m._12*m._33*m._44 + m._13*m._34*m._42 + m._14*m._32*m._43 - m._14*m._33*m._42 - m._13*m._32*m._44 - m._12*m._34*m._43)
+						+   m._31 * (m._12*m._23*m._44 + m._13*m._24*m._42 + m._14*m._22*m._43 - m._14*m._23*m._42 - m._13*m._22*m._44 - m._12*m._24*m._43)
+						-   m._41 * (m._12*m._23*m._34 + m._13*m._24*m._32 + m._14*m._22*m._33 - m._14*m._23*m._32 - m._13*m._22*m._34 - m._12*m._24*m._33);
+
+		Fmatrix mProjectAdjugate;
+		mProjectAdjugate._11 = m._22*m._33*m._44 + m._23*m._34*m._42 + m._24*m._32*m._43 - m._24*m._33*m._42 - m._23*m._32*m._44 - m._22*m._34*m._43;
+		mProjectAdjugate._12 = -m._12*m._33*m._44 - m._13*m._34*m._42 - m._14*m._32*m._43 + m._14*m._33*m._42 + m._13*m._32*m._44 + m._12*m._34*m._43;
+		mProjectAdjugate._13 = m._12*m._23*m._44 + m._13*m._24*m._42 + m._14*m._22*m._43 - m._14*m._23*m._42 - m._13*m._22*m._44 - m._12*m._24*m._43;
+		mProjectAdjugate._14 = -m._12*m._23*m._34 - m._13*m._24*m._32 - m._14*m._22*m._33 + m._14*m._23*m._32 + m._13*m._22*m._34 + m._12*m._24*m._33;
+
+		mProjectAdjugate._21 = -m._21*m._33*m._44 - m._23*m._34*m._41 - m._24*m._31*m._43 + m._24*m._33*m._41 + m._23*m._31*m._44 + m._21*m._34*m._43;
+		mProjectAdjugate._22 = m._11*m._33*m._44 + m._13*m._34*m._41 + m._14*m._31*m._43 - m._14*m._33*m._41 - m._13*m._31*m._44 - m._11*m._34*m._43;
+		mProjectAdjugate._23 = -m._11*m._23*m._44 - m._13*m._24*m._41 - m._14*m._21*m._43 + m._14*m._23*m._41 + m._13*m._21*m._44 + m._11*m._24*m._43;
+		mProjectAdjugate._24 = m._11*m._23*m._34 + m._13*m._24*m._31 + m._14*m._21*m._33 - m._14*m._23*m._31 - m._13*m._21*m._34 - m._11*m._24*m._33;
+
+		mProjectAdjugate._31 = m._21*m._32*m._44 + m._22*m._34*m._41 + m._24*m._31*m._42 - m._24*m._32*m._41 - m._22*m._31*m._44 - m._21*m._34*m._42;
+		mProjectAdjugate._32 = -m._11*m._32*m._44 - m._12*m._34*m._41 - m._14*m._31*m._42 + m._14*m._32*m._41 + m._12*m._31*m._44 + m._11*m._34*m._42;
+		mProjectAdjugate._33 = m._11*m._22*m._44 + m._12*m._24*m._41 + m._14*m._21*m._42 - m._14*m._22*m._41 - m._12*m._21*m._44 - m._11*m._24*m._42;
+		mProjectAdjugate._34 = -m._11*m._22*m._34 - m._12*m._24*m._31 - m._14*m._21*m._32 + m._14*m._22*m._31 + m._12*m._21*m._34 + m._11*m._24*m._32;
+
+		mProjectAdjugate._41 = -m._21*m._32*m._43 - m._22*m._33*m._41 - m._23*m._31*m._42 + m._23*m._32*m._41 + m._22*m._31*m._43 + m._21*m._33*m._42;
+		mProjectAdjugate._42 = m._11*m._32*m._43 + m._12*m._33*m._41 + m._13*m._31*m._42 - m._13*m._32*m._41 - m._12*m._31*m._43 - m._11*m._33*m._42;
+		mProjectAdjugate._43 = -m._11*m._22*m._43 - m._12*m._23*m._41 - m._13*m._21*m._42 + m._13*m._22*m._41 + m._12*m._21*m._43 + m._11*m._23*m._42;
+		mProjectAdjugate._44 = m._11*m._22*m._33 + m._12*m._23*m._31 + m._13*m._21*m._32 - m._13*m._22*m._31 - m._12*m._21*m._33 - m._11*m._23*m._32;
+
+		mProjectDet = 1.0 / mProjectDet;
+		mProjectAdjugate.mul(mProjectDet);
+		mProject.set(mProjectAdjugate);
+	}
+		
+	// get position at arbitrary depth
+	res.set(pos.x, pos.y, 1);
+	{
+		auto& e = mProject.m;
+		auto x = res.x;
+		auto y = res.y;
+		auto z = res.z;
+		float w = 1.0 / (e[0][3] * x + e[1][3] * y + e[2][3] * z + e[3][3]);
+
+		res.x = (e[0][0] * x + e[1][0] * y + e[2][0] * z + e[3][0]) * w;
+		res.y = (e[0][1] * x + e[1][1] * y + e[2][1] * z + e[3][1]) * w;
+		res.z = (e[0][2] * x + e[1][2] * y + e[2][2] * z + e[3][2]) * w;
+	}
+
+	// perform ray cast to get actual position
+	collide::rq_result R;
+	CObject* ignore = Actor();
+	Fvector start = Device.vCameraPosition;
+	Fvector dir;
+	dir.set(res).sub(start).normalize();
+	start.mad(dir, R_VIEWPORT_NEAR);
+	float range = g_pGamePersistent->Environment().CurrentEnv->far_plane;
+
+	obj_id = 65535;
+	if (Level().ObjectSpace.RayPick(start, dir, range, collide::rqtBoth, R, ignore))
+	{
+		res.mad(start, dir, R.range);
+
+		if (R.O) {
+			CGameObject* o = smart_cast<CGameObject*>(R.O);
+			if (o) {
+				obj_id = o->ID();
+			}
+		}
+	}
+}
+
+void ui2world(Fvector& pos, Fvector& res, u16& obj_id)
+{
+	ui2world(Fvector2().set(pos.x, pos.y), res, obj_id);
+}
+
 const float get_env_rads()
 {
 	if (!CurrentGameUI())
@@ -1675,6 +1804,9 @@ void CLevel::script_register(lua_State* L)
 			def("map_has_object_spot", map_has_object_spot),
 			def("map_change_spot_hint", map_change_spot_hint),
 
+			// demonized: remove all map object spots by id
+			def("map_remove_all_object_spots", map_remove_all_object_spots),
+
 			def("add_dialog_to_render", add_dialog_to_render),
 			def("remove_dialog_to_render", remove_dialog_to_render),
 			def("hide_indicators", hide_indicators),
@@ -1705,10 +1837,18 @@ void CLevel::script_register(lua_State* L)
 			def("get_snd_volume", &get_snd_volume),
 			def("get_rain_volume", &get_rain_volume),
 			def("set_snd_volume", &set_snd_volume),
+			def("get_music_volume", &get_music_volume),
+			def("set_music_volume", &set_music_volume),
 			def("add_cam_effector", ((float (*)(LPCSTR, int, bool, LPCSTR))&add_cam_effector)),
 			def("add_cam_effector", ((float (*)(LPCSTR, int, bool, LPCSTR, float))&add_cam_effector)),
 			def("add_cam_effector", ((float (*)(LPCSTR, int, bool, LPCSTR, float, bool))&add_cam_effector)),
 			def("add_cam_effector", ((float (*)(LPCSTR, int, bool, LPCSTR, float, bool, float))&add_cam_effector)),
+
+			// demonized: Set custom camera position and direction with movement smoothing (for cutscenes, etc)
+			def("set_cam_custom_position_direction", ((void (*)(Fvector&, Fvector&, unsigned int))&set_cam_position_direction)),
+			def("set_cam_custom_position_direction", ((void (*)(Fvector&, Fvector&))&set_cam_position_direction)),
+			def("remove_cam_custom_position_direction", &remove_cam_position_direction),
+
 			def("remove_cam_effector", &remove_cam_effector),
 			def("set_cam_effector_factor", &set_cam_effector_factor),
 			def("get_cam_effector_factor", &get_cam_effector_factor),
@@ -1762,6 +1902,21 @@ void CLevel::script_register(lua_State* L)
 		.def_readonly("object", &script_rq_result::O)
 		.def_readonly("range", &script_rq_result::range)
 		.def_readonly("element", &script_rq_result::element)
+		.def_readonly("material_name", &script_rq_result::pMaterialName)
+		.def_readonly("material_flags", &script_rq_result::pMaterialFlags)
+		.def_readonly("material_phfriction", &script_rq_result::fPHFriction)
+		.def_readonly("material_phdamping", &script_rq_result::fPHDamping)
+		.def_readonly("material_phspring", &script_rq_result::fPHSpring)
+		.def_readonly("material_phbounce_start_velocity", &script_rq_result::fPHBounceStartVelocity)
+		.def_readonly("material_phbouncing", &script_rq_result::fPHBouncing)
+		.def_readonly("material_flotation_factor", &script_rq_result::fFlotationFactor)
+		.def_readonly("material_shoot_factor", &script_rq_result::fShootFactor)
+		.def_readonly("material_shoot_factor_mp", &script_rq_result::fShootFactorMP)
+		.def_readonly("material_bounce_damage_factor", &script_rq_result::fBounceDamageFactor)
+		.def_readonly("material_injurious_speed", &script_rq_result::fInjuriousSpeed)
+		.def_readonly("material_vis_transparency_factor", &script_rq_result::fVisTransparencyFactor)
+		.def_readonly("material_snd_occlusion_factor", &script_rq_result::fSndOcclusionFactor)
+		.def_readonly("material_density_factor", &script_rq_result::fDensityFactor)
 		.def(constructor<>()),
 		class_<enum_exporter<collide::rq_target>>("rq_target")
 		.enum_("targets")
@@ -1887,6 +2042,8 @@ void CLevel::script_register(lua_State* L)
 		def("prefetch_texture", prefetch_texture),
 		def("prefetch_model", prefetch_model),
 		def("get_visual_userdata", GetVisualUserdata),
-		def("world2ui", world2ui)
+		def("world2ui", world2ui),
+		def("ui2world", (void (*)(Fvector2, Fvector&, u16&))&ui2world, pure_out_value(_2) + pure_out_value(_3)),
+		def("ui2world", (void (*)(Fvector&, Fvector&, u16&))&ui2world, pure_out_value(_2) + pure_out_value(_3))
 	];
 }
\ No newline at end of file
diff --git a/src/xrGame/level_sounds.cpp b/src/xrGame/level_sounds.cpp
index 28718aa..8ea30cb 100644
--- a/src/xrGame/level_sounds.cpp
+++ b/src/xrGame/level_sounds.cpp
@@ -1,4 +1,6 @@
 #include "stdafx.h"
+#include <random>
+#include <algorithm>
 #pragma hdrstop
 
 #include "level.h"
@@ -188,6 +190,9 @@ void CLevelSoundManager::Load()
 				Msg("- Loading music tracks from '%s'...",music_sect);
 #endif // #ifdef DEBUG
 				CInifile::Sect& S = gameLtx.r_section(music_sect);
+				std::random_device rd;
+				std::mt19937 g(rd());
+				std::shuffle(S.Data.begin(), S.Data.end(), g);
 				CInifile::SectCIt it = S.Data.begin(), end = S.Data.end();
 				m_MusicTracks.reserve(S.Data.size());
 				for (; it != end; it++)
@@ -206,6 +211,7 @@ void CLevelSoundManager::Unload()
 	m_StaticSounds.clear();
 	// music
 	m_MusicTracks.clear();
+	m_PlayedMusicIndices.clear();
 }
 
 void CLevelSoundManager::Update()
@@ -228,32 +234,46 @@ void CLevelSoundManager::Update()
 		if (m_CurrentTrack < 0 && engine_time > m_NextTrackTime)
 		{
 			U32Vec indices;
-			for (u32 k = 0; k < m_MusicTracks.size(); ++k)
+			for (u32 k = 0; k < m_MusicTracks.size(); k++)
 			{
+				// Msg("Checking track %d", k);
 				SMusicTrack& T = m_MusicTracks[k];
-				if (T.IsPlaying())
+				if (T.IsPlaying()) {
 					T.Stop();
-
-				if (T.in(game_time))
+					// Msg("Stopping track %d", k);
+				}
+				if ((T.in(game_time) && m_PlayedMusicIndices.empty()) || 
+					(T.in(game_time) && !(std::find(m_PlayedMusicIndices.begin(), m_PlayedMusicIndices.end(), k) != m_PlayedMusicIndices.end()))) {
 					indices.push_back(k);
-				/*
-								if ((0==T.m_ActiveTime.x) && (0==T.m_ActiveTime.y)||
-									((int(game_time)>=T.m_ActiveTime.x)&&(int(game_time)<T.m_ActiveTime.y)))
-									indices.push_back	(k);
-				*/
+					// Msg("Pushing track %d", k);
+					/*
+									if ((0==T.m_ActiveTime.x) && (0==T.m_ActiveTime.y)||
+										((int(game_time)>=T.m_ActiveTime.x)&&(int(game_time)<T.m_ActiveTime.y)))
+										indices.push_back	(k);
+					*/
+				}
 			}
 			if (!indices.empty())
 			{
-				u32 idx = Random.randI(indices.size());
+				//u32 idx = Random.randI(indices.size());
+				u32 idx = 0;
 				m_CurrentTrack = indices[idx];
 				SMusicTrack& T = m_MusicTracks[m_CurrentTrack];
 				T.Play();
+				m_PlayedMusicIndices.push_back(indices[idx]);
+				// Msg("Starting track %d", indices[idx]);
 #ifdef DEBUG
 				Log				("- Play music track:",T.m_DbgName.c_str());
 #endif
 			}
 			else
 			{
+				// Msg("m_PlayedMusicIndices.size %d", m_PlayedMusicIndices.size());
+				m_PlayedMusicIndices.clear();
+				std::random_device rd;
+				std::mt19937 g(rd());
+				std::shuffle(m_MusicTracks.begin(), m_MusicTracks.end(), g);
+				// Msg("Refreshing tracks");
 				m_NextTrackTime = engine_time + 10000; // next check after 10 sec
 			}
 		}
@@ -262,7 +282,7 @@ void CLevelSoundManager::Update()
 		{
 			SMusicTrack& T = m_MusicTracks[m_CurrentTrack];
 			if (!T.IsPlaying())
-			{
+			{	
 				m_CurrentTrack = -1;
 				m_NextTrackTime = engine_time;
 
diff --git a/src/xrGame/level_sounds.h b/src/xrGame/level_sounds.h
index 596cc31..79359b6 100644
--- a/src/xrGame/level_sounds.h
+++ b/src/xrGame/level_sounds.h
@@ -44,6 +44,7 @@ class CLevelSoundManager
 	StaticSoundsVec m_StaticSounds;
 	DEFINE_VECTOR(SMusicTrack, MusicTrackVec, MusicTrackVecIt);
 	MusicTrackVec m_MusicTracks;
+	U32Vec m_PlayedMusicIndices; //Already played music array
 	u32 m_NextTrackTime;
 	int m_CurrentTrack;
 public:
diff --git a/src/xrGame/map_manager.cpp b/src/xrGame/map_manager.cpp
index b354e38..dc72c28 100644
--- a/src/xrGame/map_manager.cpp
+++ b/src/xrGame/map_manager.cpp
@@ -170,6 +170,21 @@ void CMapManager::RemoveMapLocation(const shared_str& spot_type, u16 id)
 	}
 }
 
+// demonized: remove all map object spots by id
+void CMapManager::RemoveAllMapLocationsById(u16 id)
+{
+	for (Locations_it it = Locations().begin(); it != Locations().end(); ) {
+		if (it->object_id == id) {
+			if (IsGameTypeSingle())
+				Level().GameTaskManager().MapLocationRelcase((*it).location);
+			Destroy((*it).location);
+			it = Locations().erase(it);
+		} else {
+			it++;
+		}
+	}
+}
+
 void CMapManager::RemoveMapLocationByObjectID(u16 id) //call on destroy object
 {
 	FindLocationByID key(id);
diff --git a/src/xrGame/map_manager.h b/src/xrGame/map_manager.h
index a49b14a..56eb0ee 100644
--- a/src/xrGame/map_manager.h
+++ b/src/xrGame/map_manager.h
@@ -21,6 +21,10 @@ public:
 	CMapLocation* AddMapLocation(const shared_str& spot_type, u16 id);
 	CMapLocation* AddRelationLocation(CInventoryOwner* pInvOwner);
 	void RemoveMapLocation(const shared_str& spot_type, u16 id);
+
+	// demonized: remove all map object spots by id
+	void RemoveAllMapLocationsById(u16 id);
+
 	bool HasMapLocation(const shared_str& spot_type, u16 id);
 	void RemoveMapLocationByObjectID(u16 id); //call on destroy object
 	void RemoveMapLocation(CMapLocation* ml);
diff --git a/src/xrGame/movement_manager.cpp b/src/xrGame/movement_manager.cpp
index 117d30d..59769bd 100644
--- a/src/xrGame/movement_manager.cpp
+++ b/src/xrGame/movement_manager.cpp
@@ -373,6 +373,9 @@ void CMovementManager::on_frame(CPHMovementControl* movement_control, Fvector& d
 		update_path();
 
 	move_along_path(movement_control, dest_position, object().client_update_fdelta());
+
+	// Update Grass benders
+	g_pGamePersistent->GrassBendersUpdate(object().ID(), grassbender_id, grassbender_frame, object().Position(), -1.0f, 1.0f, true);
 }
 
 void CMovementManager::on_travel_point_change(const u32& previous_travel_point_index)
diff --git a/src/xrGame/movement_manager.h b/src/xrGame/movement_manager.h
index 2427493..4f7fe8b 100644
--- a/src/xrGame/movement_manager.h
+++ b/src/xrGame/movement_manager.h
@@ -84,6 +84,10 @@ class CDetailPathBuilder;
 
 class CMovementManager
 {
+public:
+	u8 grassbender_id;
+	u32 grassbender_frame;
+
 private:
 	friend class CLevelPathBuilder;
 	friend class CDetailPathBuilder;
diff --git a/src/xrGame/new_sds.h b/src/xrGame/new_sds.h
new file mode 100644
index 0000000..229a8a3
--- /dev/null
+++ b/src/xrGame/new_sds.h
@@ -0,0 +1,6 @@
+#pragma once
+
+#include "map"
+#include "../xrCore/xrstring.h"
+
+std::map<shared_str, float> listScopeRadii;
\ No newline at end of file
diff --git a/src/xrGame/player_hud.cpp b/src/xrGame/player_hud.cpp
index 96fae36..fa95199 100644
--- a/src/xrGame/player_hud.cpp
+++ b/src/xrGame/player_hud.cpp
@@ -401,7 +401,7 @@ void attachable_hud_item::load(const shared_str& sect_name)
 	// Visual
 	LPCSTR visual_name = pSettings->r_string(sect_name, "item_visual");
 	IKinematicsAnimated* visual = ::Render->model_Create(visual_name)->dcast_PKinematicsAnimated();
-	R_ASSERT2(visual, make_string("could not create model %s", visual_name));
+	R_ASSERT2(visual, make_string("could not create model %s, section %s", visual_name, sect_name.c_str()));
 	m_model = smart_cast<IKinematics*>(visual);
 
 	m_attach_place_idx = pSettings->r_u16(sect_name, "attach_place_idx");
@@ -456,7 +456,7 @@ u32 attachable_hud_item::anim_play(const shared_str& anm_name_b, BOOL bMixIn, co
 		else if (bDebug)
 			Msg("playing item animation [%s]", item_anm_name.c_str());
 
-		R_ASSERT3(M2.valid(), "model has no motion [idle] ", pSettings->r_string(m_sect_name, "item_visual"));
+		R_ASSERT3(M2.valid(), make_string("model has no motion [idle], section %s", m_sect_name.c_str()).c_str(), pSettings->r_string(m_sect_name, "item_visual"));
 
 		u16 root_id = m_model->LL_GetBoneRoot();
 		CBoneInstance& root_binst = m_model->LL_GetBoneInstance(root_id);
@@ -493,12 +493,16 @@ u32 attachable_hud_item::anim_play(const shared_str& anm_name_b, BOOL bMixIn, co
 			strconcat(sizeof(anm_name), anm_name, "camera_effects\\weapon\\", M.name.c_str(), ".anm");
 			if (FS.exist(ce_path, "$game_anims$", anm_name))
 			{
-				CAnimatorCamEffector* e = xr_new<CAnimatorCamEffector>();
-				e->SetType(eCEWeaponAction);
-				e->SetHudAffect(false);
-				e->SetCyclic(false);
-				e->Start(anm_name);
-				current_actor->Cameras().AddCamEffector(e);
+				if (!(m_attach_place_idx == 1 && m_parent->attached_item(0)))
+				{
+					int rand = ::Random.randI(5000, 10000);
+					CAnimatorCamEffector* e = xr_new<CAnimatorCamEffector>();
+					e->SetType(ECamEffectorType(rand));
+					e->SetHudAffect(false);
+					e->SetCyclic(false);
+					e->Start(anm_name);
+					current_actor->Cameras().AddCamEffector(e);
+				}
 			}
 		}
 	}
@@ -682,6 +686,10 @@ void player_hud::load(const shared_str& player_hud_sect, bool force)
 	m_model_2->dcast_PKinematics()->CalculateBones_Invalidate();
 	m_model_2->dcast_PKinematics()->CalculateBones(TRUE);
 
+	//--DSR-- HeatVision_start
+	m_model->dcast_RenderVisual()->MarkAsHot(true);
+	m_model_2->dcast_RenderVisual()->MarkAsHot(true);
+	//--DSR-- HeatVision_end
 }
 
 void player_hud::load_script(LPCSTR section)
@@ -705,11 +713,18 @@ bool player_hud::render_item_ui_query()
 
 void player_hud::render_item_ui()
 {
+	IUIRender::ePointType bk = UI().m_currentPointType;
+	UI().m_currentPointType = IUIRender::pttLIT;
+	UIRender->CacheSetCullMode(IUIRender::cmNONE);
+
 	if (m_attached_items[0])
 		m_attached_items[0]->render_item_ui();
 
 	if (m_attached_items[1])
 		m_attached_items[1]->render_item_ui();
+
+	UIRender->CacheSetCullMode(IUIRender::cmCCW);
+	UI().m_currentPointType = bk;
 }
 
 void player_hud::render_hud()
@@ -1263,7 +1278,7 @@ player_hud_motion_container* player_hud::get_hand_motions(LPCSTR section)
 		if (phm->section == section)
 			return &phm->pm;
 	}
-
+	
 	hand_motions* res = xr_new<hand_motions>();
 	res->section = section;
 	res->pm.load(m_model, section);
@@ -1442,8 +1457,10 @@ void player_hud::remove_from_model_pool(LPCSTR sect)
 	}
 }
 
+shared_str current_player_hud_sect;
 attachable_hud_item* player_hud::create_hud_item(const shared_str& sect)
 {
+	current_player_hud_sect = sect;
 	xr_vector<attachable_hud_item*>::iterator it = m_pool.begin();
 	xr_vector<attachable_hud_item*>::iterator it_e = m_pool.end();
 	for (; it != it_e; ++it)
diff --git a/src/xrGame/raypick.cpp b/src/xrGame/raypick.cpp
index 8fd463b..a07bb0c 100644
--- a/src/xrGame/raypick.cpp
+++ b/src/xrGame/raypick.cpp
@@ -1,6 +1,7 @@
 #include "stdafx.h"
 #include "raypick.h"
 #include "level.h"
+#include "material_manager.h"
 
 CRayPick::CRayPick()
 {
@@ -28,6 +29,30 @@ bool CRayPick::query()
 	if (Level().ObjectSpace.RayPick(start_position, direction, range, flags, R, ignore))
 	{
 		result.set(R);
+		if (!R.O) {
+			//Msg("no object, check material");
+			auto pTri = Level().ObjectSpace.GetStaticTris() + R.element;
+			auto pMaterial = GMLib.GetMaterialByIdx(pTri->material);
+			auto pMaterialFlags = pMaterial->Flags;
+			//result.pTri = pTri;
+			//result.pMaterial = pMaterial;
+			result.pMaterialFlags = pMaterialFlags.flags;
+			result.pMaterialName = pMaterial->m_Name.c_str();
+
+			result.fPHFriction = pMaterial->fPHFriction;
+			result.fPHDamping = pMaterial->fPHDamping;
+			result.fPHSpring = pMaterial->fPHSpring;
+			result.fPHBounceStartVelocity = pMaterial->fPHBounceStartVelocity;
+			result.fPHBouncing = pMaterial->fPHBouncing;
+			result.fFlotationFactor = pMaterial->fFlotationFactor;
+			result.fShootFactor = pMaterial->fShootFactor;
+			result.fShootFactorMP = pMaterial->fShootFactorMP;
+			result.fBounceDamageFactor = pMaterial->fBounceDamageFactor;
+			result.fInjuriousSpeed = pMaterial->fInjuriousSpeed;
+			result.fVisTransparencyFactor = pMaterial->fVisTransparencyFactor;
+			result.fSndOcclusionFactor = pMaterial->fSndOcclusionFactor;
+			result.fDensityFactor = pMaterial->fDensityFactor;
+		}
 		return true;
 	}
 	else
diff --git a/src/xrGame/raypick.h b/src/xrGame/raypick.h
index 81e990e..ff36f04 100644
--- a/src/xrGame/raypick.h
+++ b/src/xrGame/raypick.h
@@ -9,6 +9,26 @@ struct script_rq_result
 	float range;
 	int element;
 
+	// Material of tri of ray query result
+	str_c pMaterialName;
+	u32 pMaterialFlags;
+
+	// physics part
+	float fPHFriction; // ?
+	float fPHDamping; // ?
+	float fPHSpring; // ?
+	float fPHBounceStartVelocity; // ?
+	float fPHBouncing; // ?
+					   // shoot&bounce&visibility&flotation
+	float fFlotationFactor; // 0.f - 1.f (1.f-полностью проходимый)
+	float fShootFactor; // 0.f - 1.f (1.f-полностью простреливаемый)
+	float fShootFactorMP; // 0.f - 1.f (1.f-полностью простреливаемый)
+	float fBounceDamageFactor; // 0.f - 100.f
+	float fInjuriousSpeed; // 0.f - ... (0.f-не отбирает здоровье (скорость уменьшения здоровья))
+	float fVisTransparencyFactor; // 0.f - 1.f (1.f-полностью прозрачный)
+	float fSndOcclusionFactor; // 0.f - 1.f (1.f-полностью слышен)
+	float fDensityFactor;
+
 	script_rq_result()
 	{
 		O = 0;
diff --git a/src/xrGame/script_game_object.cpp b/src/xrGame/script_game_object.cpp
index 5489997..9a1a917 100644
--- a/src/xrGame/script_game_object.cpp
+++ b/src/xrGame/script_game_object.cpp
@@ -369,6 +369,32 @@ Fvector CScriptGameObject::bone_position(LPCSTR bone_name, bool bHud) const
 	return (matrix.c);
 }
 
+Fvector CScriptGameObject::bone_direction(LPCSTR bone_name, bool bHud) const
+{
+	IKinematics* k = nullptr;
+
+	CHudItem* itm = smart_cast<CHudItem*>(&object());
+	if (bHud && itm)
+		k = itm->HudItemData()->m_model;
+	else
+		k = object().Visual()->dcast_PKinematics();
+
+	u16 bone_id;
+	if (xr_strlen(bone_name))
+	{
+		bone_id = k->LL_BoneID(bone_name);
+		if (bone_id == BI_NONE)
+			bone_id = k->LL_GetBoneRoot();
+	} else
+		bone_id = k->LL_GetBoneRoot();
+
+	Fmatrix matrix;
+	Fvector res;
+	matrix.mul_43((bHud && itm) ? itm->HudItemData()->m_item_transform : object().XFORM(),
+		k->LL_GetTransform(bone_id));
+	matrix.getHPB(res);
+	return (res);
+}
 
 LPCSTR CScriptGameObject::bone_name(u16 id, bool bHud)
 {
diff --git a/src/xrGame/script_game_object.h b/src/xrGame/script_game_object.h
index 640dcab..ed31343 100644
--- a/src/xrGame/script_game_object.h
+++ b/src/xrGame/script_game_object.h
@@ -683,6 +683,7 @@ public:
 	void stop_particles(LPCSTR pname, LPCSTR bone);
 
 	Fvector bone_position(LPCSTR bone_name, bool bHud = false) const;
+	Fvector bone_direction(LPCSTR bone_name, bool bHud = false) const;
 	LPCSTR bone_name(u16 id, bool bHud);
 	bool is_body_turning() const;
 	cphysics_shell_scripted* get_physics_shell() const;
@@ -937,6 +938,12 @@ public:
 	u8 GetRestrictionType();
 	void SetRestrictionType(u8 typ);
 
+	// demonized: add getters and setters for pathfinding for npcs around anomalies and damage for npcs
+	bool get_enable_anomalies_pathfinding();
+	void set_enable_anomalies_pathfinding(bool v);
+	bool get_enable_anomalies_damage();
+	void set_enable_anomalies_damage(bool v);
+
 	//Weapon
 	void Weapon_AddonAttach(CScriptGameObject* item);
 	void Weapon_AddonDetach(LPCSTR item_section, bool b_spawn_item = true);
@@ -998,6 +1005,9 @@ public:
 	void SetArtefactBleedingRestoreSpeed(float value);
 	void SetArtefactImmunity(ALife::EHitType hit_type, float value);
 
+	float GetArtefactAdditionalInventoryWeight();
+	void SetArtefactAdditionalInventoryWeight(float value);
+
 	//Eatable items
 	void SetRemainingUses(u8 value);
 	u8 GetRemainingUses();
@@ -1027,6 +1037,14 @@ public:
 	void SetActorRunCoef(float run_coef);
 	float GetActorRunBackCoef() const;
 	void SetActorRunBackCoef(float run_back_coef);
+	float GetActorWalkAccel() const;
+	void SetActorWalkAccel(float val);
+	float GetActorWalkBackCoef() const;
+	void SetActorWalkBackCoef(float val);
+
+	// demonized: Adjust Lookout coeff
+	float GetActorLookoutCoef() const;
+	void SetActorLookoutCoef(float val);
 
 	void SetCharacterIcon(LPCSTR iconName);
 #endif
diff --git a/src/xrGame/script_game_object3.cpp b/src/xrGame/script_game_object3.cpp
index c7b3f95..421b3f4 100644
--- a/src/xrGame/script_game_object3.cpp
+++ b/src/xrGame/script_game_object3.cpp
@@ -1540,6 +1540,22 @@ void CScriptGameObject::SetArtefactImmunity(ALife::EHitType hit_type, float valu
 	return artefact->SetImmunity(hit_type, value);
 }
 
+float CScriptGameObject::GetArtefactAdditionalInventoryWeight()
+{
+	CArtefact* artefact = smart_cast<CArtefact*>(&object());
+	THROW(artefact);
+
+	return artefact->m_additional_weight;
+}
+
+void CScriptGameObject::SetArtefactAdditionalInventoryWeight(float value)
+{
+	CArtefact* artefact = smart_cast<CArtefact*>(&object());
+	THROW(artefact);
+
+	artefact->m_additional_weight = value;
+}
+
 void CScriptGameObject::AttachVehicle(CScriptGameObject* veh, bool bForce)
 {
 	CActor* actor = smart_cast<CActor*>(&object());
@@ -1823,5 +1839,51 @@ void CScriptGameObject::SetRestrictionType(u8 typ)
 			Level().space_restriction_manager().register_restrictor(restr, RestrictionSpace::ERestrictorTypes(typ));
 	}
 }
+
+// demonized: add getters and setters for pathfinding for npcs around anomalies and damage for npcs
+bool CScriptGameObject::get_enable_anomalies_pathfinding()
+{
+	auto stalker = smart_cast<CAI_Stalker*>(&object());
+	if (!stalker)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CGameObject : cannot access class member m_enable_anomalies_pathfinding!");
+		return false;
+	}
+	return stalker->m_enable_anomalies_pathfinding;
+}
+void CScriptGameObject::set_enable_anomalies_pathfinding(bool v)
+{
+	auto stalker = smart_cast<CAI_Stalker*>(&object());
+	if (!stalker)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CGameObject : cannot access class member m_enable_anomalies_pathfinding!");
+		return;
+	}
+	stalker->m_enable_anomalies_pathfinding = v;
+}
+bool CScriptGameObject::get_enable_anomalies_damage()
+{
+	auto stalker = smart_cast<CAI_Stalker*>(&object());
+	if (!stalker)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CGameObject : cannot access class member m_enable_anomalies_damage!");
+		return false;
+	}
+	return stalker->m_enable_anomalies_damage;
+}
+void CScriptGameObject::set_enable_anomalies_damage(bool v)
+{
+	auto stalker = smart_cast<CAI_Stalker*>(&object());
+	if (!stalker)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CGameObject : cannot access class member m_enable_anomalies_damage!");
+		return;
+	}
+	stalker->m_enable_anomalies_damage = v;
+}
 #endif
 //-Alundaio
\ No newline at end of file
diff --git a/src/xrGame/script_game_object_inventory_owner.cpp b/src/xrGame/script_game_object_inventory_owner.cpp
index 3ad0a2f..377a214 100644
--- a/src/xrGame/script_game_object_inventory_owner.cpp
+++ b/src/xrGame/script_game_object_inventory_owner.cpp
@@ -2491,6 +2491,55 @@ void CScriptGameObject::SetActorRunBackCoef(float run_back_coef)
 	pActor->m_fRunBackFactor = run_back_coef;
 }
 
+
+float CScriptGameObject::GetActorWalkAccel() const
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member GetActorWalkAccel!");
+		return (false);
+	}
+	return (pActor->m_fWalkAccel);
+}
+void CScriptGameObject::SetActorWalkAccel(float val)
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member SetActorWalkAccel!");
+		return;
+	}
+	pActor->m_fWalkAccel = val;
+}
+
+
+float CScriptGameObject::GetActorWalkBackCoef() const
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member GetActorWalkBackCoef!");
+		return (false);
+	}
+	return (pActor->m_fWalkBackFactor);
+}
+void CScriptGameObject::SetActorWalkBackCoef(float val)
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member SetActorWalkBackCoef!");
+		return;
+	}
+	pActor->m_fWalkBackFactor = val;
+}
+
+
 void CScriptGameObject::SetCharacterIcon(LPCSTR iconName)
 {
 	CInventoryOwner* pInventoryOwner = smart_cast<CInventoryOwner*>(&object());
@@ -2503,5 +2552,30 @@ void CScriptGameObject::SetCharacterIcon(LPCSTR iconName)
 	}
 	return pInventoryOwner->SetIcon(iconName);
 }
+
+// demonized: Adjust Lookout factor
+float CScriptGameObject::GetActorLookoutCoef() const
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member GetActorLookoutCoef!");
+		return (false);
+	}
+	return (pActor->m_fLookoutFactor);
+}
+void CScriptGameObject::SetActorLookoutCoef(float val)
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member SetActorLookoutCoef!");
+		return;
+	}
+	pActor->m_fLookoutFactor = val;
+}
+
 #endif
 //Alundaio: END
diff --git a/src/xrGame/script_game_object_script3.cpp b/src/xrGame/script_game_object_script3.cpp
index aeeaf8f..477e99f 100644
--- a/src/xrGame/script_game_object_script3.cpp
+++ b/src/xrGame/script_game_object_script3.cpp
@@ -115,6 +115,7 @@ class_<CScriptGameObject>& script_register_game_object2(class_<CScriptGameObject
 			     ::set_item))
 
 		.def("bone_position", &CScriptGameObject::bone_position)
+		.def("bone_direction", &CScriptGameObject::bone_direction)
 
 		.def("bone_name", &CScriptGameObject::bone_name)
 		.def("is_body_turning", &CScriptGameObject::is_body_turning)
@@ -304,6 +305,7 @@ class_<CScriptGameObject>& script_register_game_object2(class_<CScriptGameObject
 		.def("get_artefact_power", &CScriptGameObject::GetArtefactPowerRestoreSpeed)
 		.def("get_artefact_bleeding", &CScriptGameObject::GetArtefactBleedingRestoreSpeed)
 		.def("get_artefact_immunity", &CScriptGameObject::GetArtefactImmunity)
+		.def("get_artefact_additional_inventory_weight", &CScriptGameObject::GetArtefactAdditionalInventoryWeight)
 
 		.def("set_artefact_health", &CScriptGameObject::SetArtefactHealthRestoreSpeed)
 		.def("set_artefact_radiation", &CScriptGameObject::SetArtefactRadiationRestoreSpeed)
@@ -311,6 +313,7 @@ class_<CScriptGameObject>& script_register_game_object2(class_<CScriptGameObject
 		.def("set_artefact_power", &CScriptGameObject::SetArtefactPowerRestoreSpeed)
 		.def("set_artefact_bleeding", &CScriptGameObject::SetArtefactBleedingRestoreSpeed)
 		.def("set_artefact_immunity", &CScriptGameObject::SetArtefactImmunity)
+		.def("set_artefact_additional_inventory_weight", &CScriptGameObject::SetArtefactAdditionalInventoryWeight)
 
 		//HELICOPTER
 		.def("get_helicopter", &CScriptGameObject::get_helicopter)
@@ -536,6 +539,22 @@ class_<CScriptGameObject>& script_register_game_object2(class_<CScriptGameObject
 		.def("get_actor_runback_coef", &CScriptGameObject::GetActorRunBackCoef)
 		.def("set_actor_runback_coef", &CScriptGameObject::SetActorRunBackCoef)
 		//end AVO
+
+		// demonized: Additional exports
+		.def("get_actor_walk_accel", &CScriptGameObject::GetActorWalkAccel)
+		.def("set_actor_walk_accel", &CScriptGameObject::SetActorWalkAccel)
+		.def("get_actor_walk_back_coef", &CScriptGameObject::GetActorWalkBackCoef)
+		.def("set_actor_walk_back_coef", &CScriptGameObject::SetActorWalkBackCoef)
+
+		// demonized: Adjust Lookout factor
+		.def("get_actor_lookout_coef", &CScriptGameObject::GetActorLookoutCoef)
+		.def("set_actor_lookout_coef", &CScriptGameObject::SetActorLookoutCoef)
+
+		// demonized: add getters and setters for pathfinding for npcs around anomalies and damage for npcs
+		.def("get_enable_anomalies_pathfinding", &CScriptGameObject::get_enable_anomalies_pathfinding)
+		.def("set_enable_anomalies_pathfinding", &CScriptGameObject::set_enable_anomalies_pathfinding)
+		.def("get_enable_anomalies_damage", &CScriptGameObject::get_enable_anomalies_damage)
+		.def("set_enable_anomalies_damage", &CScriptGameObject::set_enable_anomalies_damage)
 #endif
 
 		.def("set_can_be_harmed", &CScriptGameObject::SetCanBeHarmed)
diff --git a/src/xrGame/script_wallmarks_manager.cpp b/src/xrGame/script_wallmarks_manager.cpp
index 640a9c8..fdc67d5 100644
--- a/src/xrGame/script_wallmarks_manager.cpp
+++ b/src/xrGame/script_wallmarks_manager.cpp
@@ -52,9 +52,17 @@ void ScriptWallmarksManager::PlaceWallmark(Fvector dir, Fvector start_pos,
 	PlaceWallmark(dir, start_pos, trace_dist, wallmark_size, section, ignore_obj, ttl, true);
 }
 
+// demonized: add user defined rotation to wallmark
 void ScriptWallmarksManager::PlaceWallmark(Fvector dir, Fvector start_pos,
 	float trace_dist, float wallmark_size, LPCSTR section,
 	CScriptGameObject* ignore_obj, float ttl, bool random_rotation)
+{
+	PlaceWallmark(dir, start_pos, trace_dist, wallmark_size, section, ignore_obj, ttl, random_rotation ? ::Random.randF(-20.f, 20.f) : 0.f);
+}
+
+void ScriptWallmarksManager::PlaceWallmark(Fvector dir, Fvector start_pos,
+	float trace_dist, float wallmark_size, LPCSTR section,
+	CScriptGameObject* ignore_obj, float ttl, float rotation)
 {
 	collide::rq_result result;
 	BOOL reach_wall =
@@ -81,7 +89,7 @@ void ScriptWallmarksManager::PlaceWallmark(Fvector dir, Fvector start_pos,
 			end_point.set(0, 0, 0);
 			end_point.mad(start_pos, dir, result.range);
 
-			::Render->add_StaticWallmark(FindSection(section), end_point, wallmark_size, pTri, pVerts, ttl, true, random_rotation);
+			::Render->add_StaticWallmark(FindSection(section), end_point, wallmark_size, pTri, pVerts, ttl, true, rotation);
 		}
 	}
 }
diff --git a/src/xrGame/script_wallmarks_manager.h b/src/xrGame/script_wallmarks_manager.h
index 54158cf..cb45b7e 100644
--- a/src/xrGame/script_wallmarks_manager.h
+++ b/src/xrGame/script_wallmarks_manager.h
@@ -26,6 +26,9 @@ public:
 	void PlaceWallmark(Fvector dir, Fvector start_pos,
 		float trace_dist, float wallmark_size, LPCSTR section,
 		CScriptGameObject* ignore_obj, float ttl, bool random_rotation = true);
+	void PlaceWallmark(Fvector dir, Fvector start_pos,
+		float trace_dist, float wallmark_size, LPCSTR section,
+		CScriptGameObject* ignore_obj, float ttl, float rotation);
 	void PlaceSkeletonWallmark(CScriptGameObject* obj, LPCSTR section, Fvector start,
 		Fvector dir, float size, float ttl);
 };
diff --git a/src/xrGame/script_wallmarks_script.cpp b/src/xrGame/script_wallmarks_script.cpp
index 85b8bbc..bd8925e 100644
--- a/src/xrGame/script_wallmarks_script.cpp
+++ b/src/xrGame/script_wallmarks_script.cpp
@@ -17,6 +17,10 @@ void CScriptWallmarksManager::script_register(lua_State *L)
 		.def(constructor<>())
 		.def("place", (void (ScriptWallmarksManager::*)(Fvector, Fvector, float, float, LPCSTR, CScriptGameObject*, float))(&ScriptWallmarksManager::PlaceWallmark))
 		.def("place", (void (ScriptWallmarksManager::*)(Fvector, Fvector, float, float, LPCSTR, CScriptGameObject*, float, bool))(&ScriptWallmarksManager::PlaceWallmark))
+
+		// demonized: add user defined rotation to wallmark
+		.def("place", (void (ScriptWallmarksManager::*)(Fvector, Fvector, float, float, LPCSTR, CScriptGameObject*, float, float))(&ScriptWallmarksManager::PlaceWallmark))
+
 		.def("place_skeleton", &ScriptWallmarksManager::PlaceSkeletonWallmark),
 
 		def("wallmarks_manager", &GetManager)
diff --git a/src/xrGame/space_restrictor.cpp b/src/xrGame/space_restrictor.cpp
index 6448d01..3b50ea4 100644
--- a/src/xrGame/space_restrictor.cpp
+++ b/src/xrGame/space_restrictor.cpp
@@ -79,7 +79,8 @@ BOOL CSpaceRestrictor::net_Spawn(CSE_Abstract* data)
 
 	//Alundaio: zone visible for ai if g_ai_die_in_anomaly = 1 unless it's Radioactive Zone or Campfire
 	CCustomZone* zone = smart_cast<CCustomZone*>(this);
-	if (g_ai_die_in_anomaly == 0 || !zone || smart_cast<CRadioactiveZone*>(zone) || smart_cast<CZoneCampfire*>(zone))
+	//if (g_ai_die_in_anomaly == 0 || !zone || smart_cast<CRadioactiveZone*>(zone) || smart_cast<CZoneCampfire*>(zone))
+	if (!zone || smart_cast<CRadioactiveZone*>(zone) || smart_cast<CZoneCampfire*>(zone))
 		spatial.type &= ~STYPE_VISIBLEFORAI;
 
 	setEnabled(FALSE);
diff --git a/src/xrGame/string_table.cpp b/src/xrGame/string_table.cpp
index bc29288..300c635 100644
--- a/src/xrGame/string_table.cpp
+++ b/src/xrGame/string_table.cpp
@@ -30,6 +30,8 @@ void CStringTable::rescan()
 
 extern void refresh_npc_names();
 
+// demonized: use english text if locale text string is missing
+BOOL use_english_text_for_missing_translations = TRUE;
 void CStringTable::Init()
 {
 	if (NULL != pData) return;
@@ -39,6 +41,24 @@ void CStringTable::Init()
 	//имя языка, если не задано (NULL), то первый <text> в <string> в XML
 	pData->m_sLanguage = READ_IF_EXISTS(pSettings, r_string, "string_table", "language", "eng");
 
+	// demonized: parse english files first, then they will be replaced by current locale
+	if (use_english_text_for_missing_translations && xr_strcmp(pData->m_sLanguage, "eng") != 0) {
+		FS_FileSet fset;
+		string_path files_mask;
+		xr_sprintf(files_mask, "text\\%s\\*.xml", "eng");
+		FS.file_list(fset, "$game_config$", FS_ListFiles, files_mask);
+		FS_FileSetIt fit = fset.begin();
+		FS_FileSetIt fit_e = fset.end();
+
+		for (; fit != fit_e; ++fit)
+		{
+			string_path fn, ext;
+			_splitpath((*fit).name.c_str(), 0, 0, fn, ext);
+			xr_strcat(fn, ext);
+
+			Load(fn, "eng");
+		}
+	}
 
 	//---
 	FS_FileSet fset;
@@ -77,11 +97,12 @@ void CStringTable::Init()
 	discord_gameinfo.ex_update = true;
 }
 
-void CStringTable::Load(LPCSTR xml_file_full)
+void CStringTable::Load(LPCSTR xml_file_full, LPCSTR lang_in)
 {
+	LPCSTR lang = lang_in ? lang_in : pData->m_sLanguage.c_str();
 	CUIXml uiXml;
 	string_path _s;
-	strconcat(sizeof(_s), _s, "text\\", pData->m_sLanguage.c_str());
+	strconcat(sizeof(_s), _s, "text\\", lang);
 
 	uiXml.Load(CONFIG_PATH, _s, xml_file_full);
 
@@ -98,7 +119,7 @@ void CStringTable::Load(LPCSTR xml_file_full)
 		LPCSTR string_text = uiXml.Read(uiXml.GetRoot(), "string:text", i, NULL);
 
 		if (m_bWriteErrorsToLog && string_text)
-			Msg("[string table] '%s' no translation in '%s'", string_name, pData->m_sLanguage.c_str());
+			Msg("[string table] '%s' no translation in '%s'", string_name, lang);
 
 		VERIFY3(string_text, "string table entry does not have a text", string_name);
 
diff --git a/src/xrGame/string_table.h b/src/xrGame/string_table.h
index 1f0faea..0132c16 100644
--- a/src/xrGame/string_table.h
+++ b/src/xrGame/string_table.h
@@ -33,7 +33,7 @@ public:
 	void ReloadLanguage();
 private:
 	void Init();
-	void Load(LPCSTR xml_file);
+	void Load(LPCSTR xml_file, LPCSTR lang = 0);
 	static STRING_VALUE ParseLine(LPCSTR str, LPCSTR key, bool bFirst);
 	static STRING_TABLE_DATA* pData;
 };
diff --git a/src/xrGame/ui/UILines.cpp b/src/xrGame/ui/UILines.cpp
index d639789..44b48a1 100644
--- a/src/xrGame/ui/UILines.cpp
+++ b/src/xrGame/ui/UILines.cpp
@@ -7,6 +7,7 @@
 // Copyright 2005 GSC Game World
 
 #include "StdAfx.h"
+#include <cstdio>
 
 #include "UILines.h"
 #include "UIXmlInit.h"
@@ -158,7 +159,12 @@ void CUILines::ParseText(bool force)
 				{
 					bNewLines = TRUE;
 					*pszTemp = '\0';
-					ptmp_line->AddSubLine(pszSearch, tcolor);
+					CUISubLine subline;
+					subline.m_text = pszSearch;
+					subline.m_color = tcolor;
+					subline.m_last_in_line = true;
+					//ptmp_line->AddSubLine(pszSearch, tcolor);
+					ptmp_line->AddSubLine(&subline);
 					pszSearch = pszTemp + 2;
 				}
 				ptmp_line->AddSubLine(pszSearch, tcolor);
@@ -201,8 +207,9 @@ void CUILines::ParseText(bool force)
 		{
 			for (int i = 0; i < vsz; i++)
 			{
-				const char* pszText = line->m_subLines[i].m_text.c_str();
-				const u32 tcolor = line->m_subLines[i].m_color;
+				CUISubLine* pSubLine = &line->m_subLines[i];
+				const char* pszText = pSubLine->m_text.c_str();
+				const u32 tcolor = pSubLine->m_color;
 				u16 uFrom = 0, uPartLen = 0;
 				VERIFY(pszText);
 				u16 nMarkers = m_pFont->SplitByWidth(aMarkers, UBUFFER_SIZE, fTargetWidth, pszText);
@@ -222,8 +229,11 @@ void CUILines::ParseText(bool force)
 				}
 				strncpy_s(szTempLine, pszText + uFrom, MAX_MB_CHARS);
 				tmp_line.AddSubLine(szTempLine, tcolor);
-				m_lines.push_back(tmp_line);
-				tmp_line.Clear();
+				if (pSubLine->m_last_in_line || i == (vsz -1))
+				{
+					m_lines.push_back(tmp_line);
+					tmp_line.Clear();
+				}
 			}
 		}
 	}
diff --git a/src/xrGame/ui/UILogsWnd.cpp b/src/xrGame/ui/UILogsWnd.cpp
index cda3adc..6d1fad1 100644
--- a/src/xrGame/ui/UILogsWnd.cpp
+++ b/src/xrGame/ui/UILogsWnd.cpp
@@ -76,6 +76,16 @@ void CUILogsWnd::Update()
 
 	if (!m_items_ready.empty())
 	{
+		// Sort news by date correctly
+		struct {
+			bool operator()(CUIWindow* x, CUIWindow* y) {
+				CUINewsItemWnd* a = smart_cast<CUINewsItemWnd*>(x);
+				CUINewsItemWnd* b = smart_cast<CUINewsItemWnd*>(y);
+				return a->receive_time > b->receive_time;
+			}
+		} sortNewsDesc;
+		std::sort(m_items_ready.begin(), m_items_ready.end(), sortNewsDesc);
+
 		WINDOW_LIST::iterator it = m_items_ready.begin();
 		WINDOW_LIST::iterator it_e = m_items_ready.end();
 		for (; it != it_e; ++it)
@@ -178,6 +188,14 @@ void CUILogsWnd::ReLoadNews()
 	VERIFY(m_filter_news && m_filter_talk);
 	GAME_NEWS_VECTOR& news_vector = Actor()->game_news_registry->registry().objects();
 
+	// Sort news by date correctly
+	struct {
+		bool operator()(GAME_NEWS_DATA& a, GAME_NEWS_DATA& b) {
+			return a.receive_time < b.receive_time;
+		}
+	} sortNewsDesc;
+	std::sort(news_vector.begin(), news_vector.end(), sortNewsDesc);
+
 	//	u32 currentNews = 0;
 
 	bool filter_news = m_filter_news->GetCheck();
diff --git a/src/xrGame/ui/UINewsItemWnd.cpp b/src/xrGame/ui/UINewsItemWnd.cpp
index 86180d2..2d8eac6 100644
--- a/src/xrGame/ui/UINewsItemWnd.cpp
+++ b/src/xrGame/ui/UINewsItemWnd.cpp
@@ -33,6 +33,7 @@ void CUINewsItemWnd::Init(CUIXml& uiXml, LPCSTR start_from)
 
 void CUINewsItemWnd::Setup(GAME_NEWS_DATA& news_data)
 {
+	receive_time = news_data.receive_time;
 	shared_str time_str = InventoryUtilities::GetTimeAndDateAsString(news_data.receive_time);
 	u32 sz = (time_str.size() + 5) * sizeof(char);
 	PSTR str = (PSTR)_alloca(sz);
diff --git a/src/xrGame/ui/UINewsItemWnd.h b/src/xrGame/ui/UINewsItemWnd.h
index 464c410..e7f0642 100644
--- a/src/xrGame/ui/UINewsItemWnd.h
+++ b/src/xrGame/ui/UINewsItemWnd.h
@@ -2,6 +2,7 @@
 
 #include "UIWindow.h"
 #include "xrUIXmlParser.h"
+#include "../alife_time_manager.h"
 class CUIStatic;
 class CUITextWnd;
 struct GAME_NEWS_DATA;
@@ -15,6 +16,10 @@ class CUINewsItemWnd : public CUIWindow
 	CUITextWnd* m_UIText;
 	CUIStatic* m_UIImage;
 
+	// Store GAME_NEWS_DATA time
+public:
+	ALife::_TIME_ID receive_time = 0;
+
 public:
 	CUINewsItemWnd();
 	virtual ~CUINewsItemWnd();
diff --git a/src/xrGame/xrGame.vcxproj b/src/xrGame/xrGame.vcxproj
index c8e93f0..79e3410 100644
--- a/src/xrGame/xrGame.vcxproj
+++ b/src/xrGame/xrGame.vcxproj
@@ -1228,6 +1228,8 @@
     <ClInclude Include="mt_config.h" />
     <ClInclude Include="Needles.h" />
     <ClInclude Include="NET_Queue.h" />
+    <ClInclude Include="NewZoomFlag.h" />
+    <ClInclude Include="new_sds.h" />
     <ClInclude Include="NoGravityZone.h" />
     <ClInclude Include="object_actions.h" />
     <ClInclude Include="object_actions_inline.h" />
@@ -4092,6 +4094,7 @@
       <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
     </ClCompile>
     <ClCompile Include="WeaponMagazinedWGrenade.cpp" />
+    <ClCompile Include="WeaponMagazineExtended.cpp" />
     <ClCompile Include="WeaponPistol.cpp" />
     <ClCompile Include="WeaponPM.cpp">
       <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
diff --git a/src/xrGame/xrGame.vcxproj.filters b/src/xrGame/xrGame.vcxproj.filters
index 9e58e02..9d02177 100644
--- a/src/xrGame/xrGame.vcxproj.filters
+++ b/src/xrGame/xrGame.vcxproj.filters
@@ -11037,6 +11037,9 @@
     <ClCompile Include="script_wallmarks_manager.cpp">
       <Filter>Core\Client\Effects</Filter>
     </ClCompile>
+    <ClCompile Include="WeaponMagazineExtended.cpp">
+      <Filter>Core\Client\Objects\items &amp; weapons\Weapons\Custom Weapon\Automatic</Filter>
+    </ClCompile>
     <ClCompile Include="player_hud_script.cpp">
       <Filter>Core\Client\Objects\items &amp; weapons\HudItem</Filter>
     </ClCompile>
diff --git a/src/xrParticles/particle_actions_collection.cpp b/src/xrParticles/particle_actions_collection.cpp
index e023fa2..8d9fa45 100644
--- a/src/xrParticles/particle_actions_collection.cpp
+++ b/src/xrParticles/particle_actions_collection.cpp
@@ -1504,21 +1504,30 @@ void PASpeedLimit::Execute(ParticleEffect* effect, const float dt, float& tm_max
 void PASpeedLimit::Transform(const Fmatrix&) { ; }
 //-------------------------------------------------------------------------------------------------
 
+#define STEP_DEFAULT 0.033F
+
 // Change color of all particles toward the specified color
 void PATargetColor::Execute(ParticleEffect* effect, const float dt, float& tm_max)
-{
-	float scaleFac = scale * dt;
-	Fcolor c_p, c_t;
+{	
+
+	float COEFF = STEP_DEFAULT / dt;
+	float scaleFac = scale * STEP_DEFAULT;
+	Fcolor c_p, c_t, c_n;
 
 	for (u32 i = 0; i < effect->p_count; i++)
 	{
 		Particle& m = effect->particles[i];
 		if (m.age < timeFrom * tm_max || m.age > timeTo * tm_max) continue;
 
-		c_p.set(m.color);
-		c_t.set(c_p.r + (color.x - c_p.r) * scaleFac, c_p.g + (color.y - c_p.g) * scaleFac,
-		        c_p.b + (color.z - c_p.b) * scaleFac, c_p.a + (alpha - c_p.a) * scaleFac);
-		m.color = c_t.get();
+		c_p.set(m.colorR, m.colorG, m.colorB, m.colorA);
+		c_t.set(color.x, color.y, color.z, alpha);
+		c_n.lerp(c_p, c_t, scaleFac);
+		c_n.set(c_n.get());
+
+		m.colorR -= (m.colorR - c_n.r) / COEFF;
+		m.colorG -= (m.colorG - c_n.g) / COEFF;
+		m.colorB -= (m.colorB - c_n.b) / COEFF;
+		m.colorA -= (m.colorA - c_n.a) / COEFF;
 	}
 }
 
@@ -1736,6 +1745,8 @@ struct TES_PARAMS
 	float magnitude;
 };
 
+extern float ps_particle_update_coeff;
+
 
 void PATurbulenceExecuteStream(LPVOID lpvParams)
 {
@@ -1837,7 +1848,7 @@ void PATurbulence::Execute(ParticleEffect* effect, const float dt, float& tm_max
 	tesParams.epsilon = epsilon;
 	tesParams.frequency = frequency;
 	tesParams.octaves = octaves;
-	tesParams.magnitude = magnitude;
+	tesParams.magnitude = magnitude*ps_particle_update_coeff;
 	PATurbulenceExecuteStream(&tesParams);
 }
 
diff --git a/src/xrParticles/particle_effect.h b/src/xrParticles/particle_effect.h
index 79f4778..a2523b5 100644
--- a/src/xrParticles/particle_effect.h
+++ b/src/xrParticles/particle_effect.h
@@ -98,7 +98,11 @@ namespace PAPI
 				P.size = size;
 				P.rot.x = rot.x;
 				P.vel = vel;
-				P.color = color;
+				float f = float(1.0) / float(255.0);
+				P.colorA = f * ((color >> 24) & 0xff);
+				P.colorR = f * ((color >> 16) & 0xff);
+				P.colorG = f * ((color >> 8) & 0xff);
+				P.colorB = f * ((color >> 0) & 0xff);
 				P.age = age;
 				P.frame = frame;
 				P.flags.assign(flags);
diff --git a/src/xrParticles/psystem.h b/src/xrParticles/psystem.h
index b706abc..1fd92f8 100644
--- a/src/xrParticles/psystem.h
+++ b/src/xrParticles/psystem.h
@@ -123,11 +123,14 @@ namespace PAPI
 		pVector posB; // 12
 		pVector vel; // 12  	
 		pVector size; // 12
-		u32 color; // 4
+		float colorR; // 4
+		float colorG; // 4
+		float colorB; // 4
+		float colorA; // 4
 		float age; // 4       
 		u16 frame; // 2
 		Flags16 flags; // 2
-	}; // = 64
+	}; // = 76
 
 	typedef void (* OnBirthParticleCB)(void* owner, u32 param, PAPI::Particle& P, u32 idx);
 	typedef void (* OnDeadParticleCB)(void* owner, u32 param, PAPI::Particle& P, u32 idx);
diff --git a/src/xrServerEntities/script_engine.cpp b/src/xrServerEntities/script_engine.cpp
index 6d36d9e..3e17f3e 100644
--- a/src/xrServerEntities/script_engine.cpp
+++ b/src/xrServerEntities/script_engine.cpp
@@ -13,6 +13,8 @@
 #include "script_process.h"
 #include "../build_config_defines.h"
 #include "script_storage.h"
+#include <unordered_map>
+#include <set>
 
 #ifdef USE_DEBUGGER
 #	ifndef USE_LUA_STUDIO
@@ -282,6 +284,8 @@ void CScriptEngine::setup_auto_load()
 }
 
 extern void export_classes(lua_State* L);
+extern std::unordered_map<std::string, std::set<std::string>> unlocalizers;
+extern bool unlocalizerPassed;
 
 void CScriptEngine::init()
 {
@@ -328,6 +332,8 @@ void CScriptEngine::init()
 #endif // #ifndef USE_LUA_STUDIO
 	//	lua_sethook							(lua(), lua_hook_call,	LUA_MASKLINE|LUA_MASKCALL|LUA_MASKRET,	0);
 
+	unlocalizers.clear();
+	unlocalizerPassed = false;
 	bool save = m_reload_modules;
 	m_reload_modules = true;
 	process_file_if_exists("_G", false);
diff --git a/src/xrServerEntities/script_engine_script.cpp b/src/xrServerEntities/script_engine_script.cpp
index 7f1edef..2d23b21 100644
--- a/src/xrServerEntities/script_engine_script.cpp
+++ b/src/xrServerEntities/script_engine_script.cpp
@@ -10,9 +10,14 @@
 #include "script_engine.h"
 #include "ai_space.h"
 #include "script_debugger.h"
+#include "new_sds.h"
 
 using namespace luabind;
 
+void AddScope(LPCSTR key, float val) {
+    listScopeRadii[key] = val;
+}
+
 void LuaLog1(LPCSTR caMessage)
 {
 #ifndef MASTER_GOLD
@@ -240,6 +245,7 @@ void CScriptEngine::script_register(lua_State* L)
 		def("user_name", &user_name),
 		def("time_global", &script_time_global),
 		def("time_global_async", &script_time_global_async),
+        def("add_scope_radii", &AddScope),
 #ifdef XRGAME_EXPORTS
 		def("device", &get_device),
 		def("is_enough_address_space_available", &is_enough_address_space_available_impl),
diff --git a/src/xrServerEntities/script_fvector_script.cpp b/src/xrServerEntities/script_fvector_script.cpp
index 06020de..a1a7aa6 100644
--- a/src/xrServerEntities/script_fvector_script.cpp
+++ b/src/xrServerEntities/script_fvector_script.cpp
@@ -79,6 +79,7 @@ void CScriptFvector::script_register(lua_State* L)
 		.def("dotproduct", &Fvector::dotproduct)
 		.def("crossproduct", &Fvector::crossproduct, return_reference_to(_1))
 		.def("distance_to_xz", &Fvector::distance_to_xz)
+		.def("distance_to_xz_sqr", &Fvector::distance_to_xz_sqr)
 		.def("distance_to_sqr", &Fvector::distance_to_sqr)
 		.def("distance_to", &Fvector::distance_to)
 		//			.def("from_bary",					(Fvector & (Fvector::*)(const Fvector &, const Fvector &, const Fvector &, float, float, float))(&Fvector::from_bary),	return_reference_to(_1))
diff --git a/src/xrServerEntities/script_storage.cpp b/src/xrServerEntities/script_storage.cpp
index 450b304..2d5616e 100644
--- a/src/xrServerEntities/script_storage.cpp
+++ b/src/xrServerEntities/script_storage.cpp
@@ -10,6 +10,10 @@
 #include "script_storage.h"
 #include "script_thread.h"
 #include <stdarg.h>
+#include <unordered_map>
+#include <set>
+#include <sstream>
+#include <regex>
 
 #if !defined(DEBUG) && defined(USE_LUAJIT_ONE)
 #	include "opt.lua.h"
@@ -556,18 +560,27 @@ int __cdecl CScriptStorage::script_log(ScriptStorage::ELuaMessageType tLuaMessag
 	int result = vscript_log(tLuaMessageType, caFormat, marker);
 	va_end(marker);
 
-#ifdef PRINT_CALL_STACK
-#	ifndef ENGINE_BUILD
-    static bool	reenterability = false;
-    if (!reenterability)
-    {
-        reenterability = true;
-        if (eLuaMessageTypeError == tLuaMessageType)
-            ai().script_engine().print_stack();
-        reenterability = false;
-    }
-#	endif //!ENGINE_BUILD
-#endif //-PRINT_CALL_STACK
+	static bool reenterability = false;
+	if (!reenterability)
+	{
+		reenterability = true;
+		if (tLuaMessageType == ScriptStorage::eLuaMessageTypeError)
+			ai().script_engine().print_stack();
+		reenterability = false;
+	}
+
+	// #ifdef PRINT_CALL_STACK
+	// #	ifndef ENGINE_BUILD
+	//     static bool	reenterability = false;
+	//     if (!reenterability)
+	//     {
+	//         reenterability = true;
+	//         if (eLuaMessageTypeError == tLuaMessageType)
+	//             ai().script_engine().print_stack();
+	//         reenterability = false;
+	//     }
+	// #	endif //!ENGINE_BUILD
+	// #endif //-PRINT_CALL_STACK
 
 	return (result);
 }
@@ -680,19 +693,266 @@ bool CScriptStorage::load_buffer(lua_State* L, LPCSTR caBuffer, size_t tSize, LP
 	return (true);
 }
 
+std::unordered_map<std::string, std::set<std::string>> unlocalizers;
+bool unlocalizerPassed = false;
+
+std::vector<std::string> splitStringMulti(std::string& inputString, std::string separator = " ", bool includeSeparators = false) {
+	std::stringstream stringStream(inputString);
+	std::string line;
+	std::vector<std::string> wordVector;
+	while (std::getline(stringStream, line))
+	{
+		std::size_t prev = 0, pos;
+		while ((pos = line.find_first_of(separator, prev)) != std::string::npos)
+		{
+			if (pos > prev)
+				wordVector.push_back(line.substr(prev, pos - prev));
+
+			if (includeSeparators)
+				wordVector.push_back(line.substr(pos, 1));
+
+			prev = pos + 1;
+		}
+		if (prev < line.length())
+			wordVector.push_back(line.substr(prev, std::string::npos));
+	}
+	return wordVector;
+}
+
+std::vector<std::string> splitStringLimit(std::string& inputString, std::string separator = " ", int limit = 0) {
+	std::stringstream stringStream(inputString);
+	std::string line;
+	std::vector<std::string> wordVector;
+	while (std::getline(stringStream, line))
+	{
+		std::size_t prev = 0, pos;
+		while ((pos = line.find_first_of(separator, prev)) != std::string::npos)
+		{
+			if (pos > prev)
+				wordVector.push_back(line.substr(prev, pos - prev));
+
+			prev = pos + 1;
+			if (limit > 0) {
+				if (wordVector.size() >= limit) {
+					wordVector.push_back(line.substr(prev, std::string::npos));
+					return wordVector;
+				}
+			}
+		}
+		if (prev < line.length())
+			wordVector.push_back(line.substr(prev, std::string::npos));
+	}
+	return wordVector;
+}
+
+static std::string join_list(const std::vector<std::string>& items_vec) {
+	std::string ret;
+	for (const auto& i : items_vec) {
+		ret += i;
+	}
+	return ret;
+};
+
+bool unlocalRegex(std::set<std::string>& unlocals, std::string& s, const std::regex pattern, const int group, const std::string replacement) {
+	if (std::regex_match(s, pattern)) {
+		//Msg("matching local function pattern");
+		std::smatch match;
+		std::regex_search(s, match, pattern);
+		std::string variable = match[group];
+		if (unlocals.find(variable) != unlocals.end()) {
+			Msg("found variable %s to unlocal", variable.c_str());
+			s = std::regex_replace(s, pattern, replacement);
+			return true;
+		}
+	} else {
+		return false;
+	}
+	return false;
+};
+
+static void trim(std::string& s, const char* t = " \t\n\r\f\v") {
+	s.erase(s.find_last_not_of(t) + 1);
+	s.erase(0, s.find_first_not_of(t));
+};
+
+
 bool CScriptStorage::do_file(LPCSTR caScriptName, LPCSTR caNameSpaceName)
 {
+	if (!unlocalizerPassed) {
+		auto file_list = FS.file_list_open("$game_config$", "unlocalizers\\", FS_RootOnly | FS_ListFiles);
+		if (!file_list) {
+			unlocalizerPassed = true;
+		} else {
+			xr_string id;
+			auto i = file_list->begin();
+			auto e = file_list->end();
+			for (; i != e; ++i)
+			{
+				u32 length = xr_strlen(*i);
+
+				if (!((length >= 4) &&
+					((*i)[length - 4] == '.') &&
+					((*i)[length - 3] == 'l') &&
+					((*i)[length - 2] == 't') &&
+					((*i)[length - 1] == 'x')))
+					continue;
+
+				id.assign(*i, length - 4);
+
+				string_path file_name;
+				FS.update_path(file_name, "$game_config$", (xr_string("unlocalizers\\") + id).c_str());
+				xr_strcat(file_name, ".ltx");
+
+				Msg("opening file %s", file_name);
+				CInifile* config = CInifile::Create(file_name);
+
+				typedef CInifile::Root sections_type;
+				sections_type& sections = config->sections();
+
+				sections_type::const_iterator i = sections.begin();
+				sections_type::const_iterator e = sections.end();
+				for (; i != e; ++i)
+				{
+					auto sectionName = std::string((*i)->Name.c_str());
+					if (unlocalizers.find(sectionName) == unlocalizers.end()) {
+
+						// construct set that contains top level variables to delocalize by section name
+						unlocalizers[sectionName].clear();
+						Msg("creating unlocalizer for script %s", sectionName.c_str());
+					}
+					auto& data = (*i)->Data;
+					for (auto& item : data) {
+						unlocalizers[sectionName].insert(std::string(item.first.c_str()));
+						Msg("adding variable %s for unlocalizer for script %s", item.first.c_str(), sectionName.c_str());
+					}
+				}
+				CInifile::Destroy(config);
+			}
+			FS.file_list_close(file_list);
+			unlocalizerPassed = true;
+		}
+	}
 	int start = lua_gettop(lua());
 	string_path l_caLuaFileName;
 	IReader* l_tpFileReader = FS.r_open(caScriptName);
+
 	if (!l_tpFileReader)
 	{
 		script_log(eLuaMessageTypeError, "Cannot open file \"%s\"", caScriptName);
 		return (false);
 	}
+
+	// Unlocalize variables in the script defined by unlocalizers map
+	auto scriptContents = static_cast<LPCSTR>(l_tpFileReader->pointer());
+	auto scriptLength = (size_t)l_tpFileReader->length();
+	if (unlocalizers.find(std::string(caNameSpaceName)) != unlocalizers.end()) {
+		Msg("found script %s in unlocalizers data", caNameSpaceName);
+
+		// Get contents of the script file and split by lines
+		std::vector<std::string> tokens;
+		std::string temp;
+		while (!l_tpFileReader->eof())
+		{
+			char c = l_tpFileReader->r_u8();
+			temp += c;
+		}
+
+		std::stringstream stringStream(temp);
+		std::string line;
+		tokens.clear();
+		while (std::getline(stringStream, line)) {
+			tokens.push_back(line);
+		}
+
+		// Iterate lines and unlocalize variables
+		auto& unlocals = unlocalizers[std::string(caNameSpaceName)];
+
+		/*for (auto& u : unlocals) {
+			Msg("%s", u);
+		}*/
+
+		for (auto& s : tokens) {
+
+			//Msg("%s", s.c_str());
+
+			trim(s, "\n\r");
+			if (s.empty()) {
+				continue;
+			}
+
+			std::regex pattern;
+
+			//local function x(a,b,c)
+			pattern = std::regex(R"((^local)([\t ]+)(function)([\t ]+)([_a-zA-Z].*)([\t ]*)(\(.*$))");
+			if (unlocalRegex(unlocals, s, pattern, 5, "$3$4$5$6$7")) {
+				continue;
+			}
+
+			//local a = ...
+			//local a
+			//local a,b,c = ... (if one of a,b,c is in unlocalizers list - all of them will be unlocalized)
+			//local x; local y; - unsupported yet
+			pattern = std::regex(R"((^local)([\t ]+)(.*))");
+			if (std::regex_match(s, pattern)) {
+				std::smatch match;
+				std::regex_search(s, match, pattern);
+				std::string m = match[3];
+
+				// strip comments
+				std::regex r = std::regex(R"((.*)--.*)");
+				if (std::regex_match(m, r)) {
+					//Msg("found comments\n");
+					std::smatch noncomments;
+					std::regex_search(m, noncomments, r);
+					m = noncomments[1];
+				}
+
+
+				auto variablesAndValues = splitStringLimit(m, "=", 1);
+				bool hasValue = variablesAndValues.size() > 1;
+				auto variables = splitStringMulti(variablesAndValues[0], ",");
+				for (auto v : variables) {
+					trim(v);
+					//Msg("%s\n", v.c_str());
+					if (unlocals.find(v) != unlocals.end()) {
+						Msg("found variable %s to unlocal", v.c_str());
+						s = std::regex_replace(s, pattern, "$3");
+						if (!hasValue) {
+
+							// strip comments
+							std::regex r = std::regex(R"((.*)(--.*))");
+							if (std::regex_match(s, r)) {
+								//Msg("found comments\n");
+								std::smatch noncomments;
+								std::regex_search(s, noncomments, r);
+								s = std::string(noncomments[1]) + "= nil " + std::string(noncomments[2]);
+							} else {
+								s += " = nil";
+							}
+						}
+						break;
+					}
+				}
+			}
+		}
+
+		// Store result back
+		for (auto& s : tokens) {
+			s += "\n";
+		}
+
+		/*for (auto& s : tokens) {
+			Msg("%s", s.c_str());
+		}*/
+
+		auto result = join_list(tokens);
+		scriptContents = result.c_str();
+		scriptLength = strlen(scriptContents);
+	}
+
 	strconcat(sizeof(l_caLuaFileName), l_caLuaFileName, "@", caScriptName);
 
-	if (!load_buffer(lua(), static_cast<LPCSTR>(l_tpFileReader->pointer()), (size_t)l_tpFileReader->length(),
+	if (!load_buffer(lua(), scriptContents, scriptLength,
 	                 l_caLuaFileName, caNameSpaceName))
 	{
 		//		VERIFY		(lua_gettop(lua()) >= 4);
diff --git a/src/xrServerEntities/specific_character.cpp b/src/xrServerEntities/specific_character.cpp
index 9029b27..02517bc 100644
--- a/src/xrServerEntities/specific_character.cpp
+++ b/src/xrServerEntities/specific_character.cpp
@@ -5,6 +5,8 @@
 #include "PhraseDialog.h"
 #include "string_table.h"
 
+#include "ai_space.h"
+#include "Script_Game_Object.h"
 
 SSpecificCharacterData::SSpecificCharacterData()
 {
@@ -125,6 +127,32 @@ void CSpecificCharacter::load_shared(LPCSTR)
 		data()->m_ActorDialogs.push_back(dialog_name);
 	}
 
+	luabind::functor<luabind::object> funct;
+	if (ai().script_engine().functor("_G.CSpecificCharacterDialogList", funct))
+	{
+		luabind::object table = luabind::newtable(ai().script_engine().lua());
+		int i = 1;
+		for (auto const &dialog : data()->m_ActorDialogs) {
+			table[i] = dialog.c_str();
+			i++;
+		}
+		auto character_name = item_data.id.c_str();
+		luabind::object output = funct(character_name, table);
+		if (output && output.type() == LUA_TTABLE) {
+			data()->m_ActorDialogs.clear();
+			luabind::object::iterator i = output.begin();
+			luabind::object::iterator e = output.end();
+			for (; i != e; ++i) {
+				luabind::object v = *i;
+				if (v.type() == LUA_TSTRING) {
+					shared_str dialog_name = luabind::object_cast<LPCSTR>(v);
+					//Msg("character_id %s, dialog_name %s", character_name, dialog_name.c_str());
+					data()->m_ActorDialogs.push_back(dialog_name);
+				}
+			}
+		}
+	}
+
 	data()->m_icon_name = pXML->Read("icon", 0, "ui_npc_u_barman");
 
 
@@ -240,6 +268,78 @@ void CSpecificCharacter::load_shared(LPCSTR)
 		MoneyDef().inf_money = false;
 	}
 
+	luabind::functor<luabind::object> init_funct;
+	if (ai().script_engine().functor("_G.CSpecificCharacterInit", init_funct))
+	{
+		luabind::object table = luabind::newtable(ai().script_engine().lua());
+		table["name"] = Name();
+		table["bio"] = Bio().c_str();
+		table["community"] = Community().id().c_str();
+		table["icon"] = data()->m_icon_name.c_str();
+		table["start_dialog"] = data()->m_StartDialog.c_str();
+		table["panic_threshold"] = panic_threshold();
+		table["hit_probability_factor"] = hit_probability_factor();
+		table["crouch_type"] = crouch_type();
+		table["mechanic_mode"] = upgrade_mechanic();
+		table["critical_wound_weights"] = critical_wound_weights();
+		table["supplies"] = SupplySpawn();
+		table["visual"] = Visual();
+		table["npc_config"] = NpcConfigSect();
+		table["snd_config"] = sound_voice_prefix();
+		table["terrain_sect"] = terrain_sect().c_str();
+		table["rank_min"] = RankDef().min;
+		table["rank_max"] = RankDef().max;
+		table["reputation_min"] = ReputationDef().min;
+		table["reputation_max"] = ReputationDef().max;
+		table["money_min"] = MoneyDef().min_money;
+		table["money_max"] = MoneyDef().max_money;
+		table["money_infinitive"] = MoneyDef().inf_money;
+		auto character_name = item_data.id.c_str();
+		luabind::object output = init_funct(character_name, table);
+		if (output && output.type() == LUA_TTABLE) {
+			data()->m_sGameName = luabind::object_cast<LPCSTR>(output["name"]);
+			data()->m_sBioText = CStringTable().translate(luabind::object_cast<LPCSTR>(output["bio"]));
+
+			data()->m_Community.set(luabind::object_cast<LPCSTR>(output["community"]));
+			if (data()->m_Community.index() == NO_COMMUNITY_INDEX)
+				Debug.fatal(DEBUG_INFO, "wrong 'community' '%s' in specific character %s ", luabind::object_cast<LPCSTR>(output["community"]), *m_OwnId);
+
+			data()->m_icon_name = luabind::object_cast<LPCSTR>(output["icon"]);
+			data()->m_StartDialog = output["start_dialog"].type() == LUA_TSTRING ? luabind::object_cast<LPCSTR>(output["start_dialog"]) : NULL;
+			data()->m_fPanic_threshold = luabind::object_cast<float>(output["panic_threshold"]);
+			data()->m_fHitProbabilityFactor = luabind::object_cast<float>(output["hit_probability_factor"]);
+			data()->m_crouch_type = luabind::object_cast<int>(output["crouch_type"]);
+			data()->m_upgrade_mechanic = luabind::object_cast<bool>(output["mechanic_mode"]);
+			data()->m_critical_wound_weights = luabind::object_cast<LPCSTR>(output["critical_wound_weights"]);
+			data()->m_sVisual = luabind::object_cast<LPCSTR>(output["visual"]);
+			data()->m_sNpcConfigSect = luabind::object_cast<LPCSTR>(output["npc_config"]);
+			data()->m_sound_voice_prefix = luabind::object_cast<LPCSTR>(output["snd_config"]);
+			data()->m_terrain_sect = luabind::object_cast<LPCSTR>(output["terrain_sect"]);
+
+			data()->m_sSupplySpawn = luabind::object_cast<LPCSTR>(output["supplies"]);
+			if (!data()->m_sSupplySpawn.empty())
+			{
+				xr_string& str = data()->m_sSupplySpawn;
+				xr_string::size_type pos = str.find("\\n");
+				while (xr_string::npos != pos)
+				{
+					str.replace(pos, 2, "\n");
+					pos = str.find("\\n", pos + 1);
+				}
+			}
+
+			RankDef().min = _min(luabind::object_cast<int>(output["rank_min"]), luabind::object_cast<int>(output["rank_max"]));
+			RankDef().max = _max(luabind::object_cast<int>(output["rank_min"]), luabind::object_cast<int>(output["rank_max"]));
+
+			ReputationDef().min = _min(luabind::object_cast<int>(output["reputation_min"]), luabind::object_cast<int>(output["reputation_max"]));
+			ReputationDef().max = _max(luabind::object_cast<int>(output["reputation_min"]), luabind::object_cast<int>(output["reputation_max"]));
+
+			MoneyDef().min_money = _min(luabind::object_cast<int>(output["money_min"]), luabind::object_cast<int>(output["money_max"]));
+			MoneyDef().max_money = _max(luabind::object_cast<int>(output["money_min"]), luabind::object_cast<int>(output["money_max"]));
+			MoneyDef().inf_money = luabind::object_cast<bool>(output["money_infinitive"]);
+		}
+	}
+
 #endif
 
 #if 0
diff --git a/src/xrSound/Sound.h b/src/xrSound/Sound.h
index eeb6d58..07237c7 100644
--- a/src/xrSound/Sound.h
+++ b/src/xrSound/Sound.h
@@ -36,6 +36,7 @@ XRSOUND_API extern u32 psSoundModel;
 XRSOUND_API extern float psSoundVEffects;
 XRSOUND_API extern float psSoundVFactor;
 XRSOUND_API extern float psSoundVMusic;
+XRSOUND_API extern float psSoundVMusicFactor;
 XRSOUND_API extern float psSoundRolloff;
 XRSOUND_API extern float psSoundOcclusionScale;
 XRSOUND_API extern Flags32 psSoundFlags;
@@ -212,17 +213,72 @@ class XRSOUND_API CSound_environment
 public:
 };
 
+namespace soundSmoothingParams {
+	extern float power;
+	extern int steps;
+	extern float alpha;
+	extern float getAlpha();
+	extern float getTimeDeltaSmoothing();
+	extern float getSmoothedValue(float, float, float);
+};
+
 /// definition (Sound Params)
 class XRSOUND_API CSound_params
 {
+public:
+	CSound_params() :
+		set(false)
+		{
+			position.set(0.0f, 0.0f, 0.0f);
+			velocity.set(0.0f, 0.0f, 0.0f);
+			accVelocity.set(0.f, 0.f, 0.f);
+		}
+
+private:
+	bool set;
+
 public:
 	Fvector position;
+	Fvector velocity;  // Cribbledirge.  Added for doppler effect.
+	Fvector curVelocity;  // Current velocity.
+	Fvector prevVelocity;  // Previous velocity.
+	Fvector accVelocity;  // Velocity accumulator (for moving average).
 	float base_volume;
 	float volume;
 	float freq;
 	float min_distance;
 	float max_distance;
 	float max_ai_distance;
+
+	// Functions added by Cribbledirge for doppler effect.
+	IC virtual void update_position(const Fvector& newPosition)
+	{
+		// If the position has been set already, start getting a moving average of the velocity.
+		if (set)
+		{
+			prevVelocity.set(accVelocity);
+			curVelocity.sub(newPosition, position);
+
+			//accVelocity.set(curVelocity.mul(alpha).add(prevVelocity.mul(1.f - alpha)));
+		}
+		else
+		{
+			set = true;
+		}
+		position.set(newPosition);
+	}
+
+	IC virtual void update_velocity(const float dt)
+	{
+		float a = soundSmoothingParams::getTimeDeltaSmoothing();
+		int p = soundSmoothingParams::power;
+		accVelocity.x = soundSmoothingParams::getSmoothedValue(curVelocity.x * p / dt, accVelocity.x, a);
+		accVelocity.y = soundSmoothingParams::getSmoothedValue(curVelocity.y * p / dt, accVelocity.y, a);
+		accVelocity.z = soundSmoothingParams::getSmoothedValue(curVelocity.z * p / dt, accVelocity.z, a);
+		velocity.set(accVelocity);
+
+		//Msg("VELOC: %f", velocity.magnitude());
+	}
 };
 
 /// definition (Sound Interface)
diff --git a/src/xrSound/SoundRender_Core.cpp b/src/xrSound/SoundRender_Core.cpp
index 203aeb3..3caa495 100644
--- a/src/xrSound/SoundRender_Core.cpp
+++ b/src/xrSound/SoundRender_Core.cpp
@@ -17,6 +17,7 @@ float psSoundVEffects = 1.0f;
 float psSoundVFactor = 1.0f;
 
 float psSoundVMusic = 1.f;
+float psSoundVMusicFactor = 1.f;
 int psSoundCacheSizeMB = 32;
 
 CSoundRender_Core* SoundRender = 0;
diff --git a/src/xrSound/SoundRender_CoreA.cpp b/src/xrSound/SoundRender_CoreA.cpp
index 4301be7..a90e63c 100644
--- a/src/xrSound/SoundRender_CoreA.cpp
+++ b/src/xrSound/SoundRender_CoreA.cpp
@@ -7,6 +7,22 @@
 #include "../xrEngine/pure.h"
 #include "../xrEngine/XR_IOConsole.h"
 
+namespace soundSmoothingParams {
+	float power = 1.8;
+	int steps = 15;
+	float alpha = getAlpha();
+	IC float getAlpha() {
+		return 2.0f / (steps + 1);
+	}
+	IC float getTimeDeltaSmoothing() {
+		return alpha;
+		//return min(1.0f, alpha * (Device.fTimeDelta / steps));
+	}
+	IC float getSmoothedValue(float target, float current, float smoothing = getTimeDeltaSmoothing()) {
+		return current + smoothing * (target - current);
+	}
+};
+
 extern CConsole* Console;
 
 CSoundRender_CoreA* SoundRenderA = 0;
@@ -148,6 +164,14 @@ void CSoundRender_CoreA::_initialize(int stage)
 		bEAX = EAXTestSupport(FALSE);
 	}
 
+	// Init listener struct
+	Listener.position.set(0.0f, 0.0f, 0.0f);
+	Listener.prevVelocity.set(0.0f, 0.0f, 0.0f);
+	Listener.curVelocity.set(0.0f, 0.0f, 0.0f);
+	Listener.accVelocity.set(0.0f, 0.0f, 0.0f);
+	Listener.orientation[0].set(0.0f, 0.0f, 0.0f);
+	Listener.orientation[1].set(0.0f, 0.0f, 0.0f);
+
 	inherited::_initialize(stage);
 
 	if (stage == 1) //first initialize
@@ -218,6 +242,18 @@ void CSoundRender_CoreA::update_listener(const Fvector& P, const Fvector& D, con
 {
 	inherited::update_listener(P, D, N, dt);
 
+	Listener.curVelocity.sub(P, Listener.position);
+
+	float a = soundSmoothingParams::getTimeDeltaSmoothing();
+	int p = soundSmoothingParams::power;
+	Listener.accVelocity.x = soundSmoothingParams::getSmoothedValue(Listener.curVelocity.x * p / dt, Listener.accVelocity.x, a);
+	Listener.accVelocity.y = soundSmoothingParams::getSmoothedValue(Listener.curVelocity.y * p / dt, Listener.accVelocity.y, a);
+	Listener.accVelocity.z = soundSmoothingParams::getSmoothedValue(Listener.curVelocity.z * p / dt, Listener.accVelocity.z, a);
+	
+	Listener.prevVelocity.set(Listener.accVelocity);
+
+	// Msg("listener sound update delta %.3f, velocity %.3f, %.3f, %.3f, power %.1f, alpha %.3f", dt, Listener.prevVelocity.x, Listener.prevVelocity.y, Listener.prevVelocity.z, soundSmoothingParams::power, soundSmoothingParams::alpha);
+
 	if (!Listener.position.similar(P))
 	{
 		Listener.position.set(P);
@@ -227,6 +263,6 @@ void CSoundRender_CoreA::update_listener(const Fvector& P, const Fvector& D, con
 	Listener.orientation[1].set(N.x, N.y, -N.z);
 
 	A_CHK(alListener3f (AL_POSITION,Listener.position.x,Listener.position.y,-Listener.position.z));
-	A_CHK(alListener3f (AL_VELOCITY,0.f,0.f,0.f));
+	A_CHK(alListener3f (AL_VELOCITY, Listener.prevVelocity.x, Listener.prevVelocity.y, -Listener.prevVelocity.z));
 	A_CHK(alListenerfv (AL_ORIENTATION,&Listener.orientation[0].x));
 }
diff --git a/src/xrSound/SoundRender_CoreA.h b/src/xrSound/SoundRender_CoreA.h
index e0eaabd..81d81c3 100644
--- a/src/xrSound/SoundRender_CoreA.h
+++ b/src/xrSound/SoundRender_CoreA.h
@@ -26,6 +26,9 @@ class CSoundRender_CoreA : public CSoundRender_Core
 	struct SListener
 	{
 		Fvector position;
+		Fvector prevVelocity;
+		Fvector curVelocity;
+		Fvector accVelocity;
 		Fvector orientation[2];
 	};
 
diff --git a/src/xrSound/SoundRender_Emitter.cpp b/src/xrSound/SoundRender_Emitter.cpp
index fa6be85..425130f 100644
--- a/src/xrSound/SoundRender_Emitter.cpp
+++ b/src/xrSound/SoundRender_Emitter.cpp
@@ -12,7 +12,7 @@ extern float psSoundVEffects;
 void CSoundRender_Emitter::set_position(const Fvector& pos)
 {
 	if (source()->channels_num() == 1)
-		p_source.position = pos;
+		p_source.update_position(pos);
 	else
 		p_source.position.set(0, 0, 0);
 
diff --git a/src/xrSound/SoundRender_Emitter_FSM.cpp b/src/xrSound/SoundRender_Emitter_FSM.cpp
index 87a6824..23141fe 100644
--- a/src/xrSound/SoundRender_Emitter_FSM.cpp
+++ b/src/xrSound/SoundRender_Emitter_FSM.cpp
@@ -68,7 +68,7 @@ void CSoundRender_Emitter::update(float dt)
 		occluder_volume = SoundRender->get_occlusion(p_source.position, .2f, occluder);
 		smooth_volume = p_source.base_volume * p_source.volume * (owner_data->s_type == st_Effect
 			                                                          ? psSoundVEffects * psSoundVFactor
-			                                                          : psSoundVMusic) * (b2D ? 1.f : occluder_volume);
+			                                                          : psSoundVMusic * psSoundVMusicFactor) * (b2D ? 1.f : occluder_volume);
 		e_current = e_target = *SoundRender->get_environment(p_source.position);
 		if (update_culling(dt))
 		{
@@ -94,7 +94,7 @@ void CSoundRender_Emitter::update(float dt)
 		occluder_volume = SoundRender->get_occlusion(p_source.position, .2f, occluder);
 		smooth_volume = p_source.base_volume * p_source.volume * (owner_data->s_type == st_Effect
 			                                                          ? psSoundVEffects * psSoundVFactor
-			                                                          : psSoundVMusic) * (b2D ? 1.f : occluder_volume);
+			                                                          : psSoundVMusic * psSoundVMusicFactor) * (b2D ? 1.f : occluder_volume);
 		e_current = e_target = *SoundRender->get_environment(p_source.position);
 		if (update_culling(dt))
 		{
@@ -297,7 +297,7 @@ BOOL CSoundRender_Emitter::update_culling(float dt)
 		float fade_scale = bStopping || (att * p_source.base_volume * p_source.volume * (owner_data->s_type == st_Effect
 			                                                                                 ? psSoundVEffects *
 			                                                                                 psSoundVFactor
-			                                                                                 : psSoundVMusic) <
+			                                                                                 : psSoundVMusic * psSoundVMusicFactor) <
 			                   psSoundCull)
 			                   ? -1.f
 			                   : 1.f;
@@ -313,7 +313,7 @@ BOOL CSoundRender_Emitter::update_culling(float dt)
 	clamp(fade_volume, 0.f, 1.f);
 	// Update smoothing
 	smooth_volume = .9f * smooth_volume + .1f * (p_source.base_volume * p_source.volume * (
-			owner_data->s_type == st_Effect ? psSoundVEffects * psSoundVFactor : psSoundVMusic) * occluder_volume *
+			owner_data->s_type == st_Effect ? psSoundVEffects * psSoundVFactor : psSoundVMusic * psSoundVMusicFactor) * occluder_volume *
 		fade_volume);
 	if (smooth_volume < psSoundCull) return FALSE; // allow volume to go up
 	// Here we has enought "PRIORITY" to be soundable
@@ -333,6 +333,9 @@ float CSoundRender_Emitter::priority()
 
 void CSoundRender_Emitter::update_environment(float dt)
 {
-	if (bMoved) e_target = *SoundRender->get_environment(p_source.position);
+	if (bMoved) {
+		e_target = *SoundRender->get_environment(p_source.position);
+		p_source.update_velocity(dt);
+	}
 	e_current.lerp(e_current, e_target, dt);
 }
diff --git a/src/xrSound/SoundRender_TargetA.cpp b/src/xrSound/SoundRender_TargetA.cpp
index ef418a7..f3bcdab 100644
--- a/src/xrSound/SoundRender_TargetA.cpp
+++ b/src/xrSound/SoundRender_TargetA.cpp
@@ -154,6 +154,9 @@ void CSoundRender_TargetA::fill_parameters()
 	A_CHK(alSource3f(pSource, AL_POSITION, m_pEmitter->p_source.position.x,m_pEmitter->p_source.position.y,-m_pEmitter->
 		p_source.position.z));
 
+	VERIFY2(m_pEmitter, SE->source()->file_name());
+	A_CHK(alSource3f(pSource, AL_VELOCITY, m_pEmitter->p_source.velocity.x, m_pEmitter->p_source.velocity.y, -m_pEmitter->p_source.velocity.z));
+
 	VERIFY2(m_pEmitter, SE->source()->file_name());
 	A_CHK(alSourcei (pSource, AL_SOURCE_RELATIVE, m_pEmitter->b2D));
 
diff --git a/src/xrXMLParser/xrXMLParser.cpp b/src/xrXMLParser/xrXMLParser.cpp
index 1d69c77..1cde914 100644
--- a/src/xrXMLParser/xrXMLParser.cpp
+++ b/src/xrXMLParser/xrXMLParser.cpp
@@ -3,6 +3,7 @@
 
 #include "xrXMLParser.h"
 
+extern void XMLLuaCallback(CXml &m_xml, LPCSTR xml_string);
 
 XRXMLPARSER_API CXml::CXml()
 	: m_root(NULL),
@@ -138,6 +139,21 @@ void CXml::Load(LPCSTR path, LPCSTR xml_filename)
 		R_ASSERT2(false, str);
 	}
 
+	m_root = m_Doc.FirstChildElement();
+	XMLLuaCallback(*this, (LPCSTR)W.pointer());
+}
+
+void CXml::LoadFromString(LPCSTR xml_string)
+{
+	ClearInternal();
+	m_Doc.Parse(&m_Doc, xml_string);
+	if (m_Doc.Error())
+	{
+		string1024 str;
+		xr_sprintf(str, "XML file:%s value:%s errDescr:%s", m_xml_file_name, m_Doc.Value(), m_Doc.ErrorDesc());
+		R_ASSERT2(false, str);
+	}
+
 	m_root = m_Doc.FirstChildElement();
 }
 
diff --git a/src/xrXMLParser/xrXMLParser.h b/src/xrXMLParser/xrXMLParser.h
index 3a13303..fcdc789 100644
--- a/src/xrXMLParser/xrXMLParser.h
+++ b/src/xrXMLParser/xrXMLParser.h
@@ -31,7 +31,7 @@ public:
 	void ClearInternal();
 
 	void Load(LPCSTR path_alias, LPCSTR path, LPCSTR xml_filename);
-
+	void LoadFromString(LPCSTR xml_string);
 
 	//чтение элементов
 	LPCSTR Read(LPCSTR path, int index, LPCSTR default_str_val);
