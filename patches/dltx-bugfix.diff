diff --git a/src/Layers/xrRender/SkeletonAnimated.cpp b/src/Layers/xrRender/SkeletonAnimated.cpp
index a2b6c3f..d5ac60e 100644
--- a/src/Layers/xrRender/SkeletonAnimated.cpp
+++ b/src/Layers/xrRender/SkeletonAnimated.cpp
@@ -11,6 +11,7 @@
 #include	"../../xrcore/dump_string.h"
 #endif
 extern int psSkeletonUpdate;
+extern shared_str current_player_hud_sect;
 using namespace animation;
 //////////////////////////////////////////////////////////////////////////
 // BoneInstance methods
@@ -781,7 +782,7 @@ void CKinematicsAnimated::Load(const char* N, IReader* data, u32 dwFlags)
 		if (!FS.exist(fn, "$level$", _path))
 		{
 			if (!FS.exist(fn, "$game_meshes$", _path))
-				Debug.fatal(DEBUG_INFO, "Can't find motion file '%s'.", _path);
+				Debug.fatal(DEBUG_INFO, "Can't find motion file '%s'\nsection '%s'\nmodel '%s'", _path, current_player_hud_sect.c_str(), N);
 		}
 
 		// Check compatibility
@@ -798,7 +799,7 @@ void CKinematicsAnimated::Load(const char* N, IReader* data, u32 dwFlags)
 		else
 		{
 			m_Motions.pop_back();
-			Msg("! error in model [%s]. Unable to load motion file '%s'.", N, _path);
+			Msg("! error in model [%s]. Unable to load motion file '%s', section '%s'.", N, _path, current_player_hud_sect.c_str());
 		}
 	};
 
@@ -808,7 +809,7 @@ void CKinematicsAnimated::Load(const char* N, IReader* data, u32 dwFlags)
 		string_path items_nm;
 		data->r_stringZ(items_nm, sizeof(items_nm));
 		u32 set_cnt = _GetItemCount(items_nm);
-		R_ASSERT(set_cnt<MAX_ANIM_SLOT);
+		R_ASSERT2(set_cnt<MAX_ANIM_SLOT, make_string("section '%s'\nmodel '%s'", current_player_hud_sect.c_str(), N).c_str());
 		m_Motions.reserve(set_cnt);
 		string_path nm;
 		for (u32 k = 0; k < set_cnt; ++k)
@@ -853,7 +854,7 @@ void CKinematicsAnimated::Load(const char* N, IReader* data, u32 dwFlags)
 		m_Motions.back().motions.create(nm, data, bones);
 	}
 
-	R_ASSERT(m_Motions.size());
+	R_ASSERT2(m_Motions.size(), make_string("section '%s'\nmodel '%s'", current_player_hud_sect.c_str(), N).c_str());
 
 	m_Partition = m_Motions[0].motions.partition();
 	m_Partition->load(this, N);
diff --git a/src/Layers/xrRender/WallmarksEngine.cpp b/src/Layers/xrRender/WallmarksEngine.cpp
index d0592f8..141f50c 100644
--- a/src/Layers/xrRender/WallmarksEngine.cpp
+++ b/src/Layers/xrRender/WallmarksEngine.cpp
@@ -34,7 +34,7 @@ namespace WallmarksEngine
 const float W_DIST_FADE = 15.f;
 const float W_DIST_FADE_SQR = W_DIST_FADE * W_DIST_FADE;
 const float I_DIST_FADE_SQR = 1.f / W_DIST_FADE_SQR;
-const int MAX_TRIS = 1024;
+const int MAX_TRIS = 1024 * 16;
 
 IC bool operator ==(const CWallmarksEngine::wm_slot* slot, const ref_shader& shader) { return slot->shader == shader; }
 
diff --git a/src/xrCore/Xr_ini.cpp b/src/xrCore/Xr_ini.cpp
index 3f5ac84..cce213c 100644
--- a/src/xrCore/Xr_ini.cpp
+++ b/src/xrCore/Xr_ini.cpp
@@ -3,6 +3,14 @@
 
 #include "fs_internal.h"
 
+#include <functional>
+#include <regex>
+#include <unordered_map>
+#include <unordered_set>
+#include <vector>
+#include <algorithm>
+#include "mezz_stringbuffer.h"
+
 XRCORE_API CInifile const* pSettings = NULL;
 XRCORE_API CInifile const* pSettingsAuth = NULL;
 
@@ -177,8 +185,19 @@ CInifile::~CInifile()
 		xr_delete(*I);
 }
 
+std::unordered_map<std::string, std::vector<CInifile::Item>> OverrideModifyListData;
+
 static void insert_item(CInifile::Sect* tgt, const CInifile::Item& I)
 {
+	// demonized
+	// DLTX: add or remove item from the section parameter if it has a structure of "name = item1, item2, item3, ..."
+	// >name = item will add item to the list
+	// <name = item will remove item from the list
+	if (*I.first && (I.first.c_str()[0] == '<' || I.first.c_str()[0] == '>')) {
+		OverrideModifyListData[std::string(tgt->Name.c_str())].push_back(I);
+		return;
+	}
+
 	CInifile::SectIt_ sect_it = std::lower_bound(tgt->Data.begin(), tgt->Data.end(), *I.first, item_pred);
 	if (sect_it != tgt->Data.end() && sect_it->first.equal(I.first))
 	{
@@ -210,212 +229,750 @@ void CInifile::Load(IReader* F, LPCSTR path
 )
 {
 	R_ASSERT(F);
-	Sect* Current = 0;
-	string4096 str;
-	string4096 str2;
 
-	BOOL bInsideSTR = FALSE;
+	std::string DLTX_DELETE = "DLTX_DELETE";
 
-	while (!F->eof())
+	std::function<void(std::vector<std::string>*, std::vector<std::string>*, bool)> MergeParentSet = [](std::vector<std::string>* ParentsBase, std::vector<std::string>* ParentsOverride, bool bIncludeRemovers)
 	{
-		F->r_string(str, sizeof(str));
-		_Trim(str);
-		LPSTR comm = strchr(str, ';');
-		LPSTR comm_1 = strchr(str, '/');
-
-		if (comm_1 && (*(comm_1 + 1) == '/') && ((!comm) || (comm && (comm_1 < comm))))
+		for (std::string CurrentParent : *ParentsOverride)
 		{
-			comm = comm_1;
+			bool bIsParentRemoval = CurrentParent[0] == '!';
+
+			std::string StaleParentString = (!bIsParentRemoval ? "!" : "") + CurrentParent.substr(1);
+
+			for (auto It = ParentsBase->rbegin(); It != ParentsBase->rend(); It++)
+			{
+				if (*It == StaleParentString)
+				{
+					ParentsBase->erase(std::next(It).base());
+				}
+			}
+
+			if (bIncludeRemovers || !bIsParentRemoval)
+			{
+				ParentsBase->insert(ParentsBase->end(), CurrentParent);
+			}
 		}
+	};
+
+	string_path currentFileName;
+	std::unordered_map<std::string, std::unordered_map<std::string, bool>> OverrideToFilename;
+	std::unordered_map<std::string, std::string> SectionToFilename;
+
+	std::function<void
+		(
+		IReader*,
+		LPCSTR,
+		std::unordered_map<std::string, Sect>*,
+		std::unordered_map<std::string, std::vector<std::string>>*,
+		BOOL,
+		BOOL
+		)
+	> LTXLoad = [&]
+		(
+		IReader* F,
+		LPCSTR path,
+		std::unordered_map<std::string, Sect>* OutputData,
+		std::unordered_map<std::string, std::vector<std::string>>* ParentDataMap,
+		BOOL bOverridesOnly,
+		BOOL bIsRootFile
+		)
+	{
+		Sect* Current = 0;
+		MezzStringBuffer str;
+		MezzStringBuffer str2;
 
-#ifdef DEBUG
-        LPSTR comment = 0;
-#endif
-		if (comm)
+		BOOL bInsideSTR = FALSE;
+
+		BOOL bIsCurrentSectionOverride = FALSE;
+		BOOL bHasLoadedModFiles = FALSE;
+
+		std::function<std::vector<std::string>*(std::string)> GetParentStrings = [&](std::string SectionName)
 		{
-			//."bla-bla-bla;nah-nah-nah"
-			char quot = '"';
-			bool in_quot = false;
+			auto It = ParentDataMap->find(SectionName);
 
-			LPCSTR q1 = strchr(str, quot);
-			if (q1 && q1 < comm)
+			if (It == ParentDataMap->end())
 			{
-				LPCSTR q2 = strchr(++q1, quot);
-				if (q2 && q2 > comm)
-					in_quot = true;
+				ParentDataMap->insert(std::pair<std::string, std::vector<std::string>>(SectionName, std::vector<std::string>()));
+
+				It = ParentDataMap->find(SectionName);
 			}
 
-			if (!in_quot)
+			return &It->second;
+		};
+
+		auto GetParentsSetFromString = [&](const char* ParentString)
+		{
+			std::vector<std::string> ParentSet = std::vector<std::string>();
+
+			u32 ItemCount = _GetItemCount(ParentString);
+
+			for (u32 i = 0; i < ItemCount; i++)
 			{
-				*comm = 0;
-#ifdef DEBUG
-                comment = comm + 1;
-#endif
+				_GetItem(ParentString, i, str2, str2.GetSize());
+
+				ParentSet.insert(ParentSet.end(), str2.GetBuffer());
 			}
-		}
 
+			return ParentSet;
+		};
+
+		auto GetRegexMatch = [](std::string InputString, std::string PatternString)
+		{
+			std::regex Pattern = std::regex(PatternString);
+			std::smatch MatchResult;
+
+			std::regex_search(InputString, MatchResult, Pattern);
+
+			if (MatchResult.begin() == MatchResult.end())
+			{
+				return std::string();
+			}
+
+			return MatchResult.begin()->str();
+		};
+
+		auto IsFullRegexMatch = [](std::string InputString, std::string PatternString)
+		{
+			return std::regex_match(InputString, std::regex(PatternString));
+		};
 
-		if (str[0] && (str[0] == '#') && strstr(str, "#include")) //handle includes
+		const auto loadFile = [&, LTXLoad](const string_path _fn, const string_path inc_path, const string_path name)
 		{
-			string_path inc_name;
-			R_ASSERT(path&&path[0]);
-			if (_GetItem(str, 1, inc_name, '"'))
+			if (!allow_include_func || allow_include_func(_fn))
 			{
-				string_path fn, inc_path, folder;
-				strconcat(sizeof(fn), fn, path, inc_name);
-				_splitpath(fn, inc_path, folder, 0, 0);
-				xr_strcat(inc_path, sizeof(inc_path), folder);
+				IReader* I = FS.r_open(_fn);
+				R_ASSERT3(I, "Can't find include file:", name);
+
+				strcpy(currentFileName, name);
 
-				const auto loadFile = [&](const string_path _fn, const string_path name)
+				LTXLoad(I, inc_path, OutputData, ParentDataMap, bOverridesOnly, false);
+
+				FS.r_close(I);
+			}
+		};
+
+		auto StashCurrentSection = [&]()
+		{
+			if (Current && bIsCurrentSectionOverride == bOverridesOnly)
+			{
+				//store previous section
+				auto SectIt = OutputData->find(std::string(Current->Name.c_str()));
+				if (SectIt != OutputData->end())
 				{
-					if (!allow_include_func || allow_include_func(_fn))
+					if (!bIsCurrentSectionOverride)
 					{
-						IReader* I = FS.r_open(_fn);
-						R_ASSERT3(I, "Can't find include file:", name);
-						Load(I, inc_path, allow_include_func);
-						FS.r_close(I);
-					}
-				};
 
-				if (strstr(inc_name, "*.ltx"))
-				{
-					FS_FileSet fset;
-					FS.file_list(fset, inc_path, FS_ListFiles, inc_name);
+						Debug.fatal(DEBUG_INFO, "Duplicate section '%s' wasn't marked as an override.\n\nOverride section by prefixing it with '!' (![%s]) or give it a unique name.\n\nCheck this file and its DLTX mods:\n\"%s\",\nfile with section \"%s\",\nfile with duplicate \"%s\"", *Current->Name, *Current->Name, m_file_name, SectionToFilename[std::string(Current->Name.c_str())].c_str(), currentFileName);
+					}
 
-					for (FS_FileSet::iterator it = fset.begin(); it != fset.end(); it++)
+					//Overwrite existing override data
+					for (Item CurrentItem : Current->Data)
 					{
-						LPCSTR _name = it->name.c_str();
-						string_path _fn;
-						strconcat(sizeof(_fn), _fn, inc_path, _name);
-						loadFile(_fn, _name);
+						insert_item(&SectIt->second, CurrentItem);
 					}
+
+					OverrideToFilename[SectIt->first][currentFileName] = true;
 				}
 				else
-					loadFile(fn, inc_name);
+				{
+					OutputData->emplace(std::pair<std::string, Sect>(std::string(Current->Name.c_str()), *Current));
+					OverrideToFilename[std::string(Current->Name.c_str())][currentFileName] = true;
+					SectionToFilename[std::string(Current->Name.c_str())] = currentFileName;
+				}
 			}
-		}
-		else if (str[0] && (str[0] == '[')) //new section ?
+
+			Current = NULL;
+		};
+
+		std::unordered_set<std::string> sectionsMarkedForCreate;
+
+		while (!F->eof() || (bIsRootFile && !bHasLoadedModFiles))
 		{
-			// insert previous filled section
-			if (Current)
+			if (!F->eof())
 			{
-				//store previous section
-				RootIt I = std::lower_bound(DATA.begin(), DATA.end(), *Current->Name, sect_pred);
-				if ((I != DATA.end()) && ((*I)->Name == Current->Name))
-					Debug.fatal(DEBUG_INFO, "Duplicate section '%s' found.", *Current->Name);
-				DATA.insert(I, Current);
+				F->r_string(str, str.GetSize());
+				_Trim(str);
+			}
+			else if (!bHasLoadedModFiles && bIsRootFile)
+			{
+				StashCurrentSection();
+				bHasLoadedModFiles = TRUE;
+
+				if (!m_file_name[0])
+				{
+					continue;
+				}
+
+				//Assemble paths and filename
+				MezzStringBuffer split_drive;
+				MezzStringBuffer split_dir;
+				MezzStringBuffer split_name;
+
+				_splitpath_s(m_file_name, split_drive, split_drive.GetSize(), split_dir, split_dir.GetSize(), split_name, split_name.GetSize(), NULL, 0);
+
+				std::string FilePath = std::string(split_drive) + std::string(split_dir);
+				std::string FileName = split_name;
+
+				//Collect all files that could potentially be confused as a root file by our mod files
+				FS_FileSet AmbiguousFiles;
+				FS.file_list(AmbiguousFiles, FilePath.c_str(), FS_ListFiles, (FileName + "_*.ltx").c_str());
+
+				//Collect all matching mod files
+				FS_FileSet ModFiles;
+				FS.file_list(ModFiles, FilePath.c_str(), FS_ListFiles, ("mod_" + FileName + "_*.ltx").c_str());
+
+				for (auto It = ModFiles.begin(); It != ModFiles.end(); ++It)
+				{
+					std::string ModFileName = It->name.c_str();
+
+					//Determine if we should load this mod file, or if it's meant for a different root file
+					BOOL bIsModfileMeantForMe = [&]()
+					{
+						for (auto It2 = AmbiguousFiles.begin(); It2 != AmbiguousFiles.end(); ++It2)
+						{
+							std::string AmbiguousFileName = GetRegexMatch(It2->name.c_str(), "^.+(?=.ltx$)");
+							std::string AmbiguousFileMatchPattern = std::string("mod_") + AmbiguousFileName + std::string("_.+.ltx");
+
+							if (IsFullRegexMatch(ModFileName, AmbiguousFileMatchPattern))
+							{
+								return false;
+							}
+						}
+
+						return true;
+					}();
+
+					if (!bIsModfileMeantForMe)
+					{
+						continue;
+					}
+
+					loadFile((FilePath + ModFileName).c_str(), FilePath.c_str(), ModFileName.c_str());
+				}
+
+				continue;
+			}
+
+			LPSTR comm = strchr(str, ';');
+			LPSTR comm_1 = strchr(str, '/');
+
+			if (comm_1 && (*(comm_1 + 1) == '/') && ((!comm) || (comm && (comm_1 < comm))))
+			{
+				comm = comm_1;
+			}
+
+#ifdef DEBUG
+			LPSTR comment = 0;
+#endif
+			if (comm)
+			{
+				//."bla-bla-bla;nah-nah-nah"
+				char quot = '"';
+				bool in_quot = false;
+
+				LPCSTR q1 = strchr(str, quot);
+				if (q1 && q1 < comm)
+				{
+					LPCSTR q2 = strchr(++q1, quot);
+					if (q2 && q2 > comm)
+						in_quot = true;
+				}
+
+				if (!in_quot)
+				{
+					*comm = 0;
+#ifdef DEBUG
+					comment = comm + 1;
+#endif
+				}
 			}
-			Current = xr_new<Sect>();
-			Current->Name = 0;
-			// start new section
-			R_ASSERT3(strchr(str, ']'), "Bad ini section found: ", str);
-			LPCSTR inherited_names = strstr(str, "]:");
-			if (0 != inherited_names)
+
+			_Trim(str);
+
+			auto isOverrideSection = [](char* str) {
+				return strstr(str, "![") == &str[0];
+			};
+
+			auto isSafeOverrideSection = [](char* str) {
+				return strstr(str, "@[") == &str[0];
+			};
+
+			auto isModSection = [isOverrideSection, isSafeOverrideSection](char* str) {
+				return isOverrideSection(str) || isSafeOverrideSection(str);
+			};
+
+			if (str[0] && (str[0] == '#') && strstr(str, "#include")) //handle includes
 			{
-				VERIFY2(m_flags.test(eReadOnly), "Allow for readonly mode only.");
-				inherited_names += 2;
-				u32 cnt = _GetItemCount(inherited_names);
-				u32 total_count = 0;
-				u32 k = 0;
-				for (k = 0; k < cnt; ++k)
+				string_path inc_name;
+				R_ASSERT(path && path[0]);
+				if (_GetItem(str, 1, inc_name, '"'))
 				{
-					string512 tmp;
-					_GetItem(inherited_names, k, tmp);
-					Sect& inherited_section = r_section(tmp);
-					total_count += inherited_section.Data.size();
+					string_path fn, inc_path, folder;
+					strconcat(sizeof(fn), fn, path, inc_name);
+					_splitpath(fn, inc_path, folder, 0, 0);
+					xr_strcat(inc_path, sizeof(inc_path), folder);
+
+
+					if (strstr(inc_name, "*.ltx"))
+					{
+						FS_FileSet fset;
+						FS.file_list(fset, inc_path, FS_ListFiles, inc_name);
+
+						for (FS_FileSet::iterator it = fset.begin(); it != fset.end(); it++)
+						{
+							LPCSTR _name = it->name.c_str();
+							string_path _fn;
+							strconcat(sizeof(_fn), _fn, inc_path, _name);
+							loadFile(_fn, inc_path, _name);
+						}
+					}
+					else
+						loadFile(fn, inc_path, inc_name);
 				}
 
-				Current->Data.reserve(Current->Data.size() + total_count);
+				continue;
+			}
+			else if (str[0] && strstr(str, "!![") == &str[0])	//Section delete
+			{
+				StashCurrentSection();
 
-				for (k = 0; k < cnt; ++k)
+				if (!bOverridesOnly)
 				{
-					string512 tmp;
-					_GetItem(inherited_names, k, tmp);
-					Sect& inherited_section = r_section(tmp);
-					for (SectIt_ it = inherited_section.Data.begin(); it != inherited_section.Data.end(); it++)
-						insert_item(Current, *it);
+					continue;
 				}
+
+				Current = xr_new<Sect>();
+				*strchr(str, ']') = 0;
+				Current->Name = strlwr(&str[3]);
+
+				bIsCurrentSectionOverride = true;
+
+				Item DeleteItem;
+				DeleteItem.first = DLTX_DELETE.c_str();
+				DeleteItem.second = "";
+
+				insert_item(Current, DeleteItem);
+
+				continue;
 			}
-			*strchr(str, ']') = 0;
-			Current->Name = strlwr(str + 1);
-		}
-		else // name = value
-		{
-			if (Current)
+			else if ((str[0] && (str[0] == '[')) || isModSection(str)) //new section ?
+			{
+				// insert previous filled section
+				StashCurrentSection();
+
+				u32 SectionNameStartPos = (isModSection(str) ? 2 : 1);
+				std::string SecName = std::string(str).substr(SectionNameStartPos, strchr(str, ']') - str - SectionNameStartPos).c_str();
+				for (auto i = SecName.begin(); i != SecName.end(); ++i)
+				{
+					*i = tolower(*i);
+				}
+				
+				if (isOverrideSection(str)) { //Used to detect bad or unintended overrides
+					bIsCurrentSectionOverride = true;
+				} else if (isSafeOverrideSection(str)) { // Create section if it doesnt exist, override if it does
+					bIsCurrentSectionOverride = true;
+					if (bOverridesOnly) {
+						// Msg("using @[, override existing section %s", SecName.c_str());
+					} else {
+						auto SectIt = OutputData->find(SecName);
+						if (SectIt != OutputData->end()) {
+							// Msg("using @[, override existing section %s", SecName.c_str());
+						} else {
+							// Msg("using @[, create new section %s", SecName.c_str());
+							sectionsMarkedForCreate.insert(SecName);
+						}
+					}
+				} else {
+					bIsCurrentSectionOverride = false;
+				}
+
+				Current = xr_new<Sect>();
+				Current->Name = SecName.c_str();
+
+				// start new section
+				R_ASSERT3(strchr(str, ']'), "Bad ini section found: ", str);
+
+				if (bIsCurrentSectionOverride == bOverridesOnly)
+				{
+					LPCSTR inherited_names = strstr(str, "]:");
+					if (0 != inherited_names)
+					{
+						VERIFY2(m_flags.test(eReadOnly), "Allow for readonly mode only.");
+						inherited_names += 2;
+
+						std::vector<std::string> CurrentParents = GetParentsSetFromString(inherited_names);
+						std::vector<std::string>* SectionParents = GetParentStrings(Current->Name.c_str());
+
+						MergeParentSet(SectionParents, &CurrentParents, true);
+					}
+				}
+
+				continue;
+			}
+			else // name = value
 			{
-				string4096 value_raw;
-				char* name = str;
-				char* t = strchr(name, '=');
-				if (t)
+				if (Current && bIsCurrentSectionOverride == bOverridesOnly)
 				{
-					*t = 0;
-					_Trim(name);
-					++t;
-					xr_strcpy(value_raw, sizeof(value_raw), t);
-					bInsideSTR = _parse(str2, value_raw);
-					if (bInsideSTR) //multiline str value
+					bool bIsDelete = str[0] == '!';
+
+					MezzStringBuffer value_raw;
+					char* name = (char*) (str + (bIsDelete ? 1 : 0));
+					char* t = strchr(name, '=');
+					if (t)
 					{
-						while (bInsideSTR)
+						*t = 0;
+						_Trim(name);
+						++t;
+						xr_strcpy(value_raw, value_raw.GetSize(), t);
+						bInsideSTR = _parse(str2, value_raw);
+						if (bInsideSTR) //multiline str value
 						{
-							xr_strcat(value_raw, sizeof(value_raw), "\r\n");
-							string4096 str_add_raw;
-							F->r_string(str_add_raw, sizeof(str_add_raw));
-							R_ASSERT2(
-								xr_strlen(value_raw) + xr_strlen(str_add_raw) < sizeof(value_raw),
-								make_string(
-									"Incorrect inifile format: section[%s], variable[%s]. Odd number of quotes (\") found, but should be even."
-									,
-									Current->Name.c_str(),
-									name
-								)
-							);
-							xr_strcat(value_raw, sizeof(value_raw), str_add_raw);
-							bInsideSTR = _parse(str2, value_raw);
-							if (bInsideSTR)
+							while (bInsideSTR)
 							{
-								if (is_empty_line_now(F))
-									xr_strcat(value_raw, sizeof(value_raw), "\r\n");
+								xr_strcat(value_raw, value_raw.GetSize(), "\r\n");
+								MezzStringBuffer str_add_raw;
+								F->r_string(str_add_raw, str_add_raw.GetSize());
+								R_ASSERT2(
+									xr_strlen(value_raw) + xr_strlen(str_add_raw) < value_raw.GetSize(),
+									make_string(
+										"Incorrect inifile format: section[%s], variable[%s]. Odd number of quotes (\") found, but should be even."
+										,
+										Current->Name.c_str(),
+										name
+									)
+								);
+								xr_strcat(value_raw, value_raw.GetSize(), str_add_raw);
+								bInsideSTR = _parse(str2, value_raw);
+								if (bInsideSTR)
+								{
+									if (is_empty_line_now(F))
+										xr_strcat(value_raw, value_raw.GetSize(), "\r\n");
+								}
 							}
 						}
 					}
+					else
+					{
+						_Trim(name);
+						str2[0] = 0;
+					}
+
+					Item I;
+					I.first = (name[0] ? name : NULL);
+					I.second = bIsDelete ? DLTX_DELETE.c_str() : (str2[0] ? str2.GetBuffer() : NULL);
+
+					if (*I.first || *I.second)
+					{
+						insert_item(Current, I);
+					}
+				}
+
+				continue;
+			}
+		}
+
+		StashCurrentSection();
+
+		// Create empty sections that were marked with @[ and weren't defined normally
+		if (!bOverridesOnly) {
+			for (auto& SecName : sectionsMarkedForCreate) {
+				auto SectIt = OutputData->find(SecName);
+				if (SectIt == OutputData->end()) {
+					// Msg("section %s does not exist but was marked as @[, creating", SecName.c_str());
+					Current = xr_new<Sect>();
+					Current->Name = SecName.c_str();
+					OutputData->emplace(std::pair<std::string, Sect>(std::string(Current->Name.c_str()), *Current));
+					OverrideToFilename[std::string(Current->Name.c_str())][currentFileName] = true;
+					SectionToFilename[std::string(Current->Name.c_str())] = currentFileName;
+					Current = NULL;
+				}
+			}
+		}
+	};
+
+	std::unordered_map<std::string, std::vector<std::string>> BaseParentDataMap;
+	std::unordered_map<std::string, Sect> BaseData;
+
+	std::unordered_map<std::string, std::vector<std::string>> OverrideParentDataMap;
+	std::unordered_map<std::string, Sect> OverrideData;
+
+	std::unordered_map<std::string, Sect> FinalData;
+
+	std::unordered_set<std::string> FinalizedSections;
+
+	enum InsertType
+	{
+		Override,
+		Base,
+		Parent
+	};
+
+	std::function<void(std::string, std::vector<std::string>*)> EvaluateSection = [&](std::string SectionName, std::vector<std::string>* PreviousEvaluations)
+	{
+		if (FinalizedSections.find(SectionName) != FinalizedSections.end())
+		{
+			return;
+		}
+
+		PreviousEvaluations->insert(PreviousEvaluations->end(), SectionName);
+
+		std::vector<std::string>* BaseParents = &BaseParentDataMap.find(SectionName)->second;
+		std::vector<std::string>* OverrideParents = &OverrideParentDataMap.find(SectionName)->second;
+
+		BOOL bDeleteSectionIfEmpty = FALSE;
+
+		MergeParentSet(BaseParents, OverrideParents, false);
+
+		std::pair<std::string, Sect> CurrentSecPair = std::pair<std::string, Sect>(SectionName, Sect());
+		Sect* CurrentSect = &CurrentSecPair.second;
+		CurrentSect->Name = SectionName.c_str();
+
+		auto IsStringDLTXDelete = [&](shared_str str)
+		{
+			const char* RawString = str.c_str();
+
+			return RawString && std::string(RawString) == DLTX_DELETE;
+		};
+
+		auto InsertItemWithDelete = [&](Item CurrentItem, InsertType Type)
+		{
+			if (IsStringDLTXDelete(CurrentItem.first))
+			{
+				//Delete section
+				bDeleteSectionIfEmpty = TRUE;
+			}
+			else
+			{
+				//Insert item if variable isn't already set
+				CInifile::SectIt_ sect_it = std::lower_bound(CurrentSect->Data.begin(), CurrentSect->Data.end(), *CurrentItem.first, item_pred);
+				if (sect_it != CurrentSect->Data.end() && sect_it->first.equal(CurrentItem.first))
+				{
+					bool bShouldInsert = [&]()
+					{
+						switch (Type)
+						{
+						case InsertType::Override:		return true;
+						case InsertType::Base:			return false;
+						case InsertType::Parent:		return IsStringDLTXDelete(sect_it->second);
+						}
+					}();
+
+					if (bShouldInsert)
+					{
+						sect_it->second = CurrentItem.second;
+					}
 				}
 				else
 				{
-					_Trim(name);
-					str2[0] = 0;
+					CurrentSect->Data.insert(sect_it, CurrentItem);
 				}
+			}
+		};
 
-				Item I;
-				I.first = (name[0] ? name : NULL);
-				I.second = (str2[0] ? str2 : NULL);
-				//#ifdef DEBUG
-				// I.comment = m_flags.test(eReadOnly)?0:comment;
-				//#endif
+		//Insert variables of own data
+		auto InsertData = [&](std::unordered_map<std::string, Sect>* Data, BOOL bIsBase)
+		{
+			auto It = Data->find(SectionName);
 
-				if (m_flags.test(eReadOnly))
+			if (It != Data->end())
+			{
+				Sect* DataSection = &It->second;
+				for (Item CurrentItem : DataSection->Data)
 				{
-					if (*I.first) insert_item(Current, I);
+					InsertItemWithDelete(CurrentItem, bIsBase ? Base : Override);
 				}
-				else
+
+				if (!bIsBase)
 				{
-					if (
-						*I.first
-						|| *I.second
-							//#ifdef DEBUG
-							// || *I.comment
-							//#endif
-					)
-						insert_item(Current, I);
+					Data->erase(It);
+				}
+			}
+		};
+
+		InsertData(&OverrideData, false);
+		InsertData(&BaseData, true);
+
+		//Insert variables from parents
+		for (auto It = BaseParents->rbegin(); It != BaseParents->rend(); ++It)
+		{
+			std::string ParentSectionName = *(It.base() - 1);
+
+			for (auto It = PreviousEvaluations->begin(); It != PreviousEvaluations->end(); ++It)
+			{
+				if (ParentSectionName == *It)
+				{
+					Debug.fatal(DEBUG_INFO, "Section '%s' has cyclical dependencies. Ensure that sections with parents don't inherit in a loop. Check this file and its DLTX mods: %s, mod file %s", ParentSectionName.c_str(), m_file_name, currentFileName);
+				}
+			}
+
+			EvaluateSection(ParentSectionName, PreviousEvaluations);
+
+			auto ParentIt = FinalData.find(ParentSectionName);
+
+			if (ParentIt == FinalData.end())
+			{
+				Debug.fatal(DEBUG_INFO, "Section '%s' inherits from non-existent section '%s'. Check this file and its DLTX mods: %s, mod file %s", SectionName.c_str(), ParentSectionName.c_str(), m_file_name, currentFileName);
+			}
+
+			Sect* ParentSec = &ParentIt->second;
+
+			for (Item CurrentItem : ParentSec->Data)
+			{
+				InsertItemWithDelete(CurrentItem, Parent);
+			}
+		}
+
+		//Delete entries that are still marked DLTX_DELETE
+		for (auto It = CurrentSect->Data.rbegin(); It != CurrentSect->Data.rend(); ++It)
+		{
+			if (IsStringDLTXDelete(It->second))
+			{
+				CurrentSect->Data.erase(It.base() - 1);
+			}
+		}
+
+		// If there is data to modify parameters lists
+		if (OverrideModifyListData.find(std::string(CurrentSect->Name.c_str())) != OverrideModifyListData.end()) {
+			for (auto It = OverrideModifyListData[std::string(CurrentSect->Name.c_str())].begin(); It != OverrideModifyListData[std::string(CurrentSect->Name.c_str())].end(); ++It) {
+				CInifile::Item &I = *It;
+
+				// If section exists with item list, split list and perform operation
+				char dltx_listmode = I.first[0];
+				I.first = I.first.c_str() + 1;
+
+				CInifile::SectIt_ sect_it = std::lower_bound(CurrentSect->Data.begin(), CurrentSect->Data.end(), *I.first, item_pred);
+				if (sect_it != CurrentSect->Data.end() && sect_it->first.equal(I.first)) {
+
+					//Msg("%s has dltx_listmode %s", I.first.c_str(), std::string(1, dltx_listmode).c_str());
+
+					if (dltx_listmode && sect_it->second != NULL) {
+						// Split list 
+						auto split_list = [](const std::string items, const std::string delimiter = ",") {
+							std::string i = items;
+							std::vector<std::string> vec;
+							size_t pos = 0;
+							std::string token;
+							while ((pos = i.find(delimiter)) != std::string::npos) {
+								token = i.substr(0, pos);
+								vec.push_back(token);
+								i.erase(0, pos + delimiter.length());
+							}
+							vec.push_back(i);
+
+							auto trim = [](std::string &s, const char* t = " \t\n\r\f\v") {
+								s.erase(s.find_last_not_of(t) + 1);
+								s.erase(0, s.find_first_not_of(t));
+							};
+							for (auto &item : vec) {
+								trim(item);
+							}
+							return vec;
+						};
+						std::vector<std::string> sect_it_items_vec = split_list(sect_it->second.c_str());
+						std::vector<std::string> I_items_vec = split_list(I.second.c_str());
+
+						// Add or remove to the list
+						auto find_and_store_index = [](const std::vector<std::string> &items_vec, const std::string item, int &vec_index) {
+							auto it = std::find(items_vec.begin(), items_vec.end(), item);
+							if (it != items_vec.end()) {
+								vec_index = it - items_vec.begin();
+								return true;
+							}
+							else {
+								vec_index = -1;
+								return false;
+							}
+						};
+						int vec_index = -1;
+						for (const auto &item : I_items_vec) {
+							if (dltx_listmode == '>') {
+								sect_it_items_vec.push_back(item);
+							}
+							else if (dltx_listmode == '<') {
+								while (find_and_store_index(sect_it_items_vec, item, vec_index)) {
+									sect_it_items_vec.erase(sect_it_items_vec.begin() + vec_index);
+								}
+							}
+						}
+
+						// Store result back
+						auto join_list = [](const std::vector<std::string> &items_vec, const std::string delimiter = ",") {
+							std::string ret;
+							for (const auto &i : items_vec) {
+								if (!ret.empty()) {
+									ret += delimiter;
+								}
+								ret += i;
+							}
+							return ret;
+						};
+
+						/*std::string c(1, dltx_listmode);
+						Msg("%s has dltx_listmode %s, %s items", I.first.c_str(), c.c_str(), dltx_listmode == '>' ? "adding" : "removing");
+						Msg("old %s", sect_it->second.c_str());
+						Msg("new %s", join_list(sect_it_items_vec).c_str());*/
+
+						sect_it->second = join_list(sect_it_items_vec, ",").c_str();
+					}
 				}
 			}
 		}
+		
+
+		//Pop from stack
+		auto LastElement = PreviousEvaluations->end();
+		LastElement--;
+
+		PreviousEvaluations->erase(LastElement);
+
+		//Finalize
+		if (!bDeleteSectionIfEmpty || CurrentSecPair.second.Data.size())
+		{
+			FinalData.emplace(CurrentSecPair);
+		}
+
+		FinalizedSections.insert(SectionName);
+	};
+
+	//Read contents of root file
+	LTXLoad(F, path, &OverrideData, &OverrideParentDataMap, true, true);
+	F->seek(0);
+	LTXLoad(F, path, &BaseData, &BaseParentDataMap, false, true);
+
+	//Merge base and override data together
+	std::vector<std::string> PreviousEvaluations = std::vector<std::string>();
+
+	for (std::pair<std::string, Sect> SectPair : BaseData)
+	{
+		EvaluateSection(SectPair.first, &PreviousEvaluations);
+	}
+
+	//Insert all finalized sections into final container
+	for (std::pair<std::string, Sect> SectPair : FinalData)
+	{
+		Sect* NewSect = xr_new<Sect>();
+		*NewSect = SectPair.second;
+
+		RootIt I = std::lower_bound(DATA.begin(), DATA.end(), SectPair.first.c_str(), sect_pred);
+		DATA.insert(I, NewSect);
 	}
-	if (Current)
+
+	// Clean modifiers of parameters' lists
+	OverrideModifyListData.clear();
+
+	//throw errors if there are overrides that never got used
+	if (OverrideData.size())
 	{
-		RootIt I = std::lower_bound(DATA.begin(), DATA.end(), *Current->Name, sect_pred);
-		if ((I != DATA.end()) && ((*I)->Name == Current->Name))
-			Debug.fatal(DEBUG_INFO, "Duplicate section '%s' found.", *Current->Name);
-		DATA.insert(I, Current);
+		//Debug.fatal(DEBUG_INFO, "Attemped to override section '%s', which doesn't exist. Ensure that a base section with the same name is loaded first. Check this file and its DLTX mods: %s", OverrideData.begin()->first.c_str(), m_file_name);
+		for (auto i = OverrideData.begin(); i != OverrideData.end(); i++) {
+			auto override_filenames = OverrideToFilename.find(i->first);
+			if (override_filenames != OverrideToFilename.end()) {
+				for (auto &override_filename : override_filenames->second) {
+					Msg("!!!DLTX ERROR Attemped to override section '%s', which doesn't exist. Ensure that a base section with the same name is loaded first. Check this file and its DLTX mods: %s, mod file %s", i->first.c_str(), m_file_name, override_filename.first.c_str());
+				}
+			}
+		}
 	}
 }
 
diff --git a/src/xrCore/mezz_stringbuffer.cpp b/src/xrCore/mezz_stringbuffer.cpp
new file mode 100644
index 0000000..13f0470
--- /dev/null
+++ b/src/xrCore/mezz_stringbuffer.cpp
@@ -0,0 +1,26 @@
+#include "stdafx.h"
+
+#include "mezz_stringbuffer.h"
+
+MezzStringBuffer::MezzStringBuffer(uint32_t Size)
+{
+	StringBuffer = std::make_unique<char[]>(Size);
+	BufferRaw = StringBuffer.get();
+
+	BufferSize = Size;
+}
+
+char* MezzStringBuffer::GetBuffer() const
+{
+	return BufferRaw;
+}
+
+uint32_t MezzStringBuffer::GetSize() const
+{
+	return BufferSize;
+}
+
+MezzStringBuffer::operator char* () const
+{
+	return BufferRaw;
+}
\ No newline at end of file
diff --git a/src/xrCore/mezz_stringbuffer.h b/src/xrCore/mezz_stringbuffer.h
new file mode 100644
index 0000000..9f42203
--- /dev/null
+++ b/src/xrCore/mezz_stringbuffer.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include <memory>
+#include <cstdint>
+
+class MezzStringBuffer
+{
+public:
+	MezzStringBuffer(uint32_t Size = 4096);
+
+	char* GetBuffer() const;
+	uint32_t GetSize() const;
+
+	operator char* () const;
+
+private:
+	std::unique_ptr<char[]> StringBuffer;
+
+	char* BufferRaw;
+	uint32_t BufferSize;
+};
\ No newline at end of file
diff --git a/src/xrCore/xrCore.vcxproj b/src/xrCore/xrCore.vcxproj
index 209d066..2d57efb 100644
--- a/src/xrCore/xrCore.vcxproj
+++ b/src/xrCore/xrCore.vcxproj
@@ -330,6 +330,7 @@
     <ClCompile Include="memory_allocation_stats.cpp" />
     <ClCompile Include="memory_monitor.cpp" />
     <ClCompile Include="memory_usage.cpp" />
+    <ClCompile Include="mezz_stringbuffer.cpp" />
     <ClCompile Include="Model.cpp">
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
       </PrecompiledHeader>
@@ -443,6 +444,7 @@
     <ClInclude Include="lzhuf.h" />
     <ClInclude Include="lzo_compressor.h" />
     <ClInclude Include="memory_monitor.h" />
+    <ClInclude Include="mezz_stringbuffer.h" />
     <ClInclude Include="net_utils.h" />
     <ClInclude Include="os_clipboard.h" />
     <ClInclude Include="PPMd.h" />
diff --git a/src/xrCore/xrCore.vcxproj.filters b/src/xrCore/xrCore.vcxproj.filters
index dd3958c..f39a6c6 100644
--- a/src/xrCore/xrCore.vcxproj.filters
+++ b/src/xrCore/xrCore.vcxproj.filters
@@ -280,6 +280,7 @@
     <ClCompile Include="ScopeLock.cpp">
       <Filter>Threading</Filter>
     </ClCompile>
+    <ClCompile Include="mezz_stringbuffer.cpp" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="FTimer.h">
@@ -589,6 +590,7 @@
     <ClInclude Include="ScopeLock.hpp">
       <Filter>Threading</Filter>
     </ClInclude>
+    <ClInclude Include="mezz_stringbuffer.h" />
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="xrCore.rc">
diff --git a/src/xrCore/xrDebugNew.cpp b/src/xrCore/xrDebugNew.cpp
index dd65e49..6f2f339 100644
--- a/src/xrCore/xrDebugNew.cpp
+++ b/src/xrCore/xrDebugNew.cpp
@@ -232,7 +232,7 @@ void xrDebug::backend(const char* expression, const char* description, const cha
 	ShowCursor(true);
 	ShowWindow(GetActiveWindow(), SW_FORCEMINIMIZE);
 	MessageBox(
-		GetTopWindow(NULL),
+		NULL,
 		assertion_info,
 		"Fatal Error",
 		MB_OK | MB_ICONERROR | MB_SYSTEMMODAL
diff --git a/src/xrEngine/xr_ioc_cmd.cpp b/src/xrEngine/xr_ioc_cmd.cpp
index a1ec515..b206c4e 100644
--- a/src/xrEngine/xr_ioc_cmd.cpp
+++ b/src/xrEngine/xr_ioc_cmd.cpp
@@ -833,6 +833,18 @@ public:
 	}
 };
 
+class CCC_SoundParamsSmoothing : public CCC_Integer
+{
+public:
+	CCC_SoundParamsSmoothing(LPCSTR N, int* V, int _min = 0, int _max = 999) : CCC_Integer(N, V, _min, _max) {};
+
+	virtual void Execute(LPCSTR args)
+	{
+		CCC_Integer::Execute(args);
+		soundSmoothingParams::alpha = soundSmoothingParams::getAlpha();
+	}
+};
+
 ENGINE_API float psHUD_FOV_def = 0.45f;
 ENGINE_API float psHUD_FOV = psHUD_FOV_def;
 
@@ -965,6 +977,9 @@ void CCC_Register()
 	CMD3(CCC_Mask, "snd_efx", &psSoundFlags, ss_EAX);
 	CMD4(CCC_Integer, "snd_targets", &psSoundTargets, 32, 1024);
 	CMD4(CCC_Integer, "snd_cache_size", &psSoundCacheSizeMB, 8, 256);
+	// Doppler effect power
+	CMD4(CCC_Float, "snd_doppler_power", &soundSmoothingParams::power, 0.f, 5.f);
+	CMD4(CCC_SoundParamsSmoothing, "snd_doppler_smoothing", &soundSmoothingParams::steps, 1, 100);
 
 #ifdef DEBUG
     CMD3(CCC_Mask, "snd_stats", &g_stats_flags, st_sound);
diff --git a/src/xrGame/Actor_Weapon.cpp b/src/xrGame/Actor_Weapon.cpp
index 14eefbd..931a042 100644
--- a/src/xrGame/Actor_Weapon.cpp
+++ b/src/xrGame/Actor_Weapon.cpp
@@ -287,6 +287,9 @@ void CActor::on_weapon_shot_start(CWeapon* weapon)
 		{
 			effector->Initialize(camera_recoil);
 		}
+		else {
+			effector->UpdateCameraRecoil(camera_recoil);
+		}
 	}
 
 	effector->m_WeaponID = weapon->ID();
diff --git a/src/xrGame/EffectorShot.cpp b/src/xrGame/EffectorShot.cpp
index 8ac8fa4..a7ae406 100644
--- a/src/xrGame/EffectorShot.cpp
+++ b/src/xrGame/EffectorShot.cpp
@@ -21,6 +21,11 @@ void CWeaponShotEffector::Initialize(const CameraRecoil& cam_recoil)
 	Reset();
 }
 
+void CWeaponShotEffector::UpdateCameraRecoil(const CameraRecoil& cam_recoil)
+{
+	m_cam_recoil.Clone(cam_recoil);
+}
+
 void CWeaponShotEffector::Reset()
 {
 	m_angle_vert = 0.0f;
diff --git a/src/xrGame/EffectorShot.h b/src/xrGame/EffectorShot.h
index 451d458..500db02 100644
--- a/src/xrGame/EffectorShot.h
+++ b/src/xrGame/EffectorShot.h
@@ -45,6 +45,7 @@ public:
 	};
 
 	void Initialize(const CameraRecoil& cam_recoil);
+	void UpdateCameraRecoil(const CameraRecoil& cam_recoil);
 	void Reset();
 
 	IC bool IsActive() { return m_actived; }
diff --git a/src/xrGame/GameObject.cpp b/src/xrGame/GameObject.cpp
index 1516f8d..1ce2261 100644
--- a/src/xrGame/GameObject.cpp
+++ b/src/xrGame/GameObject.cpp
@@ -116,6 +116,13 @@ void CGameObject::net_Destroy()
 #endif
 
 	VERIFY(m_spawned);
+
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.CGameObject_NetDestroy", funct))
+	{
+		funct(this->lua_game_object());
+	}
+
 	if (m_anim_mov_ctrl)
 		destroy_anim_mov_ctrl();
 
@@ -441,6 +448,11 @@ BOOL CGameObject::net_Spawn(CSE_Abstract* DC)
 	}
 	BOOL ret =CScriptBinder::net_Spawn(DC);
 #else
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.CGameObject_NetSpawn", funct))
+	{
+		funct(this->lua_game_object());
+	}
 	return (CScriptBinder::net_Spawn(DC));
 #endif
 
diff --git a/src/xrGame/GamePersistent.cpp b/src/xrGame/GamePersistent.cpp
index 7087c3a..a45da94 100644
--- a/src/xrGame/GamePersistent.cpp
+++ b/src/xrGame/GamePersistent.cpp
@@ -529,6 +529,14 @@ void CGamePersistent::game_loaded()
 			m_intro->Start("game_loaded");
 			Msg("intro_start game_loaded");
 			m_intro->m_on_destroy_event.bind(this, &CGamePersistent::update_game_loaded);
+
+			// demonized
+			// Callback for when loading screen happens and "Press Any Key to Continue" prompt appears
+			luabind::functor<void> funct;
+			if (ai().script_engine().functor("_G.OnLoadingScreenKeyPrompt", funct))
+			{
+				funct();
+			}
 		}
 		m_intro_event = 0;
 	}
@@ -539,6 +547,14 @@ void CGamePersistent::update_game_loaded()
 	xr_delete(m_intro);
 	Msg("intro_delete ::update_game_loaded");
 	start_game_intro();
+
+	// demonized
+	// Callback for when player dismisses loading screen after "Press Any Key to Continue" pressed
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.OnLoadingScreenDismissed", funct))
+	{
+		funct();
+	}
 }
 
 void CGamePersistent::start_game_intro()
diff --git a/src/xrGame/ScriptXMLInit.cpp b/src/xrGame/ScriptXMLInit.cpp
index 3c89e6d..6e490ca 100644
--- a/src/xrGame/ScriptXMLInit.cpp
+++ b/src/xrGame/ScriptXMLInit.cpp
@@ -37,6 +37,29 @@ void _attach_child(CUIWindow* _child, CUIWindow* _parent)
 		_parent->AttachChild(_child);
 }
 
+// demonized
+// Clear XML from BOM
+LPCSTR clearBOM(LPCSTR s) {
+	if (s[0] == (char)0xEF && s[1] == (char)0xBB && s[2] == (char)0xBF) {
+		LPCSTR new_s = s + 3;
+		return new_s;
+	}
+	return s;
+}
+
+// demonized
+// Send XML file contents to Lua for edit
+void XMLLuaCallback(CXml &m_xml, LPCSTR xml_string) {
+	xml_string = clearBOM(xml_string);
+	luabind::functor<LPCSTR> funct;
+	if (ai().script_engine().functor("_G.COnXmlRead", funct))
+	{
+		LPCSTR res = funct(m_xml.m_xml_file_name, xml_string);
+		//Msg("XMLLuaCallback, xml %s, contents %s", m_xml.m_xml_file_name, res);
+		m_xml.LoadFromString(res);
+	}
+}
+
 void CScriptXmlInit::ParseFile(LPCSTR xml_file)
 {
 	m_xml.Load(CONFIG_PATH, UI_PATH, xml_file);
diff --git a/src/xrGame/Weapon.h b/src/xrGame/Weapon.h
index 9880065..428ec4a 100644
--- a/src/xrGame/Weapon.h
+++ b/src/xrGame/Weapon.h
@@ -386,7 +386,16 @@ public:
 	LPCSTR GetScopeNameScript() const { return *GetScopeName(); }
 	float GetFireDispersionScript() const { return fireDispersionBase; }
 	float RPMScript() const { return fOneShotTime; }
+	float RealRPMScript() const { return 60.0f / fOneShotTime; } // Return actual RPM like in configs
 	float ModeRPMScript() const { return fModeShotTime; }
+	float ModeRealRPMScript() const { return 60.0f / fModeShotTime; }
+
+	//Setters
+	void SetFireDispersionScript(float val) { fireDispersionBase = val; }
+	void SetRPM(float newOneShotTime) { fOneShotTime = newOneShotTime; } // Input - time between shots like received from getter
+	void SetRealRPM(float rpm) { fOneShotTime = 60.0f / rpm; } // Input - actual RPM like in configs
+	void SetModeRPM(float newOneShotTime) { fModeShotTime = newOneShotTime; } // Input - time between shots like received from getter
+	void SetModeRealRPM(float rpm) { fModeShotTime = 60.0f / rpm; } // Input - actual RPM like in configs
 
 	virtual float Weight() const;
 	virtual u32 Cost() const;
@@ -563,6 +572,42 @@ public:
 	CameraRecoil cam_recoil; // simple mode (walk, run)
 	CameraRecoil zoom_cam_recoil; // using zoom =(ironsight or scope)
 
+	// Getters
+	float GetCamRelaxSpeed() { return cam_recoil.RelaxSpeed; };
+	float GetCamRelaxSpeed_AI() { return cam_recoil.RelaxSpeed_AI; };
+	float GetCamDispersion() { return cam_recoil.Dispersion; };
+	float GetCamDispersionInc() { return cam_recoil.DispersionInc; };
+	float GetCamDispersionFrac() { return cam_recoil.DispersionFrac; };
+	float GetCamMaxAngleVert() { return cam_recoil.MaxAngleVert; };
+	float GetCamMaxAngleHorz() { return cam_recoil.MaxAngleHorz; };
+	float GetCamStepAngleHorz() { return cam_recoil.StepAngleHorz; };
+	float GetZoomCamRelaxSpeed() { return zoom_cam_recoil.RelaxSpeed; };
+	float GetZoomCamRelaxSpeed_AI() { return zoom_cam_recoil.RelaxSpeed_AI; };
+	float GetZoomCamDispersion() { return zoom_cam_recoil.Dispersion; };
+	float GetZoomCamDispersionInc() { return zoom_cam_recoil.DispersionInc; };
+	float GetZoomCamDispersionFrac() { return zoom_cam_recoil.DispersionFrac; };
+	float GetZoomCamMaxAngleVert() { return zoom_cam_recoil.MaxAngleVert; };
+	float GetZoomCamMaxAngleHorz() { return zoom_cam_recoil.MaxAngleHorz; };
+	float GetZoomCamStepAngleHorz() { return zoom_cam_recoil.StepAngleHorz; };
+
+	// Setters
+	void SetCamRelaxSpeed(float val) { cam_recoil.RelaxSpeed = val; };
+	void SetCamRelaxSpeed_AI(float val) { cam_recoil.RelaxSpeed_AI = val; };
+	void SetCamDispersion(float val) { cam_recoil.Dispersion = val; };
+	void SetCamDispersionInc(float val) { cam_recoil.DispersionInc = val; };
+	void SetCamDispersionFrac(float val) { cam_recoil.DispersionFrac = val; };
+	void SetCamMaxAngleVert(float val) { cam_recoil.MaxAngleVert = val; };
+	void SetCamMaxAngleHorz(float val) { cam_recoil.MaxAngleHorz = val; };
+	void SetCamStepAngleHorz(float val) { cam_recoil.StepAngleHorz = val; };
+	void SetZoomCamRelaxSpeed(float val) { zoom_cam_recoil.RelaxSpeed = val; };
+	void SetZoomCamRelaxSpeed_AI(float val) { zoom_cam_recoil.RelaxSpeed_AI = val; };
+	void SetZoomCamDispersion(float val) { zoom_cam_recoil.Dispersion = val; };
+	void SetZoomCamDispersionInc(float val) { zoom_cam_recoil.DispersionInc = val; };
+	void SetZoomCamDispersionFrac(float val) { zoom_cam_recoil.DispersionFrac = val; };
+	void SetZoomCamMaxAngleVert(float val) { zoom_cam_recoil.MaxAngleVert = val; };
+	void SetZoomCamMaxAngleHorz(float val) { zoom_cam_recoil.MaxAngleHorz = val; };
+	void SetZoomCamStepAngleHorz(float val) { zoom_cam_recoil.StepAngleHorz = val; };
+
 protected:
 	//ôàêòîð óâåëè÷åíèÿ äèñïåðñèè ïðè ìàêñèìàëüíîé èçíîøåíîñòè
 	//(íà ñêîëüêî ïðîöåíòîâ óâåëè÷èòñÿ äèñïåðñèÿ)
@@ -590,6 +635,17 @@ public:
 		return misfireEndCondition;
 	};
 
+	// Setters
+	void SetMisfireStartCondition(float val)
+	{
+		misfireStartCondition = val;
+	};
+
+	void SetMisfireEndCondition(float val)
+	{
+		misfireEndCondition = val;
+	};
+
 protected:
 	struct SPDM
 	{
@@ -750,6 +806,107 @@ public:
 	{
 		return m_first_bullet_controller.get_fire_dispertion();
 	};
+
+	// Setters
+	virtual void Set_PDM_Base(float val) 
+	{
+		m_pdm.m_fPDM_disp_base = val;
+	};
+
+	virtual void Set_Silencer_PDM_Base(float val) 
+	{
+		cur_silencer_koef.pdm_base = val;
+	};
+
+	virtual void Set_Scope_PDM_Base(float val) 
+	{
+		cur_scope_koef.pdm_base = val;
+	};
+
+	virtual void Set_Launcher_PDM_Base(float val) 
+	{
+		cur_launcher_koef.pdm_base = val;
+	};
+
+	virtual void Set_PDM_BuckShot(float val) 
+	{
+		m_pdm.m_fPDM_disp_buckShot = val;
+	};
+
+	virtual void Set_PDM_Vel_F(float val) 
+	{
+		m_pdm.m_fPDM_disp_vel_factor = val;
+	};
+
+	virtual void Set_Silencer_PDM_Vel(float val) 
+	{
+		cur_silencer_koef.pdm_vel = val;
+	};
+
+	virtual void Set_Scope_PDM_Vel(float val) 
+	{
+		cur_scope_koef.pdm_vel = val;
+	};
+
+	virtual void Set_Launcher_PDM_Vel(float val) 
+	{
+		cur_launcher_koef.pdm_vel = val;
+	};
+
+	virtual void Set_PDM_Accel_F(float val) 
+	{
+		m_pdm.m_fPDM_disp_accel_factor = val;
+	};
+
+	virtual void Set_Silencer_PDM_Accel(float val) 
+	{
+		cur_silencer_koef.pdm_accel = val;
+	};
+
+	virtual void Set_Scope_PDM_Accel(float val) 
+	{
+		cur_scope_koef.pdm_accel = val;
+	};
+
+	virtual void Set_Launcher_PDM_Accel(float val) 
+	{
+		cur_launcher_koef.pdm_accel = val;
+	};
+
+	virtual void Set_PDM_Crouch(float val) 
+	{
+		m_pdm.m_fPDM_disp_crouch = val;
+	};
+
+	virtual void Set_PDM_Crouch_NA(float val) 
+	{
+		m_pdm.m_fPDM_disp_crouch_no_acc = val;
+	};
+
+	virtual void SetCrosshairInertion(float val) 
+	{
+		m_crosshair_inertion = val;
+	};
+
+	virtual void Set_Silencer_CrosshairInertion(float val) 
+	{
+		cur_silencer_koef.crosshair_inertion = val;
+	};
+
+	virtual void Set_Scope_CrosshairInertion(float val) 
+	{
+		cur_scope_koef.crosshair_inertion = val;
+	};
+
+	virtual void Set_Launcher_CrosshairInertion(float val)
+	{
+		cur_launcher_koef.crosshair_inertion = val;
+	};
+
+	void SetFirstBulletDisp(float val)
+	{
+		m_first_bullet_controller.set_fire_dispertion(val);
+	};
 protected:
 	int iAmmoElapsed; // ammo in magazine, currently
 	int iMagazineSize; // size (in bullets) of magazine
@@ -795,6 +952,20 @@ public:
 	virtual float GetHitPowerCritical() { return fvHitPowerCritical[g_SingleGameDifficulty]; };
 	virtual float GetHitImpulse() { return fHitImpulse; };
 	virtual float GetFireDistance() { return fireDistance; };
+
+	// Setters
+	virtual void SetHitPower(float val) {
+		for (int i = ESingleGameDifficulty::egdNovice; i < ESingleGameDifficulty::egdCount; i++) {
+			fvHitPower[i] = val;
+		}
+	};
+	virtual void SetHitPowerCritical(float val) {
+		for (int i = ESingleGameDifficulty::egdNovice; i < ESingleGameDifficulty::egdCount; i++) {
+			fvHitPowerCritical[i] = val;
+		}
+	};
+	virtual void SetHitImpulse(float val) { fHitImpulse = val; };
+	virtual void SetFireDistance(float val) { fireDistance = val; };
 	
 	IC u8 GetZoomType() const
 	{
diff --git a/src/xrGame/WeaponAK74.cpp b/src/xrGame/WeaponAK74.cpp
index 6f55903..5e8a276 100644
--- a/src/xrGame/WeaponAK74.cpp
+++ b/src/xrGame/WeaponAK74.cpp
@@ -62,7 +62,9 @@ void CWeaponAK74::script_register	(lua_State *L)
 			.def("GetAmmoType", &CWeapon::GetAmmoType)
 			.def("AmmoTypeForEach", &CWeapon::AmmoTypeForEach)
 			.def("RPM", &CWeapon::RPMScript)
+			.def("RealRPM", &CWeapon::RealRPMScript)
 			.def("ModeRPM", &CWeapon::ModeRPMScript)
+			.def("ModeRealRPM", &CWeapon::ModeRealRPMScript)
 			.def("GetZoomType", &CWeapon::GetZoomType)
 			
 			.def("Get_PDM_Base", &CWeapon::Get_PDM_Base)
@@ -93,6 +95,76 @@ void CWeaponAK74::script_register	(lua_State *L)
 			.def("GetFireMode", &CWeapon::GetCurrentFireMode)
 
 			.def("GetInertionAimFactor", &CWeapon::GetInertionAimFactor)
+
+			// Setters
+			.def("SetFireDispersion", &CWeapon::SetFireDispersionScript)
+			.def("SetMisfireStartCondition", &CWeapon::SetMisfireStartCondition)
+			.def("SetMisfireEndCondition", &CWeapon::SetMisfireEndCondition)
+			.def("SetRPM", &CWeapon::SetRPM)
+			.def("SetRealRPM", &CWeapon::SetRealRPM)
+			.def("SetModeRPM", &CWeapon::SetModeRPM)
+			.def("SetModeRealRPM", &CWeapon::SetModeRealRPM)
+			.def("Set_PDM_Base", &CWeapon::Set_PDM_Base)
+			.def("Set_Silencer_PDM_Base", &CWeapon::Set_Silencer_PDM_Base)
+			.def("Set_Scope_PDM_Base", &CWeapon::Set_Scope_PDM_Base)
+			.def("Set_Launcher_PDM_Base", &CWeapon::Set_Launcher_PDM_Base)
+			.def("Set_PDM_BuckShot", &CWeapon::Set_PDM_BuckShot)
+			.def("Set_PDM_Vel_F", &CWeapon::Set_PDM_Vel_F)
+			.def("Set_Silencer_PDM_Vel", &CWeapon::Set_Silencer_PDM_Vel)
+			.def("Set_Scope_PDM_Vel", &CWeapon::Set_Scope_PDM_Vel)
+			.def("Set_Launcher_PDM_Vel", &CWeapon::Set_Launcher_PDM_Vel)
+			.def("Set_PDM_Accel_F", &CWeapon::Set_PDM_Accel_F)
+			.def("Set_Silencer_PDM_Accel", &CWeapon::Set_Silencer_PDM_Accel)
+			.def("Set_Scope_PDM_Accel", &CWeapon::Set_Scope_PDM_Accel)
+			.def("Set_Launcher_PDM_Accel", &CWeapon::Set_Launcher_PDM_Accel)
+			.def("Set_PDM_Crouch", &CWeapon::Set_PDM_Crouch)
+			.def("Set_PDM_Crouch_NA", &CWeapon::Set_PDM_Crouch_NA)
+			.def("SetCrosshairInertion", &CWeapon::SetCrosshairInertion)
+			.def("Set_Silencer_CrosshairInertion", &CWeapon::Set_Silencer_CrosshairInertion)
+			.def("Set_Scope_CrosshairInertion", &CWeapon::Set_Scope_CrosshairInertion)
+			.def("Set_Launcher_CrosshairInertion", &CWeapon::Set_Launcher_CrosshairInertion)
+			.def("SetFirstBulletDisp", &CWeapon::SetFirstBulletDisp)
+			.def("SetHitPower", &CWeapon::SetHitPower)
+			.def("SetHitPowerCritical", &CWeapon::SetHitPowerCritical)
+			.def("SetHitImpulse", &CWeapon::SetHitImpulse)
+			.def("SetFireDistance", &CWeapon::SetFireDistance)
+
+			// Cam Recoil
+			// Getters
+			.def("GetCamRelaxSpeed", &CWeapon::GetCamRelaxSpeed)
+			.def("GetCamRelaxSpeed_AI", &CWeapon::GetCamRelaxSpeed_AI)
+			.def("GetCamDispersion", &CWeapon::GetCamDispersion)
+			.def("GetCamDispersionInc", &CWeapon::GetCamDispersionInc)
+			.def("GetCamDispersionFrac", &CWeapon::GetCamDispersionFrac)
+			.def("GetCamMaxAngleVert", &CWeapon::GetCamMaxAngleVert)
+			.def("GetCamMaxAngleHorz", &CWeapon::GetCamMaxAngleHorz)
+			.def("GetCamStepAngleHorz", &CWeapon::GetCamStepAngleHorz)
+			.def("GetZoomCamRelaxSpeed", &CWeapon::GetZoomCamRelaxSpeed)
+			.def("GetZoomCamRelaxSpeed_AI", &CWeapon::GetZoomCamRelaxSpeed_AI)
+			.def("GetZoomCamDispersion", &CWeapon::GetZoomCamDispersion)
+			.def("GetZoomCamDispersionInc", &CWeapon::GetZoomCamDispersionInc)
+			.def("GetZoomCamDispersionFrac", &CWeapon::GetZoomCamDispersionFrac)
+			.def("GetZoomCamMaxAngleVert", &CWeapon::GetZoomCamMaxAngleVert)
+			.def("GetZoomCamMaxAngleHorz", &CWeapon::GetZoomCamMaxAngleHorz)
+			.def("GetZoomCamStepAngleHorz", &CWeapon::GetZoomCamStepAngleHorz)
+
+			// Setters
+			.def("SetCamRelaxSpeed", &CWeapon::SetCamRelaxSpeed)
+			.def("SetCamRelaxSpeed_AI", &CWeapon::SetCamRelaxSpeed_AI)
+			.def("SetCamDispersion", &CWeapon::SetCamDispersion)
+			.def("SetCamDispersionInc", &CWeapon::SetCamDispersionInc)
+			.def("SetCamDispersionFrac", &CWeapon::SetCamDispersionFrac)
+			.def("SetCamMaxAngleVert", &CWeapon::SetCamMaxAngleVert)
+			.def("SetCamMaxAngleHorz", &CWeapon::SetCamMaxAngleHorz)
+			.def("SetCamStepAngleHorz", &CWeapon::SetCamStepAngleHorz)
+			.def("SetZoomCamRelaxSpeed", &CWeapon::SetZoomCamRelaxSpeed)
+			.def("SetZoomCamRelaxSpeed_AI", &CWeapon::SetZoomCamRelaxSpeed_AI)
+			.def("SetZoomCamDispersion", &CWeapon::SetZoomCamDispersion)
+			.def("SetZoomCamDispersionInc", &CWeapon::SetZoomCamDispersionInc)
+			.def("SetZoomCamDispersionFrac", &CWeapon::SetZoomCamDispersionFrac)
+			.def("SetZoomCamMaxAngleVert", &CWeapon::SetZoomCamMaxAngleVert)
+			.def("SetZoomCamMaxAngleHorz", &CWeapon::SetZoomCamMaxAngleHorz)
+			.def("SetZoomCamStepAngleHorz", &CWeapon::SetZoomCamStepAngleHorz)
 			
 			.def("Cost", &CWeapon::Cost)
 			.def("Weight", &CWeapon::Weight)
diff --git a/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp b/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp
index 908d83f..696ee7c 100644
--- a/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp
+++ b/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp
@@ -17,6 +17,13 @@
 #include "../control_path_builder_base.h"
 #include "inventory_item.h"
 
+#include "script_hit.h"
+#include "pch_script.h"
+#include "../../script_game_object.h"
+
+//Flag for damaging NPCs and other objects by the stomp attack
+BOOL pseudogiantCanDamageObjects = 1;
+
 
 CPseudoGigant::CPseudoGigant()
 {
@@ -262,6 +269,21 @@ void CPseudoGigant::on_activate_control(ControlCom::EControlType type)
 	{
 		m_sound_start_threaten.play_at_pos(this, get_head_position(this));
 		m_time_next_threaten = time() + Random.randI(m_threaten_delay_min, m_threaten_delay_max);
+
+		// callback for start animation, will be triggered by everyone in radius
+		m_nearest.clear_not_free();
+		Level().ObjectSpace.GetNearest(m_nearest, Position(), 15.f, NULL);
+		for (u32 i = 0; i < m_nearest.size(); i++)
+		{
+			CPhysicsShellHolder* obj = smart_cast<CPhysicsShellHolder*>(m_nearest[i]);
+			if (obj && obj->ID() != 0 && obj->ID() != ID()) {
+				luabind::functor<void> funct;
+				if (ai().script_engine().functor("_G.CPseudoGigant__OnStartStompAnimation", funct))
+				{
+					funct(obj->lua_game_object(), this->lua_game_object());
+				}
+			}
+		}
 	}
 }
 
@@ -274,6 +296,56 @@ void CPseudoGigant::on_threaten_execute()
 	{
 		CPhysicsShellHolder* obj = smart_cast<CPhysicsShellHolder *>(m_nearest[i]);
 		CInventoryItem* itm = smart_cast<CInventoryItem*>(m_nearest[i]);
+
+		if (pseudogiantCanDamageObjects && obj && obj->ID() != 0 && obj->ID() != ID()) {
+			float dist_to_enemy = obj->Position().distance_to(Position());
+			float hit_value;
+			hit_value = m_kick_damage - m_kick_damage * dist_to_enemy / m_threaten_dist_max;
+			clamp(hit_value, 0.f, 1.f);
+
+			SHit HS;
+
+			HS.GenHeader(GE_HIT, obj->ID()); 
+			HS.whoID = ID(); 
+			HS.who = this;
+			HS.weaponID = ID(); 
+			HS.dir = Fvector().set(0.f, 1.f, 0.f); 
+			HS.power = hit_value; 
+			HS.boneID = smart_cast<IKinematics*>(obj->Visual())->LL_GetBoneRoot();
+			HS.p_in_bone_space = Fvector().set(0.f, 0.f, 0.f);
+
+			HS.impulse = obj->cast_entity_alive() && obj->cast_entity_alive()->g_Alive() ? 80 * 80 : 0; // 0 impulse for not alive objects, they will receive the impulse later
+			//HS.impulse = 80 * obj->character_physics_support()->movement()->GetMass();
+
+			HS.hit_type = ALife::eHitTypeStrike;
+
+			bool doHit = true;
+			luabind::functor<bool> funct;
+			CScriptHit tLuaHit(&HS);
+			if (ai().script_engine().functor("_G.CPseudoGigant__BeforeHitCallback", funct))
+			{
+				doHit = funct(obj->lua_game_object(), this->lua_game_object(), &tLuaHit, HS.boneID);
+				if (doHit) {
+					HS.ApplyScriptHit(&tLuaHit);
+				}
+			}
+
+			if (doHit) {
+				//Msg("hit entity %d, name %s, damage %f", obj->ID(), obj->Name(), hit_value);
+				obj->Hit(&HS);
+
+				luabind::functor<void> hitFunct;
+				if (ai().script_engine().functor("_G.CPseudoGigant__HitCallback", hitFunct))
+				{
+					hitFunct(obj->lua_game_object(), this->lua_game_object(), &tLuaHit, HS.boneID);
+				}
+
+				//NET_Packet l_P;
+				//HS.Write_Packet(l_P);
+				//u_EventSend(l_P);
+			}						
+		}
+
 		if (!obj || !obj->m_pPhysicsShell || (itm && itm->IsQuestItem())) continue;
 
 		Fvector dir;
diff --git a/src/xrGame/console_commands.cpp b/src/xrGame/console_commands.cpp
index 2841970..b7f58f4 100644
--- a/src/xrGame/console_commands.cpp
+++ b/src/xrGame/console_commands.cpp
@@ -110,6 +110,8 @@ float streff;
 
 extern BOOL g_ai_die_in_anomaly; //Alundaio
 
+extern BOOL pseudogiantCanDamageObjects;
+
 ENGINE_API extern float g_console_sensitive;
 
 u32 g_dead_body_collision = 1;
@@ -2448,6 +2450,8 @@ void CCC_RegisterCommands()
 
 	CMD4(CCC_Integer, "ai_die_in_anomaly", &g_ai_die_in_anomaly, 0, 1); //Alundaio
 
+	CMD4(CCC_Integer, "pseudogiant_can_damage_objects_on_stomp", &pseudogiantCanDamageObjects, 0, 1);
+
 	CMD4(CCC_Float, "ai_aim_predict_time", &g_aim_predict_time, 0.f, 10.f);
 
 	CMD4(CCC_Float, "head_bob_factor", &g_head_bob_factor, 0.f, 2.f);
diff --git a/src/xrGame/death_anims_predicates.cpp b/src/xrGame/death_anims_predicates.cpp
index 05efd48..c9d6437 100644
--- a/src/xrGame/death_anims_predicates.cpp
+++ b/src/xrGame/death_anims_predicates.cpp
@@ -6,6 +6,7 @@
 #include	"ai/stalker/ai_stalker.h"
 #include	"stalker_movement_manager_smart_cover.h"
 #include	"weaponshotgun.h"
+#include	"WeaponAutomaticShotgun.h"
 #include	"explosive.h"
 #include	"weaponmagazined.h"
 #include	"CharacterPhysicsSupport.h"
@@ -177,8 +178,11 @@ class type_motion2 : public type_motion
 			return false;
 		//static_cast<CGameObject*>(O)->cast_weapon()
 		CWeaponShotgun* s = smart_cast<CWeaponShotgun*>(static_cast<CGameObject*>(O));
-		if (!s)
-			return false;
+		if (!s) {
+			CWeaponAutomaticShotgun* s = smart_cast<CWeaponAutomaticShotgun*>(static_cast<CGameObject*>(O));
+			if (!s)
+				return false;
+		}		
 		Fvector p;
 		const float max_distance = 20.f;
 		if (Fvector().sub(H.initiator()->Position(), global_hit_position(p, ea, H)).magnitude() > max_distance)
diff --git a/src/xrGame/first_bullet_controller.h b/src/xrGame/first_bullet_controller.h
index 0d3548b..e55621e 100644
--- a/src/xrGame/first_bullet_controller.h
+++ b/src/xrGame/first_bullet_controller.h
@@ -14,6 +14,7 @@ public:
 	void load(shared_str const& section);
 	bool is_bullet_first(float actor_linear_velocity) const;
 	inline float get_fire_dispertion() const { return m_fire_dispertion; };
+	inline void set_fire_dispertion(float val) { m_fire_dispertion = val; };
 	void make_shot();
 }; //class first_bullet_controller
 
diff --git a/src/xrGame/level_script.cpp b/src/xrGame/level_script.cpp
index c16d21c..ae3827f 100644
--- a/src/xrGame/level_script.cpp
+++ b/src/xrGame/level_script.cpp
@@ -1762,6 +1762,21 @@ void CLevel::script_register(lua_State* L)
 		.def_readonly("object", &script_rq_result::O)
 		.def_readonly("range", &script_rq_result::range)
 		.def_readonly("element", &script_rq_result::element)
+		.def_readonly("material_name", &script_rq_result::pMaterialName)
+		.def_readonly("material_flags", &script_rq_result::pMaterialFlags)
+		.def_readonly("material_phfriction", &script_rq_result::fPHFriction)
+		.def_readonly("material_phdamping", &script_rq_result::fPHDamping)
+		.def_readonly("material_phspring", &script_rq_result::fPHSpring)
+		.def_readonly("material_phbounce_start_velocity", &script_rq_result::fPHBounceStartVelocity)
+		.def_readonly("material_phbouncing", &script_rq_result::fPHBouncing)
+		.def_readonly("material_flotation_factor", &script_rq_result::fFlotationFactor)
+		.def_readonly("material_shoot_factor", &script_rq_result::fShootFactor)
+		.def_readonly("material_shoot_factor_mp", &script_rq_result::fShootFactorMP)
+		.def_readonly("material_bounce_damage_factor", &script_rq_result::fBounceDamageFactor)
+		.def_readonly("material_injurious_speed", &script_rq_result::fInjuriousSpeed)
+		.def_readonly("material_vis_transparency_factor", &script_rq_result::fVisTransparencyFactor)
+		.def_readonly("material_snd_occlusion_factor", &script_rq_result::fSndOcclusionFactor)
+		.def_readonly("material_density_factor", &script_rq_result::fDensityFactor)
 		.def(constructor<>()),
 		class_<enum_exporter<collide::rq_target>>("rq_target")
 		.enum_("targets")
diff --git a/src/xrGame/level_sounds.cpp b/src/xrGame/level_sounds.cpp
index 28718aa..8ea30cb 100644
--- a/src/xrGame/level_sounds.cpp
+++ b/src/xrGame/level_sounds.cpp
@@ -1,4 +1,6 @@
 #include "stdafx.h"
+#include <random>
+#include <algorithm>
 #pragma hdrstop
 
 #include "level.h"
@@ -188,6 +190,9 @@ void CLevelSoundManager::Load()
 				Msg("- Loading music tracks from '%s'...",music_sect);
 #endif // #ifdef DEBUG
 				CInifile::Sect& S = gameLtx.r_section(music_sect);
+				std::random_device rd;
+				std::mt19937 g(rd());
+				std::shuffle(S.Data.begin(), S.Data.end(), g);
 				CInifile::SectCIt it = S.Data.begin(), end = S.Data.end();
 				m_MusicTracks.reserve(S.Data.size());
 				for (; it != end; it++)
@@ -206,6 +211,7 @@ void CLevelSoundManager::Unload()
 	m_StaticSounds.clear();
 	// music
 	m_MusicTracks.clear();
+	m_PlayedMusicIndices.clear();
 }
 
 void CLevelSoundManager::Update()
@@ -228,32 +234,46 @@ void CLevelSoundManager::Update()
 		if (m_CurrentTrack < 0 && engine_time > m_NextTrackTime)
 		{
 			U32Vec indices;
-			for (u32 k = 0; k < m_MusicTracks.size(); ++k)
+			for (u32 k = 0; k < m_MusicTracks.size(); k++)
 			{
+				// Msg("Checking track %d", k);
 				SMusicTrack& T = m_MusicTracks[k];
-				if (T.IsPlaying())
+				if (T.IsPlaying()) {
 					T.Stop();
-
-				if (T.in(game_time))
+					// Msg("Stopping track %d", k);
+				}
+				if ((T.in(game_time) && m_PlayedMusicIndices.empty()) || 
+					(T.in(game_time) && !(std::find(m_PlayedMusicIndices.begin(), m_PlayedMusicIndices.end(), k) != m_PlayedMusicIndices.end()))) {
 					indices.push_back(k);
-				/*
-								if ((0==T.m_ActiveTime.x) && (0==T.m_ActiveTime.y)||
-									((int(game_time)>=T.m_ActiveTime.x)&&(int(game_time)<T.m_ActiveTime.y)))
-									indices.push_back	(k);
-				*/
+					// Msg("Pushing track %d", k);
+					/*
+									if ((0==T.m_ActiveTime.x) && (0==T.m_ActiveTime.y)||
+										((int(game_time)>=T.m_ActiveTime.x)&&(int(game_time)<T.m_ActiveTime.y)))
+										indices.push_back	(k);
+					*/
+				}
 			}
 			if (!indices.empty())
 			{
-				u32 idx = Random.randI(indices.size());
+				//u32 idx = Random.randI(indices.size());
+				u32 idx = 0;
 				m_CurrentTrack = indices[idx];
 				SMusicTrack& T = m_MusicTracks[m_CurrentTrack];
 				T.Play();
+				m_PlayedMusicIndices.push_back(indices[idx]);
+				// Msg("Starting track %d", indices[idx]);
 #ifdef DEBUG
 				Log				("- Play music track:",T.m_DbgName.c_str());
 #endif
 			}
 			else
 			{
+				// Msg("m_PlayedMusicIndices.size %d", m_PlayedMusicIndices.size());
+				m_PlayedMusicIndices.clear();
+				std::random_device rd;
+				std::mt19937 g(rd());
+				std::shuffle(m_MusicTracks.begin(), m_MusicTracks.end(), g);
+				// Msg("Refreshing tracks");
 				m_NextTrackTime = engine_time + 10000; // next check after 10 sec
 			}
 		}
@@ -262,7 +282,7 @@ void CLevelSoundManager::Update()
 		{
 			SMusicTrack& T = m_MusicTracks[m_CurrentTrack];
 			if (!T.IsPlaying())
-			{
+			{	
 				m_CurrentTrack = -1;
 				m_NextTrackTime = engine_time;
 
diff --git a/src/xrGame/level_sounds.h b/src/xrGame/level_sounds.h
index 596cc31..79359b6 100644
--- a/src/xrGame/level_sounds.h
+++ b/src/xrGame/level_sounds.h
@@ -44,6 +44,7 @@ class CLevelSoundManager
 	StaticSoundsVec m_StaticSounds;
 	DEFINE_VECTOR(SMusicTrack, MusicTrackVec, MusicTrackVecIt);
 	MusicTrackVec m_MusicTracks;
+	U32Vec m_PlayedMusicIndices; //Already played music array
 	u32 m_NextTrackTime;
 	int m_CurrentTrack;
 public:
diff --git a/src/xrGame/player_hud.cpp b/src/xrGame/player_hud.cpp
index 96fae36..46f77f2 100644
--- a/src/xrGame/player_hud.cpp
+++ b/src/xrGame/player_hud.cpp
@@ -401,7 +401,7 @@ void attachable_hud_item::load(const shared_str& sect_name)
 	// Visual
 	LPCSTR visual_name = pSettings->r_string(sect_name, "item_visual");
 	IKinematicsAnimated* visual = ::Render->model_Create(visual_name)->dcast_PKinematicsAnimated();
-	R_ASSERT2(visual, make_string("could not create model %s", visual_name));
+	R_ASSERT2(visual, make_string("could not create model %s, section %s", visual_name, sect_name.c_str()));
 	m_model = smart_cast<IKinematics*>(visual);
 
 	m_attach_place_idx = pSettings->r_u16(sect_name, "attach_place_idx");
@@ -456,7 +456,7 @@ u32 attachable_hud_item::anim_play(const shared_str& anm_name_b, BOOL bMixIn, co
 		else if (bDebug)
 			Msg("playing item animation [%s]", item_anm_name.c_str());
 
-		R_ASSERT3(M2.valid(), "model has no motion [idle] ", pSettings->r_string(m_sect_name, "item_visual"));
+		R_ASSERT3(M2.valid(), make_string("model has no motion [idle], section %s", m_sect_name.c_str()).c_str(), pSettings->r_string(m_sect_name, "item_visual"));
 
 		u16 root_id = m_model->LL_GetBoneRoot();
 		CBoneInstance& root_binst = m_model->LL_GetBoneInstance(root_id);
@@ -1263,7 +1263,7 @@ player_hud_motion_container* player_hud::get_hand_motions(LPCSTR section)
 		if (phm->section == section)
 			return &phm->pm;
 	}
-
+	
 	hand_motions* res = xr_new<hand_motions>();
 	res->section = section;
 	res->pm.load(m_model, section);
@@ -1442,8 +1442,10 @@ void player_hud::remove_from_model_pool(LPCSTR sect)
 	}
 }
 
+shared_str current_player_hud_sect;
 attachable_hud_item* player_hud::create_hud_item(const shared_str& sect)
 {
+	current_player_hud_sect = sect;
 	xr_vector<attachable_hud_item*>::iterator it = m_pool.begin();
 	xr_vector<attachable_hud_item*>::iterator it_e = m_pool.end();
 	for (; it != it_e; ++it)
diff --git a/src/xrGame/raypick.cpp b/src/xrGame/raypick.cpp
index 8fd463b..a07bb0c 100644
--- a/src/xrGame/raypick.cpp
+++ b/src/xrGame/raypick.cpp
@@ -1,6 +1,7 @@
 #include "stdafx.h"
 #include "raypick.h"
 #include "level.h"
+#include "material_manager.h"
 
 CRayPick::CRayPick()
 {
@@ -28,6 +29,30 @@ bool CRayPick::query()
 	if (Level().ObjectSpace.RayPick(start_position, direction, range, flags, R, ignore))
 	{
 		result.set(R);
+		if (!R.O) {
+			//Msg("no object, check material");
+			auto pTri = Level().ObjectSpace.GetStaticTris() + R.element;
+			auto pMaterial = GMLib.GetMaterialByIdx(pTri->material);
+			auto pMaterialFlags = pMaterial->Flags;
+			//result.pTri = pTri;
+			//result.pMaterial = pMaterial;
+			result.pMaterialFlags = pMaterialFlags.flags;
+			result.pMaterialName = pMaterial->m_Name.c_str();
+
+			result.fPHFriction = pMaterial->fPHFriction;
+			result.fPHDamping = pMaterial->fPHDamping;
+			result.fPHSpring = pMaterial->fPHSpring;
+			result.fPHBounceStartVelocity = pMaterial->fPHBounceStartVelocity;
+			result.fPHBouncing = pMaterial->fPHBouncing;
+			result.fFlotationFactor = pMaterial->fFlotationFactor;
+			result.fShootFactor = pMaterial->fShootFactor;
+			result.fShootFactorMP = pMaterial->fShootFactorMP;
+			result.fBounceDamageFactor = pMaterial->fBounceDamageFactor;
+			result.fInjuriousSpeed = pMaterial->fInjuriousSpeed;
+			result.fVisTransparencyFactor = pMaterial->fVisTransparencyFactor;
+			result.fSndOcclusionFactor = pMaterial->fSndOcclusionFactor;
+			result.fDensityFactor = pMaterial->fDensityFactor;
+		}
 		return true;
 	}
 	else
diff --git a/src/xrGame/raypick.h b/src/xrGame/raypick.h
index 81e990e..ff36f04 100644
--- a/src/xrGame/raypick.h
+++ b/src/xrGame/raypick.h
@@ -9,6 +9,26 @@ struct script_rq_result
 	float range;
 	int element;
 
+	// Material of tri of ray query result
+	str_c pMaterialName;
+	u32 pMaterialFlags;
+
+	// physics part
+	float fPHFriction; // ?
+	float fPHDamping; // ?
+	float fPHSpring; // ?
+	float fPHBounceStartVelocity; // ?
+	float fPHBouncing; // ?
+					   // shoot&bounce&visibility&flotation
+	float fFlotationFactor; // 0.f - 1.f (1.f- )
+	float fShootFactor; // 0.f - 1.f (1.f- )
+	float fShootFactorMP; // 0.f - 1.f (1.f- )
+	float fBounceDamageFactor; // 0.f - 100.f
+	float fInjuriousSpeed; // 0.f - ... (0.f-   (  ))
+	float fVisTransparencyFactor; // 0.f - 1.f (1.f- )
+	float fSndOcclusionFactor; // 0.f - 1.f (1.f- )
+	float fDensityFactor;
+
 	script_rq_result()
 	{
 		O = 0;
diff --git a/src/xrGame/script_game_object.cpp b/src/xrGame/script_game_object.cpp
index 5489997..9a1a917 100644
--- a/src/xrGame/script_game_object.cpp
+++ b/src/xrGame/script_game_object.cpp
@@ -369,6 +369,32 @@ Fvector CScriptGameObject::bone_position(LPCSTR bone_name, bool bHud) const
 	return (matrix.c);
 }
 
+Fvector CScriptGameObject::bone_direction(LPCSTR bone_name, bool bHud) const
+{
+	IKinematics* k = nullptr;
+
+	CHudItem* itm = smart_cast<CHudItem*>(&object());
+	if (bHud && itm)
+		k = itm->HudItemData()->m_model;
+	else
+		k = object().Visual()->dcast_PKinematics();
+
+	u16 bone_id;
+	if (xr_strlen(bone_name))
+	{
+		bone_id = k->LL_BoneID(bone_name);
+		if (bone_id == BI_NONE)
+			bone_id = k->LL_GetBoneRoot();
+	} else
+		bone_id = k->LL_GetBoneRoot();
+
+	Fmatrix matrix;
+	Fvector res;
+	matrix.mul_43((bHud && itm) ? itm->HudItemData()->m_item_transform : object().XFORM(),
+		k->LL_GetTransform(bone_id));
+	matrix.getHPB(res);
+	return (res);
+}
 
 LPCSTR CScriptGameObject::bone_name(u16 id, bool bHud)
 {
diff --git a/src/xrGame/script_game_object.h b/src/xrGame/script_game_object.h
index 640dcab..08f6153 100644
--- a/src/xrGame/script_game_object.h
+++ b/src/xrGame/script_game_object.h
@@ -683,6 +683,7 @@ public:
 	void stop_particles(LPCSTR pname, LPCSTR bone);
 
 	Fvector bone_position(LPCSTR bone_name, bool bHud = false) const;
+	Fvector bone_direction(LPCSTR bone_name, bool bHud = false) const;
 	LPCSTR bone_name(u16 id, bool bHud);
 	bool is_body_turning() const;
 	cphysics_shell_scripted* get_physics_shell() const;
@@ -1027,6 +1028,10 @@ public:
 	void SetActorRunCoef(float run_coef);
 	float GetActorRunBackCoef() const;
 	void SetActorRunBackCoef(float run_back_coef);
+	float GetActorWalkAccel() const;
+	void SetActorWalkAccel(float val);
+	float GetActorWalkBackCoef() const;
+	void SetActorWalkBackCoef(float val);
 
 	void SetCharacterIcon(LPCSTR iconName);
 #endif
diff --git a/src/xrGame/script_game_object_inventory_owner.cpp b/src/xrGame/script_game_object_inventory_owner.cpp
index 3ad0a2f..d7697f7 100644
--- a/src/xrGame/script_game_object_inventory_owner.cpp
+++ b/src/xrGame/script_game_object_inventory_owner.cpp
@@ -2491,6 +2491,55 @@ void CScriptGameObject::SetActorRunBackCoef(float run_back_coef)
 	pActor->m_fRunBackFactor = run_back_coef;
 }
 
+
+float CScriptGameObject::GetActorWalkAccel() const
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member GetActorWalkAccel!");
+		return (false);
+	}
+	return (pActor->m_fWalkAccel);
+}
+void CScriptGameObject::SetActorWalkAccel(float val)
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member SetActorWalkAccel!");
+		return;
+	}
+	pActor->m_fWalkAccel = val;
+}
+
+
+float CScriptGameObject::GetActorWalkBackCoef() const
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member GetActorWalkBackCoef!");
+		return (false);
+	}
+	return (pActor->m_fWalkBackFactor);
+}
+void CScriptGameObject::SetActorWalkBackCoef(float val)
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member SetActorWalkBackCoef!");
+		return;
+	}
+	pActor->m_fWalkBackFactor = val;
+}
+
+
 void CScriptGameObject::SetCharacterIcon(LPCSTR iconName)
 {
 	CInventoryOwner* pInventoryOwner = smart_cast<CInventoryOwner*>(&object());
diff --git a/src/xrGame/script_game_object_script3.cpp b/src/xrGame/script_game_object_script3.cpp
index aeeaf8f..1b4f437 100644
--- a/src/xrGame/script_game_object_script3.cpp
+++ b/src/xrGame/script_game_object_script3.cpp
@@ -115,6 +115,7 @@ class_<CScriptGameObject>& script_register_game_object2(class_<CScriptGameObject
 			     ::set_item))
 
 		.def("bone_position", &CScriptGameObject::bone_position)
+		.def("bone_direction", &CScriptGameObject::bone_direction)
 
 		.def("bone_name", &CScriptGameObject::bone_name)
 		.def("is_body_turning", &CScriptGameObject::is_body_turning)
@@ -536,6 +537,12 @@ class_<CScriptGameObject>& script_register_game_object2(class_<CScriptGameObject
 		.def("get_actor_runback_coef", &CScriptGameObject::GetActorRunBackCoef)
 		.def("set_actor_runback_coef", &CScriptGameObject::SetActorRunBackCoef)
 		//end AVO
+
+		// Additional exports
+		.def("get_actor_walk_accel", &CScriptGameObject::GetActorWalkAccel)
+		.def("set_actor_walk_accel", &CScriptGameObject::SetActorWalkAccel)
+		.def("get_actor_walk_back_coef", &CScriptGameObject::GetActorWalkBackCoef)
+		.def("set_actor_walk_back_coef", &CScriptGameObject::SetActorWalkBackCoef)
 #endif
 
 		.def("set_can_be_harmed", &CScriptGameObject::SetCanBeHarmed)
diff --git a/src/xrGame/ui/UILogsWnd.cpp b/src/xrGame/ui/UILogsWnd.cpp
index cda3adc..6d1fad1 100644
--- a/src/xrGame/ui/UILogsWnd.cpp
+++ b/src/xrGame/ui/UILogsWnd.cpp
@@ -76,6 +76,16 @@ void CUILogsWnd::Update()
 
 	if (!m_items_ready.empty())
 	{
+		// Sort news by date correctly
+		struct {
+			bool operator()(CUIWindow* x, CUIWindow* y) {
+				CUINewsItemWnd* a = smart_cast<CUINewsItemWnd*>(x);
+				CUINewsItemWnd* b = smart_cast<CUINewsItemWnd*>(y);
+				return a->receive_time > b->receive_time;
+			}
+		} sortNewsDesc;
+		std::sort(m_items_ready.begin(), m_items_ready.end(), sortNewsDesc);
+
 		WINDOW_LIST::iterator it = m_items_ready.begin();
 		WINDOW_LIST::iterator it_e = m_items_ready.end();
 		for (; it != it_e; ++it)
@@ -178,6 +188,14 @@ void CUILogsWnd::ReLoadNews()
 	VERIFY(m_filter_news && m_filter_talk);
 	GAME_NEWS_VECTOR& news_vector = Actor()->game_news_registry->registry().objects();
 
+	// Sort news by date correctly
+	struct {
+		bool operator()(GAME_NEWS_DATA& a, GAME_NEWS_DATA& b) {
+			return a.receive_time < b.receive_time;
+		}
+	} sortNewsDesc;
+	std::sort(news_vector.begin(), news_vector.end(), sortNewsDesc);
+
 	//	u32 currentNews = 0;
 
 	bool filter_news = m_filter_news->GetCheck();
diff --git a/src/xrGame/ui/UINewsItemWnd.cpp b/src/xrGame/ui/UINewsItemWnd.cpp
index 86180d2..2d8eac6 100644
--- a/src/xrGame/ui/UINewsItemWnd.cpp
+++ b/src/xrGame/ui/UINewsItemWnd.cpp
@@ -33,6 +33,7 @@ void CUINewsItemWnd::Init(CUIXml& uiXml, LPCSTR start_from)
 
 void CUINewsItemWnd::Setup(GAME_NEWS_DATA& news_data)
 {
+	receive_time = news_data.receive_time;
 	shared_str time_str = InventoryUtilities::GetTimeAndDateAsString(news_data.receive_time);
 	u32 sz = (time_str.size() + 5) * sizeof(char);
 	PSTR str = (PSTR)_alloca(sz);
diff --git a/src/xrGame/ui/UINewsItemWnd.h b/src/xrGame/ui/UINewsItemWnd.h
index 464c410..e7f0642 100644
--- a/src/xrGame/ui/UINewsItemWnd.h
+++ b/src/xrGame/ui/UINewsItemWnd.h
@@ -2,6 +2,7 @@
 
 #include "UIWindow.h"
 #include "xrUIXmlParser.h"
+#include "../alife_time_manager.h"
 class CUIStatic;
 class CUITextWnd;
 struct GAME_NEWS_DATA;
@@ -15,6 +16,10 @@ class CUINewsItemWnd : public CUIWindow
 	CUITextWnd* m_UIText;
 	CUIStatic* m_UIImage;
 
+	// Store GAME_NEWS_DATA time
+public:
+	ALife::_TIME_ID receive_time = 0;
+
 public:
 	CUINewsItemWnd();
 	virtual ~CUINewsItemWnd();
diff --git a/src/xrServerEntities/script_fvector_script.cpp b/src/xrServerEntities/script_fvector_script.cpp
index 06020de..a1a7aa6 100644
--- a/src/xrServerEntities/script_fvector_script.cpp
+++ b/src/xrServerEntities/script_fvector_script.cpp
@@ -79,6 +79,7 @@ void CScriptFvector::script_register(lua_State* L)
 		.def("dotproduct", &Fvector::dotproduct)
 		.def("crossproduct", &Fvector::crossproduct, return_reference_to(_1))
 		.def("distance_to_xz", &Fvector::distance_to_xz)
+		.def("distance_to_xz_sqr", &Fvector::distance_to_xz_sqr)
 		.def("distance_to_sqr", &Fvector::distance_to_sqr)
 		.def("distance_to", &Fvector::distance_to)
 		//			.def("from_bary",					(Fvector & (Fvector::*)(const Fvector &, const Fvector &, const Fvector &, float, float, float))(&Fvector::from_bary),	return_reference_to(_1))
diff --git a/src/xrServerEntities/script_storage.cpp b/src/xrServerEntities/script_storage.cpp
index 450b304..6a932db 100644
--- a/src/xrServerEntities/script_storage.cpp
+++ b/src/xrServerEntities/script_storage.cpp
@@ -556,18 +556,27 @@ int __cdecl CScriptStorage::script_log(ScriptStorage::ELuaMessageType tLuaMessag
 	int result = vscript_log(tLuaMessageType, caFormat, marker);
 	va_end(marker);
 
-#ifdef PRINT_CALL_STACK
-#	ifndef ENGINE_BUILD
-    static bool	reenterability = false;
-    if (!reenterability)
-    {
-        reenterability = true;
-        if (eLuaMessageTypeError == tLuaMessageType)
-            ai().script_engine().print_stack();
-        reenterability = false;
-    }
-#	endif //!ENGINE_BUILD
-#endif //-PRINT_CALL_STACK
+	static bool reenterability = false;
+	if (!reenterability)
+	{
+		reenterability = true;
+		if (tLuaMessageType == ScriptStorage::eLuaMessageTypeError)
+			ai().script_engine().print_stack();
+		reenterability = false;
+	}
+
+	// #ifdef PRINT_CALL_STACK
+	// #	ifndef ENGINE_BUILD
+	//     static bool	reenterability = false;
+	//     if (!reenterability)
+	//     {
+	//         reenterability = true;
+	//         if (eLuaMessageTypeError == tLuaMessageType)
+	//             ai().script_engine().print_stack();
+	//         reenterability = false;
+	//     }
+	// #	endif //!ENGINE_BUILD
+	// #endif //-PRINT_CALL_STACK
 
 	return (result);
 }
diff --git a/src/xrServerEntities/specific_character.cpp b/src/xrServerEntities/specific_character.cpp
index 9029b27..02517bc 100644
--- a/src/xrServerEntities/specific_character.cpp
+++ b/src/xrServerEntities/specific_character.cpp
@@ -5,6 +5,8 @@
 #include "PhraseDialog.h"
 #include "string_table.h"
 
+#include "ai_space.h"
+#include "Script_Game_Object.h"
 
 SSpecificCharacterData::SSpecificCharacterData()
 {
@@ -125,6 +127,32 @@ void CSpecificCharacter::load_shared(LPCSTR)
 		data()->m_ActorDialogs.push_back(dialog_name);
 	}
 
+	luabind::functor<luabind::object> funct;
+	if (ai().script_engine().functor("_G.CSpecificCharacterDialogList", funct))
+	{
+		luabind::object table = luabind::newtable(ai().script_engine().lua());
+		int i = 1;
+		for (auto const &dialog : data()->m_ActorDialogs) {
+			table[i] = dialog.c_str();
+			i++;
+		}
+		auto character_name = item_data.id.c_str();
+		luabind::object output = funct(character_name, table);
+		if (output && output.type() == LUA_TTABLE) {
+			data()->m_ActorDialogs.clear();
+			luabind::object::iterator i = output.begin();
+			luabind::object::iterator e = output.end();
+			for (; i != e; ++i) {
+				luabind::object v = *i;
+				if (v.type() == LUA_TSTRING) {
+					shared_str dialog_name = luabind::object_cast<LPCSTR>(v);
+					//Msg("character_id %s, dialog_name %s", character_name, dialog_name.c_str());
+					data()->m_ActorDialogs.push_back(dialog_name);
+				}
+			}
+		}
+	}
+
 	data()->m_icon_name = pXML->Read("icon", 0, "ui_npc_u_barman");
 
 
@@ -240,6 +268,78 @@ void CSpecificCharacter::load_shared(LPCSTR)
 		MoneyDef().inf_money = false;
 	}
 
+	luabind::functor<luabind::object> init_funct;
+	if (ai().script_engine().functor("_G.CSpecificCharacterInit", init_funct))
+	{
+		luabind::object table = luabind::newtable(ai().script_engine().lua());
+		table["name"] = Name();
+		table["bio"] = Bio().c_str();
+		table["community"] = Community().id().c_str();
+		table["icon"] = data()->m_icon_name.c_str();
+		table["start_dialog"] = data()->m_StartDialog.c_str();
+		table["panic_threshold"] = panic_threshold();
+		table["hit_probability_factor"] = hit_probability_factor();
+		table["crouch_type"] = crouch_type();
+		table["mechanic_mode"] = upgrade_mechanic();
+		table["critical_wound_weights"] = critical_wound_weights();
+		table["supplies"] = SupplySpawn();
+		table["visual"] = Visual();
+		table["npc_config"] = NpcConfigSect();
+		table["snd_config"] = sound_voice_prefix();
+		table["terrain_sect"] = terrain_sect().c_str();
+		table["rank_min"] = RankDef().min;
+		table["rank_max"] = RankDef().max;
+		table["reputation_min"] = ReputationDef().min;
+		table["reputation_max"] = ReputationDef().max;
+		table["money_min"] = MoneyDef().min_money;
+		table["money_max"] = MoneyDef().max_money;
+		table["money_infinitive"] = MoneyDef().inf_money;
+		auto character_name = item_data.id.c_str();
+		luabind::object output = init_funct(character_name, table);
+		if (output && output.type() == LUA_TTABLE) {
+			data()->m_sGameName = luabind::object_cast<LPCSTR>(output["name"]);
+			data()->m_sBioText = CStringTable().translate(luabind::object_cast<LPCSTR>(output["bio"]));
+
+			data()->m_Community.set(luabind::object_cast<LPCSTR>(output["community"]));
+			if (data()->m_Community.index() == NO_COMMUNITY_INDEX)
+				Debug.fatal(DEBUG_INFO, "wrong 'community' '%s' in specific character %s ", luabind::object_cast<LPCSTR>(output["community"]), *m_OwnId);
+
+			data()->m_icon_name = luabind::object_cast<LPCSTR>(output["icon"]);
+			data()->m_StartDialog = output["start_dialog"].type() == LUA_TSTRING ? luabind::object_cast<LPCSTR>(output["start_dialog"]) : NULL;
+			data()->m_fPanic_threshold = luabind::object_cast<float>(output["panic_threshold"]);
+			data()->m_fHitProbabilityFactor = luabind::object_cast<float>(output["hit_probability_factor"]);
+			data()->m_crouch_type = luabind::object_cast<int>(output["crouch_type"]);
+			data()->m_upgrade_mechanic = luabind::object_cast<bool>(output["mechanic_mode"]);
+			data()->m_critical_wound_weights = luabind::object_cast<LPCSTR>(output["critical_wound_weights"]);
+			data()->m_sVisual = luabind::object_cast<LPCSTR>(output["visual"]);
+			data()->m_sNpcConfigSect = luabind::object_cast<LPCSTR>(output["npc_config"]);
+			data()->m_sound_voice_prefix = luabind::object_cast<LPCSTR>(output["snd_config"]);
+			data()->m_terrain_sect = luabind::object_cast<LPCSTR>(output["terrain_sect"]);
+
+			data()->m_sSupplySpawn = luabind::object_cast<LPCSTR>(output["supplies"]);
+			if (!data()->m_sSupplySpawn.empty())
+			{
+				xr_string& str = data()->m_sSupplySpawn;
+				xr_string::size_type pos = str.find("\\n");
+				while (xr_string::npos != pos)
+				{
+					str.replace(pos, 2, "\n");
+					pos = str.find("\\n", pos + 1);
+				}
+			}
+
+			RankDef().min = _min(luabind::object_cast<int>(output["rank_min"]), luabind::object_cast<int>(output["rank_max"]));
+			RankDef().max = _max(luabind::object_cast<int>(output["rank_min"]), luabind::object_cast<int>(output["rank_max"]));
+
+			ReputationDef().min = _min(luabind::object_cast<int>(output["reputation_min"]), luabind::object_cast<int>(output["reputation_max"]));
+			ReputationDef().max = _max(luabind::object_cast<int>(output["reputation_min"]), luabind::object_cast<int>(output["reputation_max"]));
+
+			MoneyDef().min_money = _min(luabind::object_cast<int>(output["money_min"]), luabind::object_cast<int>(output["money_max"]));
+			MoneyDef().max_money = _max(luabind::object_cast<int>(output["money_min"]), luabind::object_cast<int>(output["money_max"]));
+			MoneyDef().inf_money = luabind::object_cast<bool>(output["money_infinitive"]);
+		}
+	}
+
 #endif
 
 #if 0
diff --git a/src/xrSound/Sound.h b/src/xrSound/Sound.h
index eeb6d58..9e1ed78 100644
--- a/src/xrSound/Sound.h
+++ b/src/xrSound/Sound.h
@@ -212,17 +212,72 @@ class XRSOUND_API CSound_environment
 public:
 };
 
+namespace soundSmoothingParams {
+	extern float power;
+	extern int steps;
+	extern float alpha;
+	extern float getAlpha();
+	extern float getTimeDeltaSmoothing();
+	extern float getSmoothedValue(float, float, float);
+};
+
 /// definition (Sound Params)
 class XRSOUND_API CSound_params
 {
+public:
+	CSound_params() :
+		set(false)
+		{
+			position.set(0.0f, 0.0f, 0.0f);
+			velocity.set(0.0f, 0.0f, 0.0f);
+			accVelocity.set(0.f, 0.f, 0.f);
+		}
+
+private:
+	bool set;
+
 public:
 	Fvector position;
+	Fvector velocity;  // Cribbledirge.  Added for doppler effect.
+	Fvector curVelocity;  // Current velocity.
+	Fvector prevVelocity;  // Previous velocity.
+	Fvector accVelocity;  // Velocity accumulator (for moving average).
 	float base_volume;
 	float volume;
 	float freq;
 	float min_distance;
 	float max_distance;
 	float max_ai_distance;
+
+	// Functions added by Cribbledirge for doppler effect.
+	IC virtual void update_position(const Fvector& newPosition)
+	{
+		// If the position has been set already, start getting a moving average of the velocity.
+		if (set)
+		{
+			prevVelocity.set(accVelocity);
+			curVelocity.sub(newPosition, position);
+
+			//accVelocity.set(curVelocity.mul(alpha).add(prevVelocity.mul(1.f - alpha)));
+		}
+		else
+		{
+			set = true;
+		}
+		position.set(newPosition);
+	}
+
+	IC virtual void update_velocity(const float dt)
+	{
+		float a = soundSmoothingParams::getTimeDeltaSmoothing();
+		int p = soundSmoothingParams::power;
+		accVelocity.x = soundSmoothingParams::getSmoothedValue(curVelocity.x * p / dt, accVelocity.x, a);
+		accVelocity.y = soundSmoothingParams::getSmoothedValue(curVelocity.y * p / dt, accVelocity.y, a);
+		accVelocity.z = soundSmoothingParams::getSmoothedValue(curVelocity.z * p / dt, accVelocity.z, a);
+		velocity.set(accVelocity);
+
+		//Msg("VELOC: %f", velocity.magnitude());
+	}
 };
 
 /// definition (Sound Interface)
diff --git a/src/xrSound/SoundRender_CoreA.cpp b/src/xrSound/SoundRender_CoreA.cpp
index 4301be7..a90e63c 100644
--- a/src/xrSound/SoundRender_CoreA.cpp
+++ b/src/xrSound/SoundRender_CoreA.cpp
@@ -7,6 +7,22 @@
 #include "../xrEngine/pure.h"
 #include "../xrEngine/XR_IOConsole.h"
 
+namespace soundSmoothingParams {
+	float power = 1.8;
+	int steps = 15;
+	float alpha = getAlpha();
+	IC float getAlpha() {
+		return 2.0f / (steps + 1);
+	}
+	IC float getTimeDeltaSmoothing() {
+		return alpha;
+		//return min(1.0f, alpha * (Device.fTimeDelta / steps));
+	}
+	IC float getSmoothedValue(float target, float current, float smoothing = getTimeDeltaSmoothing()) {
+		return current + smoothing * (target - current);
+	}
+};
+
 extern CConsole* Console;
 
 CSoundRender_CoreA* SoundRenderA = 0;
@@ -148,6 +164,14 @@ void CSoundRender_CoreA::_initialize(int stage)
 		bEAX = EAXTestSupport(FALSE);
 	}
 
+	// Init listener struct
+	Listener.position.set(0.0f, 0.0f, 0.0f);
+	Listener.prevVelocity.set(0.0f, 0.0f, 0.0f);
+	Listener.curVelocity.set(0.0f, 0.0f, 0.0f);
+	Listener.accVelocity.set(0.0f, 0.0f, 0.0f);
+	Listener.orientation[0].set(0.0f, 0.0f, 0.0f);
+	Listener.orientation[1].set(0.0f, 0.0f, 0.0f);
+
 	inherited::_initialize(stage);
 
 	if (stage == 1) //first initialize
@@ -218,6 +242,18 @@ void CSoundRender_CoreA::update_listener(const Fvector& P, const Fvector& D, con
 {
 	inherited::update_listener(P, D, N, dt);
 
+	Listener.curVelocity.sub(P, Listener.position);
+
+	float a = soundSmoothingParams::getTimeDeltaSmoothing();
+	int p = soundSmoothingParams::power;
+	Listener.accVelocity.x = soundSmoothingParams::getSmoothedValue(Listener.curVelocity.x * p / dt, Listener.accVelocity.x, a);
+	Listener.accVelocity.y = soundSmoothingParams::getSmoothedValue(Listener.curVelocity.y * p / dt, Listener.accVelocity.y, a);
+	Listener.accVelocity.z = soundSmoothingParams::getSmoothedValue(Listener.curVelocity.z * p / dt, Listener.accVelocity.z, a);
+	
+	Listener.prevVelocity.set(Listener.accVelocity);
+
+	// Msg("listener sound update delta %.3f, velocity %.3f, %.3f, %.3f, power %.1f, alpha %.3f", dt, Listener.prevVelocity.x, Listener.prevVelocity.y, Listener.prevVelocity.z, soundSmoothingParams::power, soundSmoothingParams::alpha);
+
 	if (!Listener.position.similar(P))
 	{
 		Listener.position.set(P);
@@ -227,6 +263,6 @@ void CSoundRender_CoreA::update_listener(const Fvector& P, const Fvector& D, con
 	Listener.orientation[1].set(N.x, N.y, -N.z);
 
 	A_CHK(alListener3f (AL_POSITION,Listener.position.x,Listener.position.y,-Listener.position.z));
-	A_CHK(alListener3f (AL_VELOCITY,0.f,0.f,0.f));
+	A_CHK(alListener3f (AL_VELOCITY, Listener.prevVelocity.x, Listener.prevVelocity.y, -Listener.prevVelocity.z));
 	A_CHK(alListenerfv (AL_ORIENTATION,&Listener.orientation[0].x));
 }
diff --git a/src/xrSound/SoundRender_CoreA.h b/src/xrSound/SoundRender_CoreA.h
index e0eaabd..81d81c3 100644
--- a/src/xrSound/SoundRender_CoreA.h
+++ b/src/xrSound/SoundRender_CoreA.h
@@ -26,6 +26,9 @@ class CSoundRender_CoreA : public CSoundRender_Core
 	struct SListener
 	{
 		Fvector position;
+		Fvector prevVelocity;
+		Fvector curVelocity;
+		Fvector accVelocity;
 		Fvector orientation[2];
 	};
 
diff --git a/src/xrSound/SoundRender_Emitter.cpp b/src/xrSound/SoundRender_Emitter.cpp
index fa6be85..425130f 100644
--- a/src/xrSound/SoundRender_Emitter.cpp
+++ b/src/xrSound/SoundRender_Emitter.cpp
@@ -12,7 +12,7 @@ extern float psSoundVEffects;
 void CSoundRender_Emitter::set_position(const Fvector& pos)
 {
 	if (source()->channels_num() == 1)
-		p_source.position = pos;
+		p_source.update_position(pos);
 	else
 		p_source.position.set(0, 0, 0);
 
diff --git a/src/xrSound/SoundRender_Emitter_FSM.cpp b/src/xrSound/SoundRender_Emitter_FSM.cpp
index 87a6824..7313308 100644
--- a/src/xrSound/SoundRender_Emitter_FSM.cpp
+++ b/src/xrSound/SoundRender_Emitter_FSM.cpp
@@ -333,6 +333,9 @@ float CSoundRender_Emitter::priority()
 
 void CSoundRender_Emitter::update_environment(float dt)
 {
-	if (bMoved) e_target = *SoundRender->get_environment(p_source.position);
+	if (bMoved) {
+		e_target = *SoundRender->get_environment(p_source.position);
+		p_source.update_velocity(dt);
+	}
 	e_current.lerp(e_current, e_target, dt);
 }
diff --git a/src/xrSound/SoundRender_TargetA.cpp b/src/xrSound/SoundRender_TargetA.cpp
index ef418a7..f3bcdab 100644
--- a/src/xrSound/SoundRender_TargetA.cpp
+++ b/src/xrSound/SoundRender_TargetA.cpp
@@ -154,6 +154,9 @@ void CSoundRender_TargetA::fill_parameters()
 	A_CHK(alSource3f(pSource, AL_POSITION, m_pEmitter->p_source.position.x,m_pEmitter->p_source.position.y,-m_pEmitter->
 		p_source.position.z));
 
+	VERIFY2(m_pEmitter, SE->source()->file_name());
+	A_CHK(alSource3f(pSource, AL_VELOCITY, m_pEmitter->p_source.velocity.x, m_pEmitter->p_source.velocity.y, -m_pEmitter->p_source.velocity.z));
+
 	VERIFY2(m_pEmitter, SE->source()->file_name());
 	A_CHK(alSourcei (pSource, AL_SOURCE_RELATIVE, m_pEmitter->b2D));
 
diff --git a/src/xrXMLParser/xrXMLParser.cpp b/src/xrXMLParser/xrXMLParser.cpp
index 1d69c77..1cde914 100644
--- a/src/xrXMLParser/xrXMLParser.cpp
+++ b/src/xrXMLParser/xrXMLParser.cpp
@@ -3,6 +3,7 @@
 
 #include "xrXMLParser.h"
 
+extern void XMLLuaCallback(CXml &m_xml, LPCSTR xml_string);
 
 XRXMLPARSER_API CXml::CXml()
 	: m_root(NULL),
@@ -138,6 +139,21 @@ void CXml::Load(LPCSTR path, LPCSTR xml_filename)
 		R_ASSERT2(false, str);
 	}
 
+	m_root = m_Doc.FirstChildElement();
+	XMLLuaCallback(*this, (LPCSTR)W.pointer());
+}
+
+void CXml::LoadFromString(LPCSTR xml_string)
+{
+	ClearInternal();
+	m_Doc.Parse(&m_Doc, xml_string);
+	if (m_Doc.Error())
+	{
+		string1024 str;
+		xr_sprintf(str, "XML file:%s value:%s errDescr:%s", m_xml_file_name, m_Doc.Value(), m_Doc.ErrorDesc());
+		R_ASSERT2(false, str);
+	}
+
 	m_root = m_Doc.FirstChildElement();
 }
 
diff --git a/src/xrXMLParser/xrXMLParser.h b/src/xrXMLParser/xrXMLParser.h
index 3a13303..fcdc789 100644
--- a/src/xrXMLParser/xrXMLParser.h
+++ b/src/xrXMLParser/xrXMLParser.h
@@ -31,7 +31,7 @@ public:
 	void ClearInternal();
 
 	void Load(LPCSTR path_alias, LPCSTR path, LPCSTR xml_filename);
-
+	void LoadFromString(LPCSTR xml_string);
 
 	// 
 	LPCSTR Read(LPCSTR path, int index, LPCSTR default_str_val);
