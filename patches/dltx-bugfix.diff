diff --git a/src/Layers/xrRender/SkeletonAnimated.cpp b/src/Layers/xrRender/SkeletonAnimated.cpp
index a2b6c3f..d5ac60e 100644
--- a/src/Layers/xrRender/SkeletonAnimated.cpp
+++ b/src/Layers/xrRender/SkeletonAnimated.cpp
@@ -11,6 +11,7 @@
 #include	"../../xrcore/dump_string.h"
 #endif
 extern int psSkeletonUpdate;
+extern shared_str current_player_hud_sect;
 using namespace animation;
 //////////////////////////////////////////////////////////////////////////
 // BoneInstance methods
@@ -781,7 +782,7 @@ void CKinematicsAnimated::Load(const char* N, IReader* data, u32 dwFlags)
 		if (!FS.exist(fn, "$level$", _path))
 		{
 			if (!FS.exist(fn, "$game_meshes$", _path))
-				Debug.fatal(DEBUG_INFO, "Can't find motion file '%s'.", _path);
+				Debug.fatal(DEBUG_INFO, "Can't find motion file '%s'\nsection '%s'\nmodel '%s'", _path, current_player_hud_sect.c_str(), N);
 		}
 
 		// Check compatibility
@@ -798,7 +799,7 @@ void CKinematicsAnimated::Load(const char* N, IReader* data, u32 dwFlags)
 		else
 		{
 			m_Motions.pop_back();
-			Msg("! error in model [%s]. Unable to load motion file '%s'.", N, _path);
+			Msg("! error in model [%s]. Unable to load motion file '%s', section '%s'.", N, _path, current_player_hud_sect.c_str());
 		}
 	};
 
@@ -808,7 +809,7 @@ void CKinematicsAnimated::Load(const char* N, IReader* data, u32 dwFlags)
 		string_path items_nm;
 		data->r_stringZ(items_nm, sizeof(items_nm));
 		u32 set_cnt = _GetItemCount(items_nm);
-		R_ASSERT(set_cnt<MAX_ANIM_SLOT);
+		R_ASSERT2(set_cnt<MAX_ANIM_SLOT, make_string("section '%s'\nmodel '%s'", current_player_hud_sect.c_str(), N).c_str());
 		m_Motions.reserve(set_cnt);
 		string_path nm;
 		for (u32 k = 0; k < set_cnt; ++k)
@@ -853,7 +854,7 @@ void CKinematicsAnimated::Load(const char* N, IReader* data, u32 dwFlags)
 		m_Motions.back().motions.create(nm, data, bones);
 	}
 
-	R_ASSERT(m_Motions.size());
+	R_ASSERT2(m_Motions.size(), make_string("section '%s'\nmodel '%s'", current_player_hud_sect.c_str(), N).c_str());
 
 	m_Partition = m_Motions[0].motions.partition();
 	m_Partition->load(this, N);
diff --git a/src/Layers/xrRender/WallmarksEngine.cpp b/src/Layers/xrRender/WallmarksEngine.cpp
index d0592f8..141f50c 100644
--- a/src/Layers/xrRender/WallmarksEngine.cpp
+++ b/src/Layers/xrRender/WallmarksEngine.cpp
@@ -34,7 +34,7 @@ namespace WallmarksEngine
 const float W_DIST_FADE = 15.f;
 const float W_DIST_FADE_SQR = W_DIST_FADE * W_DIST_FADE;
 const float I_DIST_FADE_SQR = 1.f / W_DIST_FADE_SQR;
-const int MAX_TRIS = 1024;
+const int MAX_TRIS = 1024 * 16;
 
 IC bool operator ==(const CWallmarksEngine::wm_slot* slot, const ref_shader& shader) { return slot->shader == shader; }
 
diff --git a/src/build_config_defines.h b/src/build_config_defines.h
index 3f15b2c..8158b52 100644
--- a/src/build_config_defines.h
+++ b/src/build_config_defines.h
@@ -6,7 +6,7 @@
 #define INVENTORY_UPGRADE_CALLBACKS						// calls lua function inventory_upgrades.effect_upgrade_item
 #define ACTOR_BEFORE_DEATH_CALLBACK						// For extending the life of the actor to fake death or do other tasks that need to happen before actor is dead
 #define INPUT_CALLBACKS									// (eKeyPress, eKeyRelease, eKeyHold)
-//#define MOUSE_INPUT_CALLBACKS							// (eMouseMove, eMouseWheel)
+#define MOUSE_INPUT_CALLBACKS							// (eMouseMove, eMouseWheel)
 #define ENGINE_LUA_ALIFE_STORAGE_MANAGER_CALLBACKS		// calls lua functions from engine in a script named alife_storage_manager.script  (alife_storage_manager.CALifeStorageManager_save) and (alife_storage_manager.CALifeStorageManager_load)
 #define ENGINE_LUA_ALIFE_UPDAGE_MANAGER_CALLBACKS		// calls lua function named on_before_change_level and on_after_new_game in _G.script when enabled
 //-CALLBACKS
diff --git a/src/xrCore/Xr_ini.cpp b/src/xrCore/Xr_ini.cpp
index 3f5ac84..cce213c 100644
--- a/src/xrCore/Xr_ini.cpp
+++ b/src/xrCore/Xr_ini.cpp
@@ -3,6 +3,14 @@
 
 #include "fs_internal.h"
 
+#include <functional>
+#include <regex>
+#include <unordered_map>
+#include <unordered_set>
+#include <vector>
+#include <algorithm>
+#include "mezz_stringbuffer.h"
+
 XRCORE_API CInifile const* pSettings = NULL;
 XRCORE_API CInifile const* pSettingsAuth = NULL;
 
@@ -177,8 +185,19 @@ CInifile::~CInifile()
 		xr_delete(*I);
 }
 
+std::unordered_map<std::string, std::vector<CInifile::Item>> OverrideModifyListData;
+
 static void insert_item(CInifile::Sect* tgt, const CInifile::Item& I)
 {
+	// demonized
+	// DLTX: add or remove item from the section parameter if it has a structure of "name = item1, item2, item3, ..."
+	// >name = item will add item to the list
+	// <name = item will remove item from the list
+	if (*I.first && (I.first.c_str()[0] == '<' || I.first.c_str()[0] == '>')) {
+		OverrideModifyListData[std::string(tgt->Name.c_str())].push_back(I);
+		return;
+	}
+
 	CInifile::SectIt_ sect_it = std::lower_bound(tgt->Data.begin(), tgt->Data.end(), *I.first, item_pred);
 	if (sect_it != tgt->Data.end() && sect_it->first.equal(I.first))
 	{
@@ -210,212 +229,750 @@ void CInifile::Load(IReader* F, LPCSTR path
 )
 {
 	R_ASSERT(F);
-	Sect* Current = 0;
-	string4096 str;
-	string4096 str2;
 
-	BOOL bInsideSTR = FALSE;
+	std::string DLTX_DELETE = "DLTX_DELETE";
 
-	while (!F->eof())
+	std::function<void(std::vector<std::string>*, std::vector<std::string>*, bool)> MergeParentSet = [](std::vector<std::string>* ParentsBase, std::vector<std::string>* ParentsOverride, bool bIncludeRemovers)
 	{
-		F->r_string(str, sizeof(str));
-		_Trim(str);
-		LPSTR comm = strchr(str, ';');
-		LPSTR comm_1 = strchr(str, '/');
-
-		if (comm_1 && (*(comm_1 + 1) == '/') && ((!comm) || (comm && (comm_1 < comm))))
+		for (std::string CurrentParent : *ParentsOverride)
 		{
-			comm = comm_1;
+			bool bIsParentRemoval = CurrentParent[0] == '!';
+
+			std::string StaleParentString = (!bIsParentRemoval ? "!" : "") + CurrentParent.substr(1);
+
+			for (auto It = ParentsBase->rbegin(); It != ParentsBase->rend(); It++)
+			{
+				if (*It == StaleParentString)
+				{
+					ParentsBase->erase(std::next(It).base());
+				}
+			}
+
+			if (bIncludeRemovers || !bIsParentRemoval)
+			{
+				ParentsBase->insert(ParentsBase->end(), CurrentParent);
+			}
 		}
+	};
+
+	string_path currentFileName;
+	std::unordered_map<std::string, std::unordered_map<std::string, bool>> OverrideToFilename;
+	std::unordered_map<std::string, std::string> SectionToFilename;
+
+	std::function<void
+		(
+		IReader*,
+		LPCSTR,
+		std::unordered_map<std::string, Sect>*,
+		std::unordered_map<std::string, std::vector<std::string>>*,
+		BOOL,
+		BOOL
+		)
+	> LTXLoad = [&]
+		(
+		IReader* F,
+		LPCSTR path,
+		std::unordered_map<std::string, Sect>* OutputData,
+		std::unordered_map<std::string, std::vector<std::string>>* ParentDataMap,
+		BOOL bOverridesOnly,
+		BOOL bIsRootFile
+		)
+	{
+		Sect* Current = 0;
+		MezzStringBuffer str;
+		MezzStringBuffer str2;
 
-#ifdef DEBUG
-        LPSTR comment = 0;
-#endif
-		if (comm)
+		BOOL bInsideSTR = FALSE;
+
+		BOOL bIsCurrentSectionOverride = FALSE;
+		BOOL bHasLoadedModFiles = FALSE;
+
+		std::function<std::vector<std::string>*(std::string)> GetParentStrings = [&](std::string SectionName)
 		{
-			//."bla-bla-bla;nah-nah-nah"
-			char quot = '"';
-			bool in_quot = false;
+			auto It = ParentDataMap->find(SectionName);
 
-			LPCSTR q1 = strchr(str, quot);
-			if (q1 && q1 < comm)
+			if (It == ParentDataMap->end())
 			{
-				LPCSTR q2 = strchr(++q1, quot);
-				if (q2 && q2 > comm)
-					in_quot = true;
+				ParentDataMap->insert(std::pair<std::string, std::vector<std::string>>(SectionName, std::vector<std::string>()));
+
+				It = ParentDataMap->find(SectionName);
 			}
 
-			if (!in_quot)
+			return &It->second;
+		};
+
+		auto GetParentsSetFromString = [&](const char* ParentString)
+		{
+			std::vector<std::string> ParentSet = std::vector<std::string>();
+
+			u32 ItemCount = _GetItemCount(ParentString);
+
+			for (u32 i = 0; i < ItemCount; i++)
 			{
-				*comm = 0;
-#ifdef DEBUG
-                comment = comm + 1;
-#endif
+				_GetItem(ParentString, i, str2, str2.GetSize());
+
+				ParentSet.insert(ParentSet.end(), str2.GetBuffer());
 			}
-		}
 
+			return ParentSet;
+		};
+
+		auto GetRegexMatch = [](std::string InputString, std::string PatternString)
+		{
+			std::regex Pattern = std::regex(PatternString);
+			std::smatch MatchResult;
+
+			std::regex_search(InputString, MatchResult, Pattern);
+
+			if (MatchResult.begin() == MatchResult.end())
+			{
+				return std::string();
+			}
+
+			return MatchResult.begin()->str();
+		};
+
+		auto IsFullRegexMatch = [](std::string InputString, std::string PatternString)
+		{
+			return std::regex_match(InputString, std::regex(PatternString));
+		};
 
-		if (str[0] && (str[0] == '#') && strstr(str, "#include")) //handle includes
+		const auto loadFile = [&, LTXLoad](const string_path _fn, const string_path inc_path, const string_path name)
 		{
-			string_path inc_name;
-			R_ASSERT(path&&path[0]);
-			if (_GetItem(str, 1, inc_name, '"'))
+			if (!allow_include_func || allow_include_func(_fn))
 			{
-				string_path fn, inc_path, folder;
-				strconcat(sizeof(fn), fn, path, inc_name);
-				_splitpath(fn, inc_path, folder, 0, 0);
-				xr_strcat(inc_path, sizeof(inc_path), folder);
+				IReader* I = FS.r_open(_fn);
+				R_ASSERT3(I, "Can't find include file:", name);
+
+				strcpy(currentFileName, name);
 
-				const auto loadFile = [&](const string_path _fn, const string_path name)
+				LTXLoad(I, inc_path, OutputData, ParentDataMap, bOverridesOnly, false);
+
+				FS.r_close(I);
+			}
+		};
+
+		auto StashCurrentSection = [&]()
+		{
+			if (Current && bIsCurrentSectionOverride == bOverridesOnly)
+			{
+				//store previous section
+				auto SectIt = OutputData->find(std::string(Current->Name.c_str()));
+				if (SectIt != OutputData->end())
 				{
-					if (!allow_include_func || allow_include_func(_fn))
+					if (!bIsCurrentSectionOverride)
 					{
-						IReader* I = FS.r_open(_fn);
-						R_ASSERT3(I, "Can't find include file:", name);
-						Load(I, inc_path, allow_include_func);
-						FS.r_close(I);
-					}
-				};
 
-				if (strstr(inc_name, "*.ltx"))
-				{
-					FS_FileSet fset;
-					FS.file_list(fset, inc_path, FS_ListFiles, inc_name);
+						Debug.fatal(DEBUG_INFO, "Duplicate section '%s' wasn't marked as an override.\n\nOverride section by prefixing it with '!' (![%s]) or give it a unique name.\n\nCheck this file and its DLTX mods:\n\"%s\",\nfile with section \"%s\",\nfile with duplicate \"%s\"", *Current->Name, *Current->Name, m_file_name, SectionToFilename[std::string(Current->Name.c_str())].c_str(), currentFileName);
+					}
 
-					for (FS_FileSet::iterator it = fset.begin(); it != fset.end(); it++)
+					//Overwrite existing override data
+					for (Item CurrentItem : Current->Data)
 					{
-						LPCSTR _name = it->name.c_str();
-						string_path _fn;
-						strconcat(sizeof(_fn), _fn, inc_path, _name);
-						loadFile(_fn, _name);
+						insert_item(&SectIt->second, CurrentItem);
 					}
+
+					OverrideToFilename[SectIt->first][currentFileName] = true;
 				}
 				else
-					loadFile(fn, inc_name);
+				{
+					OutputData->emplace(std::pair<std::string, Sect>(std::string(Current->Name.c_str()), *Current));
+					OverrideToFilename[std::string(Current->Name.c_str())][currentFileName] = true;
+					SectionToFilename[std::string(Current->Name.c_str())] = currentFileName;
+				}
 			}
-		}
-		else if (str[0] && (str[0] == '[')) //new section ?
+
+			Current = NULL;
+		};
+
+		std::unordered_set<std::string> sectionsMarkedForCreate;
+
+		while (!F->eof() || (bIsRootFile && !bHasLoadedModFiles))
 		{
-			// insert previous filled section
-			if (Current)
+			if (!F->eof())
 			{
-				//store previous section
-				RootIt I = std::lower_bound(DATA.begin(), DATA.end(), *Current->Name, sect_pred);
-				if ((I != DATA.end()) && ((*I)->Name == Current->Name))
-					Debug.fatal(DEBUG_INFO, "Duplicate section '%s' found.", *Current->Name);
-				DATA.insert(I, Current);
+				F->r_string(str, str.GetSize());
+				_Trim(str);
+			}
+			else if (!bHasLoadedModFiles && bIsRootFile)
+			{
+				StashCurrentSection();
+				bHasLoadedModFiles = TRUE;
+
+				if (!m_file_name[0])
+				{
+					continue;
+				}
+
+				//Assemble paths and filename
+				MezzStringBuffer split_drive;
+				MezzStringBuffer split_dir;
+				MezzStringBuffer split_name;
+
+				_splitpath_s(m_file_name, split_drive, split_drive.GetSize(), split_dir, split_dir.GetSize(), split_name, split_name.GetSize(), NULL, 0);
+
+				std::string FilePath = std::string(split_drive) + std::string(split_dir);
+				std::string FileName = split_name;
+
+				//Collect all files that could potentially be confused as a root file by our mod files
+				FS_FileSet AmbiguousFiles;
+				FS.file_list(AmbiguousFiles, FilePath.c_str(), FS_ListFiles, (FileName + "_*.ltx").c_str());
+
+				//Collect all matching mod files
+				FS_FileSet ModFiles;
+				FS.file_list(ModFiles, FilePath.c_str(), FS_ListFiles, ("mod_" + FileName + "_*.ltx").c_str());
+
+				for (auto It = ModFiles.begin(); It != ModFiles.end(); ++It)
+				{
+					std::string ModFileName = It->name.c_str();
+
+					//Determine if we should load this mod file, or if it's meant for a different root file
+					BOOL bIsModfileMeantForMe = [&]()
+					{
+						for (auto It2 = AmbiguousFiles.begin(); It2 != AmbiguousFiles.end(); ++It2)
+						{
+							std::string AmbiguousFileName = GetRegexMatch(It2->name.c_str(), "^.+(?=.ltx$)");
+							std::string AmbiguousFileMatchPattern = std::string("mod_") + AmbiguousFileName + std::string("_.+.ltx");
+
+							if (IsFullRegexMatch(ModFileName, AmbiguousFileMatchPattern))
+							{
+								return false;
+							}
+						}
+
+						return true;
+					}();
+
+					if (!bIsModfileMeantForMe)
+					{
+						continue;
+					}
+
+					loadFile((FilePath + ModFileName).c_str(), FilePath.c_str(), ModFileName.c_str());
+				}
+
+				continue;
+			}
+
+			LPSTR comm = strchr(str, ';');
+			LPSTR comm_1 = strchr(str, '/');
+
+			if (comm_1 && (*(comm_1 + 1) == '/') && ((!comm) || (comm && (comm_1 < comm))))
+			{
+				comm = comm_1;
+			}
+
+#ifdef DEBUG
+			LPSTR comment = 0;
+#endif
+			if (comm)
+			{
+				//."bla-bla-bla;nah-nah-nah"
+				char quot = '"';
+				bool in_quot = false;
+
+				LPCSTR q1 = strchr(str, quot);
+				if (q1 && q1 < comm)
+				{
+					LPCSTR q2 = strchr(++q1, quot);
+					if (q2 && q2 > comm)
+						in_quot = true;
+				}
+
+				if (!in_quot)
+				{
+					*comm = 0;
+#ifdef DEBUG
+					comment = comm + 1;
+#endif
+				}
 			}
-			Current = xr_new<Sect>();
-			Current->Name = 0;
-			// start new section
-			R_ASSERT3(strchr(str, ']'), "Bad ini section found: ", str);
-			LPCSTR inherited_names = strstr(str, "]:");
-			if (0 != inherited_names)
+
+			_Trim(str);
+
+			auto isOverrideSection = [](char* str) {
+				return strstr(str, "![") == &str[0];
+			};
+
+			auto isSafeOverrideSection = [](char* str) {
+				return strstr(str, "@[") == &str[0];
+			};
+
+			auto isModSection = [isOverrideSection, isSafeOverrideSection](char* str) {
+				return isOverrideSection(str) || isSafeOverrideSection(str);
+			};
+
+			if (str[0] && (str[0] == '#') && strstr(str, "#include")) //handle includes
 			{
-				VERIFY2(m_flags.test(eReadOnly), "Allow for readonly mode only.");
-				inherited_names += 2;
-				u32 cnt = _GetItemCount(inherited_names);
-				u32 total_count = 0;
-				u32 k = 0;
-				for (k = 0; k < cnt; ++k)
+				string_path inc_name;
+				R_ASSERT(path && path[0]);
+				if (_GetItem(str, 1, inc_name, '"'))
 				{
-					string512 tmp;
-					_GetItem(inherited_names, k, tmp);
-					Sect& inherited_section = r_section(tmp);
-					total_count += inherited_section.Data.size();
+					string_path fn, inc_path, folder;
+					strconcat(sizeof(fn), fn, path, inc_name);
+					_splitpath(fn, inc_path, folder, 0, 0);
+					xr_strcat(inc_path, sizeof(inc_path), folder);
+
+
+					if (strstr(inc_name, "*.ltx"))
+					{
+						FS_FileSet fset;
+						FS.file_list(fset, inc_path, FS_ListFiles, inc_name);
+
+						for (FS_FileSet::iterator it = fset.begin(); it != fset.end(); it++)
+						{
+							LPCSTR _name = it->name.c_str();
+							string_path _fn;
+							strconcat(sizeof(_fn), _fn, inc_path, _name);
+							loadFile(_fn, inc_path, _name);
+						}
+					}
+					else
+						loadFile(fn, inc_path, inc_name);
 				}
 
-				Current->Data.reserve(Current->Data.size() + total_count);
+				continue;
+			}
+			else if (str[0] && strstr(str, "!![") == &str[0])	//Section delete
+			{
+				StashCurrentSection();
 
-				for (k = 0; k < cnt; ++k)
+				if (!bOverridesOnly)
 				{
-					string512 tmp;
-					_GetItem(inherited_names, k, tmp);
-					Sect& inherited_section = r_section(tmp);
-					for (SectIt_ it = inherited_section.Data.begin(); it != inherited_section.Data.end(); it++)
-						insert_item(Current, *it);
+					continue;
 				}
+
+				Current = xr_new<Sect>();
+				*strchr(str, ']') = 0;
+				Current->Name = strlwr(&str[3]);
+
+				bIsCurrentSectionOverride = true;
+
+				Item DeleteItem;
+				DeleteItem.first = DLTX_DELETE.c_str();
+				DeleteItem.second = "";
+
+				insert_item(Current, DeleteItem);
+
+				continue;
 			}
-			*strchr(str, ']') = 0;
-			Current->Name = strlwr(str + 1);
-		}
-		else // name = value
-		{
-			if (Current)
+			else if ((str[0] && (str[0] == '[')) || isModSection(str)) //new section ?
+			{
+				// insert previous filled section
+				StashCurrentSection();
+
+				u32 SectionNameStartPos = (isModSection(str) ? 2 : 1);
+				std::string SecName = std::string(str).substr(SectionNameStartPos, strchr(str, ']') - str - SectionNameStartPos).c_str();
+				for (auto i = SecName.begin(); i != SecName.end(); ++i)
+				{
+					*i = tolower(*i);
+				}
+				
+				if (isOverrideSection(str)) { //Used to detect bad or unintended overrides
+					bIsCurrentSectionOverride = true;
+				} else if (isSafeOverrideSection(str)) { // Create section if it doesnt exist, override if it does
+					bIsCurrentSectionOverride = true;
+					if (bOverridesOnly) {
+						// Msg("using @[, override existing section %s", SecName.c_str());
+					} else {
+						auto SectIt = OutputData->find(SecName);
+						if (SectIt != OutputData->end()) {
+							// Msg("using @[, override existing section %s", SecName.c_str());
+						} else {
+							// Msg("using @[, create new section %s", SecName.c_str());
+							sectionsMarkedForCreate.insert(SecName);
+						}
+					}
+				} else {
+					bIsCurrentSectionOverride = false;
+				}
+
+				Current = xr_new<Sect>();
+				Current->Name = SecName.c_str();
+
+				// start new section
+				R_ASSERT3(strchr(str, ']'), "Bad ini section found: ", str);
+
+				if (bIsCurrentSectionOverride == bOverridesOnly)
+				{
+					LPCSTR inherited_names = strstr(str, "]:");
+					if (0 != inherited_names)
+					{
+						VERIFY2(m_flags.test(eReadOnly), "Allow for readonly mode only.");
+						inherited_names += 2;
+
+						std::vector<std::string> CurrentParents = GetParentsSetFromString(inherited_names);
+						std::vector<std::string>* SectionParents = GetParentStrings(Current->Name.c_str());
+
+						MergeParentSet(SectionParents, &CurrentParents, true);
+					}
+				}
+
+				continue;
+			}
+			else // name = value
 			{
-				string4096 value_raw;
-				char* name = str;
-				char* t = strchr(name, '=');
-				if (t)
+				if (Current && bIsCurrentSectionOverride == bOverridesOnly)
 				{
-					*t = 0;
-					_Trim(name);
-					++t;
-					xr_strcpy(value_raw, sizeof(value_raw), t);
-					bInsideSTR = _parse(str2, value_raw);
-					if (bInsideSTR) //multiline str value
+					bool bIsDelete = str[0] == '!';
+
+					MezzStringBuffer value_raw;
+					char* name = (char*) (str + (bIsDelete ? 1 : 0));
+					char* t = strchr(name, '=');
+					if (t)
 					{
-						while (bInsideSTR)
+						*t = 0;
+						_Trim(name);
+						++t;
+						xr_strcpy(value_raw, value_raw.GetSize(), t);
+						bInsideSTR = _parse(str2, value_raw);
+						if (bInsideSTR) //multiline str value
 						{
-							xr_strcat(value_raw, sizeof(value_raw), "\r\n");
-							string4096 str_add_raw;
-							F->r_string(str_add_raw, sizeof(str_add_raw));
-							R_ASSERT2(
-								xr_strlen(value_raw) + xr_strlen(str_add_raw) < sizeof(value_raw),
-								make_string(
-									"Incorrect inifile format: section[%s], variable[%s]. Odd number of quotes (\") found, but should be even."
-									,
-									Current->Name.c_str(),
-									name
-								)
-							);
-							xr_strcat(value_raw, sizeof(value_raw), str_add_raw);
-							bInsideSTR = _parse(str2, value_raw);
-							if (bInsideSTR)
+							while (bInsideSTR)
 							{
-								if (is_empty_line_now(F))
-									xr_strcat(value_raw, sizeof(value_raw), "\r\n");
+								xr_strcat(value_raw, value_raw.GetSize(), "\r\n");
+								MezzStringBuffer str_add_raw;
+								F->r_string(str_add_raw, str_add_raw.GetSize());
+								R_ASSERT2(
+									xr_strlen(value_raw) + xr_strlen(str_add_raw) < value_raw.GetSize(),
+									make_string(
+										"Incorrect inifile format: section[%s], variable[%s]. Odd number of quotes (\") found, but should be even."
+										,
+										Current->Name.c_str(),
+										name
+									)
+								);
+								xr_strcat(value_raw, value_raw.GetSize(), str_add_raw);
+								bInsideSTR = _parse(str2, value_raw);
+								if (bInsideSTR)
+								{
+									if (is_empty_line_now(F))
+										xr_strcat(value_raw, value_raw.GetSize(), "\r\n");
+								}
 							}
 						}
 					}
+					else
+					{
+						_Trim(name);
+						str2[0] = 0;
+					}
+
+					Item I;
+					I.first = (name[0] ? name : NULL);
+					I.second = bIsDelete ? DLTX_DELETE.c_str() : (str2[0] ? str2.GetBuffer() : NULL);
+
+					if (*I.first || *I.second)
+					{
+						insert_item(Current, I);
+					}
+				}
+
+				continue;
+			}
+		}
+
+		StashCurrentSection();
+
+		// Create empty sections that were marked with @[ and weren't defined normally
+		if (!bOverridesOnly) {
+			for (auto& SecName : sectionsMarkedForCreate) {
+				auto SectIt = OutputData->find(SecName);
+				if (SectIt == OutputData->end()) {
+					// Msg("section %s does not exist but was marked as @[, creating", SecName.c_str());
+					Current = xr_new<Sect>();
+					Current->Name = SecName.c_str();
+					OutputData->emplace(std::pair<std::string, Sect>(std::string(Current->Name.c_str()), *Current));
+					OverrideToFilename[std::string(Current->Name.c_str())][currentFileName] = true;
+					SectionToFilename[std::string(Current->Name.c_str())] = currentFileName;
+					Current = NULL;
+				}
+			}
+		}
+	};
+
+	std::unordered_map<std::string, std::vector<std::string>> BaseParentDataMap;
+	std::unordered_map<std::string, Sect> BaseData;
+
+	std::unordered_map<std::string, std::vector<std::string>> OverrideParentDataMap;
+	std::unordered_map<std::string, Sect> OverrideData;
+
+	std::unordered_map<std::string, Sect> FinalData;
+
+	std::unordered_set<std::string> FinalizedSections;
+
+	enum InsertType
+	{
+		Override,
+		Base,
+		Parent
+	};
+
+	std::function<void(std::string, std::vector<std::string>*)> EvaluateSection = [&](std::string SectionName, std::vector<std::string>* PreviousEvaluations)
+	{
+		if (FinalizedSections.find(SectionName) != FinalizedSections.end())
+		{
+			return;
+		}
+
+		PreviousEvaluations->insert(PreviousEvaluations->end(), SectionName);
+
+		std::vector<std::string>* BaseParents = &BaseParentDataMap.find(SectionName)->second;
+		std::vector<std::string>* OverrideParents = &OverrideParentDataMap.find(SectionName)->second;
+
+		BOOL bDeleteSectionIfEmpty = FALSE;
+
+		MergeParentSet(BaseParents, OverrideParents, false);
+
+		std::pair<std::string, Sect> CurrentSecPair = std::pair<std::string, Sect>(SectionName, Sect());
+		Sect* CurrentSect = &CurrentSecPair.second;
+		CurrentSect->Name = SectionName.c_str();
+
+		auto IsStringDLTXDelete = [&](shared_str str)
+		{
+			const char* RawString = str.c_str();
+
+			return RawString && std::string(RawString) == DLTX_DELETE;
+		};
+
+		auto InsertItemWithDelete = [&](Item CurrentItem, InsertType Type)
+		{
+			if (IsStringDLTXDelete(CurrentItem.first))
+			{
+				//Delete section
+				bDeleteSectionIfEmpty = TRUE;
+			}
+			else
+			{
+				//Insert item if variable isn't already set
+				CInifile::SectIt_ sect_it = std::lower_bound(CurrentSect->Data.begin(), CurrentSect->Data.end(), *CurrentItem.first, item_pred);
+				if (sect_it != CurrentSect->Data.end() && sect_it->first.equal(CurrentItem.first))
+				{
+					bool bShouldInsert = [&]()
+					{
+						switch (Type)
+						{
+						case InsertType::Override:		return true;
+						case InsertType::Base:			return false;
+						case InsertType::Parent:		return IsStringDLTXDelete(sect_it->second);
+						}
+					}();
+
+					if (bShouldInsert)
+					{
+						sect_it->second = CurrentItem.second;
+					}
 				}
 				else
 				{
-					_Trim(name);
-					str2[0] = 0;
+					CurrentSect->Data.insert(sect_it, CurrentItem);
 				}
+			}
+		};
 
-				Item I;
-				I.first = (name[0] ? name : NULL);
-				I.second = (str2[0] ? str2 : NULL);
-				//#ifdef DEBUG
-				// I.comment = m_flags.test(eReadOnly)?0:comment;
-				//#endif
+		//Insert variables of own data
+		auto InsertData = [&](std::unordered_map<std::string, Sect>* Data, BOOL bIsBase)
+		{
+			auto It = Data->find(SectionName);
 
-				if (m_flags.test(eReadOnly))
+			if (It != Data->end())
+			{
+				Sect* DataSection = &It->second;
+				for (Item CurrentItem : DataSection->Data)
 				{
-					if (*I.first) insert_item(Current, I);
+					InsertItemWithDelete(CurrentItem, bIsBase ? Base : Override);
 				}
-				else
+
+				if (!bIsBase)
 				{
-					if (
-						*I.first
-						|| *I.second
-							//#ifdef DEBUG
-							// || *I.comment
-							//#endif
-					)
-						insert_item(Current, I);
+					Data->erase(It);
+				}
+			}
+		};
+
+		InsertData(&OverrideData, false);
+		InsertData(&BaseData, true);
+
+		//Insert variables from parents
+		for (auto It = BaseParents->rbegin(); It != BaseParents->rend(); ++It)
+		{
+			std::string ParentSectionName = *(It.base() - 1);
+
+			for (auto It = PreviousEvaluations->begin(); It != PreviousEvaluations->end(); ++It)
+			{
+				if (ParentSectionName == *It)
+				{
+					Debug.fatal(DEBUG_INFO, "Section '%s' has cyclical dependencies. Ensure that sections with parents don't inherit in a loop. Check this file and its DLTX mods: %s, mod file %s", ParentSectionName.c_str(), m_file_name, currentFileName);
+				}
+			}
+
+			EvaluateSection(ParentSectionName, PreviousEvaluations);
+
+			auto ParentIt = FinalData.find(ParentSectionName);
+
+			if (ParentIt == FinalData.end())
+			{
+				Debug.fatal(DEBUG_INFO, "Section '%s' inherits from non-existent section '%s'. Check this file and its DLTX mods: %s, mod file %s", SectionName.c_str(), ParentSectionName.c_str(), m_file_name, currentFileName);
+			}
+
+			Sect* ParentSec = &ParentIt->second;
+
+			for (Item CurrentItem : ParentSec->Data)
+			{
+				InsertItemWithDelete(CurrentItem, Parent);
+			}
+		}
+
+		//Delete entries that are still marked DLTX_DELETE
+		for (auto It = CurrentSect->Data.rbegin(); It != CurrentSect->Data.rend(); ++It)
+		{
+			if (IsStringDLTXDelete(It->second))
+			{
+				CurrentSect->Data.erase(It.base() - 1);
+			}
+		}
+
+		// If there is data to modify parameters lists
+		if (OverrideModifyListData.find(std::string(CurrentSect->Name.c_str())) != OverrideModifyListData.end()) {
+			for (auto It = OverrideModifyListData[std::string(CurrentSect->Name.c_str())].begin(); It != OverrideModifyListData[std::string(CurrentSect->Name.c_str())].end(); ++It) {
+				CInifile::Item &I = *It;
+
+				// If section exists with item list, split list and perform operation
+				char dltx_listmode = I.first[0];
+				I.first = I.first.c_str() + 1;
+
+				CInifile::SectIt_ sect_it = std::lower_bound(CurrentSect->Data.begin(), CurrentSect->Data.end(), *I.first, item_pred);
+				if (sect_it != CurrentSect->Data.end() && sect_it->first.equal(I.first)) {
+
+					//Msg("%s has dltx_listmode %s", I.first.c_str(), std::string(1, dltx_listmode).c_str());
+
+					if (dltx_listmode && sect_it->second != NULL) {
+						// Split list 
+						auto split_list = [](const std::string items, const std::string delimiter = ",") {
+							std::string i = items;
+							std::vector<std::string> vec;
+							size_t pos = 0;
+							std::string token;
+							while ((pos = i.find(delimiter)) != std::string::npos) {
+								token = i.substr(0, pos);
+								vec.push_back(token);
+								i.erase(0, pos + delimiter.length());
+							}
+							vec.push_back(i);
+
+							auto trim = [](std::string &s, const char* t = " \t\n\r\f\v") {
+								s.erase(s.find_last_not_of(t) + 1);
+								s.erase(0, s.find_first_not_of(t));
+							};
+							for (auto &item : vec) {
+								trim(item);
+							}
+							return vec;
+						};
+						std::vector<std::string> sect_it_items_vec = split_list(sect_it->second.c_str());
+						std::vector<std::string> I_items_vec = split_list(I.second.c_str());
+
+						// Add or remove to the list
+						auto find_and_store_index = [](const std::vector<std::string> &items_vec, const std::string item, int &vec_index) {
+							auto it = std::find(items_vec.begin(), items_vec.end(), item);
+							if (it != items_vec.end()) {
+								vec_index = it - items_vec.begin();
+								return true;
+							}
+							else {
+								vec_index = -1;
+								return false;
+							}
+						};
+						int vec_index = -1;
+						for (const auto &item : I_items_vec) {
+							if (dltx_listmode == '>') {
+								sect_it_items_vec.push_back(item);
+							}
+							else if (dltx_listmode == '<') {
+								while (find_and_store_index(sect_it_items_vec, item, vec_index)) {
+									sect_it_items_vec.erase(sect_it_items_vec.begin() + vec_index);
+								}
+							}
+						}
+
+						// Store result back
+						auto join_list = [](const std::vector<std::string> &items_vec, const std::string delimiter = ",") {
+							std::string ret;
+							for (const auto &i : items_vec) {
+								if (!ret.empty()) {
+									ret += delimiter;
+								}
+								ret += i;
+							}
+							return ret;
+						};
+
+						/*std::string c(1, dltx_listmode);
+						Msg("%s has dltx_listmode %s, %s items", I.first.c_str(), c.c_str(), dltx_listmode == '>' ? "adding" : "removing");
+						Msg("old %s", sect_it->second.c_str());
+						Msg("new %s", join_list(sect_it_items_vec).c_str());*/
+
+						sect_it->second = join_list(sect_it_items_vec, ",").c_str();
+					}
 				}
 			}
 		}
+		
+
+		//Pop from stack
+		auto LastElement = PreviousEvaluations->end();
+		LastElement--;
+
+		PreviousEvaluations->erase(LastElement);
+
+		//Finalize
+		if (!bDeleteSectionIfEmpty || CurrentSecPair.second.Data.size())
+		{
+			FinalData.emplace(CurrentSecPair);
+		}
+
+		FinalizedSections.insert(SectionName);
+	};
+
+	//Read contents of root file
+	LTXLoad(F, path, &OverrideData, &OverrideParentDataMap, true, true);
+	F->seek(0);
+	LTXLoad(F, path, &BaseData, &BaseParentDataMap, false, true);
+
+	//Merge base and override data together
+	std::vector<std::string> PreviousEvaluations = std::vector<std::string>();
+
+	for (std::pair<std::string, Sect> SectPair : BaseData)
+	{
+		EvaluateSection(SectPair.first, &PreviousEvaluations);
+	}
+
+	//Insert all finalized sections into final container
+	for (std::pair<std::string, Sect> SectPair : FinalData)
+	{
+		Sect* NewSect = xr_new<Sect>();
+		*NewSect = SectPair.second;
+
+		RootIt I = std::lower_bound(DATA.begin(), DATA.end(), SectPair.first.c_str(), sect_pred);
+		DATA.insert(I, NewSect);
 	}
-	if (Current)
+
+	// Clean modifiers of parameters' lists
+	OverrideModifyListData.clear();
+
+	//throw errors if there are overrides that never got used
+	if (OverrideData.size())
 	{
-		RootIt I = std::lower_bound(DATA.begin(), DATA.end(), *Current->Name, sect_pred);
-		if ((I != DATA.end()) && ((*I)->Name == Current->Name))
-			Debug.fatal(DEBUG_INFO, "Duplicate section '%s' found.", *Current->Name);
-		DATA.insert(I, Current);
+		//Debug.fatal(DEBUG_INFO, "Attemped to override section '%s', which doesn't exist. Ensure that a base section with the same name is loaded first. Check this file and its DLTX mods: %s", OverrideData.begin()->first.c_str(), m_file_name);
+		for (auto i = OverrideData.begin(); i != OverrideData.end(); i++) {
+			auto override_filenames = OverrideToFilename.find(i->first);
+			if (override_filenames != OverrideToFilename.end()) {
+				for (auto &override_filename : override_filenames->second) {
+					Msg("!!!DLTX ERROR Attemped to override section '%s', which doesn't exist. Ensure that a base section with the same name is loaded first. Check this file and its DLTX mods: %s, mod file %s", i->first.c_str(), m_file_name, override_filename.first.c_str());
+				}
+			}
+		}
 	}
 }
 
diff --git a/src/xrCore/mezz_stringbuffer.cpp b/src/xrCore/mezz_stringbuffer.cpp
new file mode 100644
index 0000000..13f0470
--- /dev/null
+++ b/src/xrCore/mezz_stringbuffer.cpp
@@ -0,0 +1,26 @@
+#include "stdafx.h"
+
+#include "mezz_stringbuffer.h"
+
+MezzStringBuffer::MezzStringBuffer(uint32_t Size)
+{
+	StringBuffer = std::make_unique<char[]>(Size);
+	BufferRaw = StringBuffer.get();
+
+	BufferSize = Size;
+}
+
+char* MezzStringBuffer::GetBuffer() const
+{
+	return BufferRaw;
+}
+
+uint32_t MezzStringBuffer::GetSize() const
+{
+	return BufferSize;
+}
+
+MezzStringBuffer::operator char* () const
+{
+	return BufferRaw;
+}
\ No newline at end of file
diff --git a/src/xrCore/mezz_stringbuffer.h b/src/xrCore/mezz_stringbuffer.h
new file mode 100644
index 0000000..9f42203
--- /dev/null
+++ b/src/xrCore/mezz_stringbuffer.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include <memory>
+#include <cstdint>
+
+class MezzStringBuffer
+{
+public:
+	MezzStringBuffer(uint32_t Size = 4096);
+
+	char* GetBuffer() const;
+	uint32_t GetSize() const;
+
+	operator char* () const;
+
+private:
+	std::unique_ptr<char[]> StringBuffer;
+
+	char* BufferRaw;
+	uint32_t BufferSize;
+};
\ No newline at end of file
diff --git a/src/xrCore/xrCore.vcxproj b/src/xrCore/xrCore.vcxproj
index 209d066..2d57efb 100644
--- a/src/xrCore/xrCore.vcxproj
+++ b/src/xrCore/xrCore.vcxproj
@@ -330,6 +330,7 @@
     <ClCompile Include="memory_allocation_stats.cpp" />
     <ClCompile Include="memory_monitor.cpp" />
     <ClCompile Include="memory_usage.cpp" />
+    <ClCompile Include="mezz_stringbuffer.cpp" />
     <ClCompile Include="Model.cpp">
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
       </PrecompiledHeader>
@@ -443,6 +444,7 @@
     <ClInclude Include="lzhuf.h" />
     <ClInclude Include="lzo_compressor.h" />
     <ClInclude Include="memory_monitor.h" />
+    <ClInclude Include="mezz_stringbuffer.h" />
     <ClInclude Include="net_utils.h" />
     <ClInclude Include="os_clipboard.h" />
     <ClInclude Include="PPMd.h" />
diff --git a/src/xrCore/xrCore.vcxproj.filters b/src/xrCore/xrCore.vcxproj.filters
index dd3958c..f39a6c6 100644
--- a/src/xrCore/xrCore.vcxproj.filters
+++ b/src/xrCore/xrCore.vcxproj.filters
@@ -280,6 +280,7 @@
     <ClCompile Include="ScopeLock.cpp">
       <Filter>Threading</Filter>
     </ClCompile>
+    <ClCompile Include="mezz_stringbuffer.cpp" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="FTimer.h">
@@ -589,6 +590,7 @@
     <ClInclude Include="ScopeLock.hpp">
       <Filter>Threading</Filter>
     </ClInclude>
+    <ClInclude Include="mezz_stringbuffer.h" />
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="xrCore.rc">
diff --git a/src/xrCore/xrDebugNew.cpp b/src/xrCore/xrDebugNew.cpp
index dd65e49..1c3a710 100644
--- a/src/xrCore/xrDebugNew.cpp
+++ b/src/xrCore/xrDebugNew.cpp
@@ -67,6 +67,20 @@ XRCORE_API xrDebug Debug;
 
 static bool error_after_dialog = false;
 
+namespace crash_saving
+{
+    void (*save_impl)() = nullptr;
+	BOOL enabled = TRUE;
+
+    void save()
+    {
+        if (enabled && save_impl != nullptr)
+        {
+            (*save_impl)();
+        }
+    }
+}
+
 //extern void BuildStackTrace();
 //extern char g_stackTrace[100][4096];
 //extern int g_stackTraceCount;
@@ -206,6 +220,9 @@ void xrDebug::do_exit(const std::string& message)
 void xrDebug::backend(const char* expression, const char* description, const char* argument0, const char* argument1,
                       const char* file, int line, const char* function, bool& ignore_always)
 {
+    // we save first
+    crash_saving::save();
+    
 	static xrCriticalSection CS
 #ifdef PROFILE_CRITICAL_SECTIONS
         (MUTEX_PROFILE_ID(xrDebug::backend))
@@ -232,7 +249,7 @@ void xrDebug::backend(const char* expression, const char* description, const cha
 	ShowCursor(true);
 	ShowWindow(GetActiveWindow(), SW_FORCEMINIMIZE);
 	MessageBox(
-		GetTopWindow(NULL),
+		NULL,
 		assertion_info,
 		"Fatal Error",
 		MB_OK | MB_ICONERROR | MB_SYSTEMMODAL
diff --git a/src/xrEngine/CameraManager.cpp b/src/xrEngine/CameraManager.cpp
index 4eb5146..206b3ac 100644
--- a/src/xrEngine/CameraManager.cpp
+++ b/src/xrEngine/CameraManager.cpp
@@ -225,6 +225,21 @@ void CCameraManager::RemoveCamEffector(ECamEffectorType type)
 		}
 }
 
+// demonized: removecameffector by pointer
+void CCameraManager::RemoveCamEffector(CEffectorCam* ef)
+{
+	for (EffectorCamIt it = m_EffectorsCam.begin(); it != m_EffectorsCam.end(); it++)
+	{
+		CEffectorCam* cam = (*it);
+		if (cam == ef)
+		{
+			OnEffectorReleased(cam);
+			m_EffectorsCam.erase(it);
+			return;
+		}
+	}
+}
+
 CEffectorPP* CCameraManager::GetPPEffector(EEffectorPPType type)
 {
 	for (EffectorPPIt it = m_EffectorsPP.begin(); it != m_EffectorsPP.end(); it++)
diff --git a/src/xrEngine/CameraManager.h b/src/xrEngine/CameraManager.h
index ca5bd2f..649a183 100644
--- a/src/xrEngine/CameraManager.h
+++ b/src/xrEngine/CameraManager.h
@@ -154,6 +154,9 @@ public:
 	CEffectorCam* GetCamEffector(ECamEffectorType type);
 	void RemoveCamEffector(ECamEffectorType type);
 
+	// demonized: removecameffector by pointer
+	void RemoveCamEffector(CEffectorCam* ef);
+
 	ECamEffectorType RequestCamEffectorId();
 	EEffectorPPType RequestPPEffectorId();
 	CEffectorPP* GetPPEffector(EEffectorPPType type);
diff --git a/src/xrEngine/FDemoRecord.cpp b/src/xrEngine/FDemoRecord.cpp
index aa96cfb..0499b90 100644
--- a/src/xrEngine/FDemoRecord.cpp
+++ b/src/xrEngine/FDemoRecord.cpp
@@ -20,7 +20,8 @@ BOOL stored_cross;
 BOOL stored_red_text;
 
 CDemoRecord* xrDemoRecord = 0;
-CDemoRecord::force_position CDemoRecord::g_position = {false, {0, 0, 0}};
+CDemoRecord::force_position CDemoRecord::g_position = { false, {0, 0, 0} };
+CDemoRecord::force_direction CDemoRecord::g_direction = {false, {0, 0, 0}};
 
 Fbox curr_lm_fbox;
 
@@ -77,6 +78,8 @@ CDemoRecord::CDemoRecord(const char* name, float life_time) : CEffectorCam(cefDe
 	m_b_redirect_input_to_level = false;
 	_unlink(name);
 	file = FS.w_open(name);
+	isInputBlocked = FALSE;
+	pDemoRecords = nullptr;
 	if (file)
 	{
 		g_position.set_position = false;
@@ -123,6 +126,23 @@ CDemoRecord::CDemoRecord(const char* name, float life_time) : CEffectorCam(cefDe
 	}
 }
 
+CDemoRecord::CDemoRecord(const char* name, std::unordered_set<CDemoRecord*>* pDemoRecords, BOOL isInputBlocked, float life_time) : CDemoRecord(name, life_time)
+{
+	pDemoRecords->insert(this);
+	this->pDemoRecords = pDemoRecords;
+	this->isInputBlocked = isInputBlocked;
+	if (!file) {
+		StopDemo();
+	}
+}
+
+void CDemoRecord::StopDemo() {
+	fLifeTime = -1;
+	if (pDemoRecords) {
+		pDemoRecords->erase(this);
+	}
+}
+
 CDemoRecord::~CDemoRecord()
 {
 	if (file)
@@ -130,6 +150,9 @@ CDemoRecord::~CDemoRecord()
 		IR_Release(); // release input
 		FS.w_close(file);
 	}
+	if (pDemoRecords) {
+		pDemoRecords->erase(this);
+	}
 	g_bDisableRedText = stored_red_text;
 
 	Device.seqRender.Remove(this);
@@ -372,6 +395,13 @@ BOOL CDemoRecord::ProcessCam(SCamEffectorInfo& info)
 		}
 		else
 			g_position.p.set(m_Position);
+
+		if (g_direction.set_direction)
+		{
+			m_HPB.set(g_direction.d);
+			g_direction.set_direction = false;
+		} else
+			g_direction.d.set(m_Position);
 		// move
 		Fvector vmove;
 
@@ -399,6 +429,9 @@ BOOL CDemoRecord::ProcessCam(SCamEffectorInfo& info)
 		info.p.set(m_Camera.c);
 
 		fLifeTime -= Device.fTimeDelta;
+		if (fLifeTime < 0) {
+			StopDemo();
+		}
 
 		m_vT.set(0, 0, 0);
 		m_vR.set(0, 0, 0);
@@ -420,43 +453,54 @@ void CDemoRecord::IR_OnMouseRelease(int btn)
 
 void CDemoRecord::IR_OnKeyboardPress(int dik)
 {
-	if (dik == DIK_MULTIPLY) m_b_redirect_input_to_level = !m_b_redirect_input_to_level;
-
-	if (m_b_redirect_input_to_level)
-	{
-		g_pGameLevel->IR_OnKeyboardPress(dik);
-		return;
-	}
-	if (dik == DIK_GRAVE)
-		Console->Show();
-	if (dik == DIK_SPACE) RecordKey();
-	if (dik == DIK_BACK) MakeCubemap();
-	if (dik == DIK_F11) MakeLevelMapScreenshot(IR_GetKeyState(DIK_LCONTROL));
-	if (dik == DIK_F12) MakeScreenshot();
-	if (dik == DIK_ESCAPE) fLifeTime = -1;
-
-	//Alundaio: Teleport to demo cam
-	//#ifndef MASTER_GOLD
-	if (dik == DIK_RETURN)
-	{
-		if (strstr(Core.Params, "-dbg"))
+	if (isInputBlocked) {
+		if (dik == DIK_PAUSE)
+			Device.Pause(!Device.Paused(), TRUE, TRUE, "demo_record");
+		if (dik == DIK_GRAVE)
+			Console->Show();
+		if (dik == DIK_ESCAPE)
+			Console->Execute("main_menu on");
+	} else {
+		if (dik == DIK_MULTIPLY) m_b_redirect_input_to_level = !m_b_redirect_input_to_level;
+
+		if (m_b_redirect_input_to_level)
 		{
-			if (g_pGameLevel->CurrentEntity())
+			g_pGameLevel->IR_OnKeyboardPress(dik);
+			return;
+		}
+		if (dik == DIK_GRAVE)
+			Console->Show();
+		if (dik == DIK_SPACE) RecordKey();
+		if (dik == DIK_BACK) MakeCubemap();
+		if (dik == DIK_F11) MakeLevelMapScreenshot(IR_GetKeyState(DIK_LCONTROL));
+		if (dik == DIK_F12) MakeScreenshot();
+		if (dik == DIK_ESCAPE) StopDemo();
+
+		//Alundaio: Teleport to demo cam
+		//#ifndef MASTER_GOLD
+		if (dik == DIK_RETURN)
+		{
+			if (strstr(Core.Params, "-dbg"))
 			{
-				g_pGameLevel->CurrentEntity()->ForceTransform(m_Camera);
-				fLifeTime = -1;
+				if (g_pGameLevel->CurrentEntity())
+				{
+					g_pGameLevel->CurrentEntity()->ForceTransform(m_Camera);
+					StopDemo();
+				}
 			}
 		}
-	}
-	//#endif // #ifndef MASTER_GOLD
-	//-Alundaio
+		//#endif // #ifndef MASTER_GOLD
+		//-Alundaio
 
-	if (dik == DIK_PAUSE)
-		Device.Pause(!Device.Paused(), TRUE, TRUE, "demo_record");
+		if (dik == DIK_PAUSE)
+			Device.Pause(!Device.Paused(), TRUE, TRUE, "demo_record");
+	}
+	
 }
 
 void CDemoRecord::IR_OnKeyboardRelease(int dik)
 {
+	if (isInputBlocked) return;
 	if (m_b_redirect_input_to_level)
 		g_pGameLevel->IR_OnKeyboardRelease(dik);
 }
@@ -471,6 +515,7 @@ static void update_whith_timescale(Fvector& v, const Fvector& v_delta)
 
 void CDemoRecord::IR_OnKeyboardHold(int dik)
 {
+	if (isInputBlocked) return;
 	if (m_b_redirect_input_to_level)
 	{
 		g_pGameLevel->IR_OnKeyboardHold(dik);
@@ -526,6 +571,7 @@ void CDemoRecord::IR_OnKeyboardHold(int dik)
 
 void CDemoRecord::IR_OnMouseMove(int dx, int dy)
 {
+	if (isInputBlocked) return;
 	if (m_b_redirect_input_to_level)
 	{
 		g_pGameLevel->IR_OnMouseMove(dx, dy);
@@ -545,6 +591,7 @@ void CDemoRecord::IR_OnMouseMove(int dx, int dy)
 
 void CDemoRecord::IR_OnMouseHold(int btn)
 {
+	if (isInputBlocked) return;
 	if (m_b_redirect_input_to_level)
 	{
 		g_pGameLevel->IR_OnMouseHold(btn);
diff --git a/src/xrEngine/FDemoRecord.h b/src/xrEngine/FDemoRecord.h
index 2e8de06..5890079 100644
--- a/src/xrEngine/FDemoRecord.h
+++ b/src/xrEngine/FDemoRecord.h
@@ -6,6 +6,8 @@
 #include "iinputreceiver.h"
 #include "effector.h"
 
+#include <unordered_set>
+
 class ENGINE_API CDemoRecord :
 	public CEffectorCam,
 	public IInputReceiver,
@@ -18,6 +20,12 @@ private:
 		Fvector p;
 	} g_position;
 
+	static struct force_direction
+	{
+		bool set_direction;
+		Fvector d;
+	} g_direction;
+
 	int iCount;
 	IWriter* file;
 	Fvector m_HPB;
@@ -44,6 +52,9 @@ private:
 	float m_fAngSpeed2;
 	float m_fAngSpeed3;
 
+	BOOL isInputBlocked;
+	std::unordered_set<CDemoRecord*>* pDemoRecords;
+
 	void MakeCubeMapFace(Fvector& D, Fvector& N);
 	void MakeLevelMapProcess();
 	void MakeScreenshotFace();
@@ -53,6 +64,7 @@ private:
 	void MakeLevelMapScreenshot(BOOL bHQ);
 public:
 	CDemoRecord(const char* name, float life_time = 60 * 60 * 1000);
+	CDemoRecord(const char* name, std::unordered_set<CDemoRecord*>* pDemoRecords, BOOL isInputBlocked = 0, float life_time = 60 * 60 * 1000);
 	virtual ~CDemoRecord();
 
 	virtual void IR_OnKeyboardPress(int dik);
@@ -62,10 +74,13 @@ public:
 	virtual void IR_OnMouseHold(int btn);
 	virtual void IR_OnMousePress(int btn);
 	virtual void IR_OnMouseRelease(int btn);
+	void StopDemo();
 
 	virtual BOOL ProcessCam(SCamEffectorInfo& info);
 	static void SetGlobalPosition(const Fvector& p) { g_position.p.set(p), g_position.set_position = true; }
 	static void GetGlobalPosition(Fvector& p) { p.set(g_position.p); }
+	static void SetGlobalDirection(const Fvector& d) { g_direction.d.set(d), g_direction.set_direction = true; }
+	static void GetGlobalDirection(Fvector& d) { d.set(g_direction.d); }
 	BOOL m_b_redirect_input_to_level;
 	virtual void OnRender();
 };
diff --git a/src/xrEngine/xr_ioc_cmd.cpp b/src/xrEngine/xr_ioc_cmd.cpp
index a1ec515..b206c4e 100644
--- a/src/xrEngine/xr_ioc_cmd.cpp
+++ b/src/xrEngine/xr_ioc_cmd.cpp
@@ -833,6 +833,18 @@ public:
 	}
 };
 
+class CCC_SoundParamsSmoothing : public CCC_Integer
+{
+public:
+	CCC_SoundParamsSmoothing(LPCSTR N, int* V, int _min = 0, int _max = 999) : CCC_Integer(N, V, _min, _max) {};
+
+	virtual void Execute(LPCSTR args)
+	{
+		CCC_Integer::Execute(args);
+		soundSmoothingParams::alpha = soundSmoothingParams::getAlpha();
+	}
+};
+
 ENGINE_API float psHUD_FOV_def = 0.45f;
 ENGINE_API float psHUD_FOV = psHUD_FOV_def;
 
@@ -965,6 +977,9 @@ void CCC_Register()
 	CMD3(CCC_Mask, "snd_efx", &psSoundFlags, ss_EAX);
 	CMD4(CCC_Integer, "snd_targets", &psSoundTargets, 32, 1024);
 	CMD4(CCC_Integer, "snd_cache_size", &psSoundCacheSizeMB, 8, 256);
+	// Doppler effect power
+	CMD4(CCC_Float, "snd_doppler_power", &soundSmoothingParams::power, 0.f, 5.f);
+	CMD4(CCC_SoundParamsSmoothing, "snd_doppler_smoothing", &soundSmoothingParams::steps, 1, 100);
 
 #ifdef DEBUG
     CMD3(CCC_Mask, "snd_stats", &g_stats_flags, st_sound);
diff --git a/src/xrGame/Actor.cpp b/src/xrGame/Actor.cpp
index 899a940..9bf276b 100644
--- a/src/xrGame/Actor.cpp
+++ b/src/xrGame/Actor.cpp
@@ -246,6 +246,8 @@ CActor::CActor() : CEntityAlive(), current_ik_cam_shift(0)
 	m_bSafemode = false;
 
 	m_bDelayDrawPickupItems = false;
+
+	m_FPCam = NULL;
 }
 
 
@@ -829,6 +831,7 @@ void CActor::HitSignal(float perc, Fvector& vLocalDir, CObject* who, s16 element
 }
 
 void start_tutorial(LPCSTR name);
+extern BOOL firstPersonDeath;
 
 void CActor::Die(CObject* who)
 {
@@ -920,11 +923,25 @@ void CActor::Die(CObject* who)
 
 	if (IsGameTypeSingle())
 	{
-#ifdef FP_DEATH
-        cam_Set(eacFirstEye);
-#else
-		cam_Set(eacFreeLook);
-#endif // FP_DEATH
+		// demonized: First Person Death
+		if (firstPersonDeath) {
+			cam_Set(eacFirstEye);
+			initFPCam();
+			Fvector pos = Device.vCameraPosition;
+			Fvector hpb;
+			hpb.set(
+				Device.vCameraDirection.getH(),
+				Device.vCameraDirection.getP(),
+				0
+			);
+			m_FPCam->m_Position.set(pos);
+			m_FPCam->m_HPB.set(hpb);
+			m_FPCam->m_Camera.setHPB(hpb.x, hpb.y, hpb.z).translate_over(pos);
+			m_FPCam->m_customSmoothing = 0;
+		}
+		else
+			cam_Set(eacFreeLook);
+
 		CurrentGameUI()->HideShownDialogs();
 
 		/* avo: attempt to set camera on timer */
@@ -1566,8 +1583,26 @@ void CActor::shedule_Update(u32 DT)
 		if (bHudView)
 		{
 			CInventoryItem* pInvItem = inventory().ActiveItem();
-			if (!pInvItem)
+			if (pInvItem)
+			{
+				CHudItem* pHudItem = smart_cast<CHudItem*>(pInvItem);
+				if (pHudItem)
+				{
+					if (pHudItem->IsHidden())
+					{
+						g_player_hud->detach_item(pHudItem);
+					}
+					else
+					{
+						g_player_hud->attach_item(pHudItem);
+					}
+				}
+			}
+			else
+			{
 				g_player_hud->detach_item_idx(0);
+				//Msg("---No active item in inventory(), item 0 detached.");
+			}
 		}
 		else
 		{
@@ -1933,7 +1968,8 @@ extern	BOOL	g_ShowAnimationInfo		;
 void CActor::OnHUDDraw(CCustomHUD*)
 {
 	R_ASSERT(IsFocused());
-	if (!((mstate_real & mcLookout) && !IsGameTypeSingle()))
+	//demonized: disable hud when FPCam is on
+	if (!((mstate_real & mcLookout) && !IsGameTypeSingle()) && !m_FPCam)
 		g_player_hud->render_hud();
 
 
@@ -2675,3 +2711,20 @@ void CActor::SwitchNightVision(bool vision_on, bool use_sounds, bool send_event)
 		//Msg("GE_TRADER_FLAGS event sent %d", m_trader_flags.get());
 	}
 }
+
+// demonized: First Person Death
+void CActor::initFPCam()
+{
+	if (!m_FPCam) {
+		m_FPCam = xr_new<CFPCamEffector>();
+		Cameras().AddCamEffector(m_FPCam);
+	}
+}
+
+void CActor::removeFPCam() 
+{
+	if (m_FPCam) {
+		Cameras().RemoveCamEffector(m_FPCam);
+		m_FPCam = NULL;
+	}
+}
diff --git a/src/xrGame/Actor.h b/src/xrGame/Actor.h
index 1440969..eee4444 100644
--- a/src/xrGame/Actor.h
+++ b/src/xrGame/Actor.h
@@ -61,6 +61,7 @@ class CActorStatisticMgr;
 class CLocationManager;
 
 class CNightVisionEffector;
+class CFPCamEffector;
 
 class CActor :
 	public CEntityAlive,
@@ -81,6 +82,14 @@ public:
 	CActor();
 	virtual ~CActor();
 
+// demonized: First Person Death
+public:
+	CFPCamEffector* m_FPCam;
+
+public:
+	void initFPCam();
+	void removeFPCam();
+
 public:
 	virtual BOOL AlwaysTheCrow() { return TRUE; }
 
@@ -458,6 +467,9 @@ public:
 	float m_fRun_StrafeFactor;
 	float m_fSprint_StrafeFactor;
 
+	// demonized: lookout modifier
+	float m_fLookoutFactor = 1;
+
 public:
 	Fvector GetMovementSpeed() { return NET_SavedAccel; };
 	//////////////////////////////////////////////////////////////////////////
diff --git a/src/xrGame/ActorCameras.cpp b/src/xrGame/ActorCameras.cpp
index 19a5c6c..0b324e9 100644
--- a/src/xrGame/ActorCameras.cpp
+++ b/src/xrGame/ActorCameras.cpp
@@ -28,6 +28,9 @@
 #include "player_hud.h"
 #include "Missile.h"
 
+#include "EffectorBobbing.h"
+class CFPCamEffector;
+
 ENGINE_API extern float psHUD_FOV;
 ENGINE_API extern float psHUD_FOV_def;
 
@@ -453,6 +456,14 @@ static const float ik_cam_shift_tolerance = 0.2f;
 static const float ik_cam_shift_speed = 0.01f;
 #endif
 
+BOOL firstPersonDeath = TRUE;
+float offsetH = 0;
+float offsetP = 0;
+float offsetB = 0;
+float offsetX = 0;
+float offsetY = 0;
+float offsetZ = 0;
+float viewportNearOffset = 0;
 void CActor::cam_Update(float dt, float fFOV)
 {
 	if (m_holder) return;
@@ -576,6 +587,53 @@ void CActor::cam_Update(float dt, float fFOV)
 	{
 		collide_camera(*cameras[eacFirstEye], _viewport_near, this);
 	}
+	
+	if (cam_active == eacFirstEye) {
+		if (firstPersonDeath && !g_Alive() && m_FPCam) {
+			IKinematics* k = Visual()->dcast_PKinematics();
+
+			// Get eye bone position
+			CBoneInstance& eyeBone = k->LL_GetBoneInstance(m_eye_right);
+			Fmatrix matrix = Fidentity;
+			matrix.mul_43(XFORM(), eyeBone.mTransform);
+			Fvector camPos = (matrix.c);
+
+			// Get head bone direction, works better for first person death
+			CBoneInstance& headBone = k->LL_GetBoneInstance(m_head);
+			Fmatrix matrixDir = Fidentity;
+			Fvector camDir;
+			matrixDir.mul_43(XFORM(), headBone.mTransform);
+			matrixDir.getHPB(camDir);
+
+			// Adjust camera direction
+			Fvector adjustedCamDir;
+			adjustedCamDir.set(camDir).setHP(
+				camDir.x + deg2rad(8.f) + deg2rad(offsetH),
+				camDir.y - deg2rad(20.f) + deg2rad(offsetP)
+			);
+			camDir.set(
+				adjustedCamDir.getH(),
+				adjustedCamDir.getP(),
+				camDir.z + deg2rad(90.f) + deg2rad(offsetB)
+			);
+			if (camDir.x < 0) {
+				camDir.x = PI_MUL_2 + camDir.x;
+			}
+
+			Fvector dir, dirUp, dirRight;
+			dir.setHP(camDir.x, camDir.y);
+			Fvector::generate_orthonormal_basis_normalized(dir, dirUp, dirRight);
+
+			camPos.mad(dir, -0.04 + offsetZ);
+			camPos.mad(dirUp, offsetY);
+			camPos.mad(dirRight, -0.01 + offsetX);
+
+			m_FPCam->m_HPB.set(camDir);
+			m_FPCam->m_Position.set(camPos);
+			_viewport_near = VIEWPORT_NEAR - 0.08 + viewportNearOffset;
+			//Cameras().ApplyDevice(_viewport_near);
+		}
+	}
 
 	//Alundaio -psp always
 	//if( psActorFlags.test(AF_PSP) )
diff --git a/src/xrGame/ActorInput.cpp b/src/xrGame/ActorInput.cpp
index 8499334..2e2983b 100644
--- a/src/xrGame/ActorInput.cpp
+++ b/src/xrGame/ActorInput.cpp
@@ -592,11 +592,11 @@ void CActor::ActorUse()
 		}
 	}
 }
-
+extern BOOL firstPersonDeath;
 BOOL CActor::HUDview() const
 {
 	return IsFocused() && (cam_active == eacFirstEye) &&
-		((!m_holder) || (m_holder && m_holder->allowWeapon() && m_holder->HUDView()));
+		((!m_holder) || (m_holder && m_holder->allowWeapon() && m_holder->HUDView())) && (firstPersonDeath ? g_Alive() : true);
 }
 
 static u16 SlotsToCheck [] = {
diff --git a/src/xrGame/Actor_Movement.cpp b/src/xrGame/Actor_Movement.cpp
index b95ff6c..b49421b 100644
--- a/src/xrGame/Actor_Movement.cpp
+++ b/src/xrGame/Actor_Movement.cpp
@@ -426,6 +426,9 @@ void CActor::g_Orientate(u32 mstate_rl, float dt)
 	{
 		tgt_roll = (mstate_rl & mcLLookout) ? -ACTOR_LLOOKOUT_ANGLE : ACTOR_RLOOKOUT_ANGLE;
 
+		// demonized: add lookout modifier
+		tgt_roll *= m_fLookoutFactor;
+
 		if ((mstate_rl & mcLLookout) && (mstate_rl & mcRLookout))
 			tgt_roll = 0.0f;
 	}
diff --git a/src/xrGame/Actor_Weapon.cpp b/src/xrGame/Actor_Weapon.cpp
index 14eefbd..931a042 100644
--- a/src/xrGame/Actor_Weapon.cpp
+++ b/src/xrGame/Actor_Weapon.cpp
@@ -287,6 +287,9 @@ void CActor::on_weapon_shot_start(CWeapon* weapon)
 		{
 			effector->Initialize(camera_recoil);
 		}
+		else {
+			effector->UpdateCameraRecoil(camera_recoil);
+		}
 	}
 
 	effector->m_WeaponID = weapon->ID();
diff --git a/src/xrGame/Artefact.h b/src/xrGame/Artefact.h
index 35f5e1c..2298a74 100644
--- a/src/xrGame/Artefact.h
+++ b/src/xrGame/Artefact.h
@@ -70,7 +70,6 @@ protected:
 	float m_fTrailLightRange;
 	u8 m_af_rank;
 	bool m_bLightsEnabled;
-	float m_additional_weight;
 
 	virtual void UpdateLights();
 public:
@@ -91,6 +90,8 @@ public:
 	{
 	};
 
+	float m_additional_weight;
+
 	float AdditionalInventoryWeight() const { return m_additional_weight; }
 	bool m_bCanSpawnZone;
 	float m_fHealthRestoreSpeed;
diff --git a/src/xrGame/CustomOutfit.cpp b/src/xrGame/CustomOutfit.cpp
index 350d6f1..df7f414 100644
--- a/src/xrGame/CustomOutfit.cpp
+++ b/src/xrGame/CustomOutfit.cpp
@@ -110,7 +110,8 @@ void CCustomOutfit::Load(LPCSTR section)
 
 	m_full_icon_name = pSettings->r_string(section, "full_icon_name");
 	m_artefact_count = READ_IF_EXISTS(pSettings, r_u32, section, "artefact_count", 0);
-	clamp(m_artefact_count, (u32)0, (u32)5);
+	//clamp(m_artefact_count, (u32)0, (u32)5);
+	m_artefact_count = _max(m_artefact_count, (u32)0);
 
 	m_BonesProtectionSect = READ_IF_EXISTS(pSettings, r_string, section, "bones_koeff_protection", "");
 	bIsHelmetAvaliable = !!READ_IF_EXISTS(pSettings, r_bool, section, "helmet_avaliable", true);
@@ -363,7 +364,8 @@ bool CCustomOutfit::install_upgrade_impl(LPCSTR section, bool test)
 	clamp(m_fPowerLoss, 0.0f, 1.0f);
 
 	result |= process_if_exists(section, "artefact_count", &CInifile::r_u32, m_artefact_count, test);
-	clamp(m_artefact_count, (u32)0, (u32)5);
+	//clamp(m_artefact_count, (u32)0, (u32)5);
+	m_artefact_count = _max(m_artefact_count, (u32)0);
 
 	return result;
 }
diff --git a/src/xrGame/EffectorBobbing.cpp b/src/xrGame/EffectorBobbing.cpp
index ffd7c19..4ac05a2 100644
--- a/src/xrGame/EffectorBobbing.cpp
+++ b/src/xrGame/EffectorBobbing.cpp
@@ -113,3 +113,56 @@ BOOL CEffectorBobbing::ProcessCam(SCamEffectorInfo& info)
 	//	}
 	return TRUE;
 }
+
+// demonized: First Person Death (Cam Effector, can be used in scripts any time to set custom position and direction)
+CFPCamEffector::CFPCamEffector() : CEffectorCam(eCEUser, INT_MAX) {
+	m_Camera.identity();
+	m_Camera.setHPB(0, 0, 0);
+	m_HPB.set(0, 0, 0);
+	m_Position.set(0, 0, 0);
+	m_customSmoothing = 0;
+}
+
+// EMA smoothing for changing values, frame independent
+int firstPersonDeathPositionSmoothing = 6;
+int firstPersonDeathDirectionSmoothing = 12;
+
+void CFPCamEffector::ema(Fvector &current, Fvector &target, unsigned int steps) {
+	float smoothing_alpha = 2.0 / (steps + 1);
+	float delta = Device.dwTimeDelta;
+
+	if (fis_zero(current.x) && fis_zero(current.y) && fis_zero(current.z)) {
+		current.x = target.x;
+		current.y = target.y;
+		current.z = target.z;
+		return;
+	}
+
+	current.x = current.x + min(1.f, smoothing_alpha * (delta / steps)) * (target.x - current.x);
+	current.y = current.y + min(1.f, smoothing_alpha * (delta / steps)) * (target.y - current.y);
+	current.z = current.z + min(1.f, smoothing_alpha * (delta / steps)) * (target.z - current.z);
+}
+
+BOOL CFPCamEffector::ProcessCam(SCamEffectorInfo& info)
+{
+	// Set target camera
+	Fmatrix temp;
+	temp.identity().setHPB(m_HPB.x, m_HPB.y, m_HPB.z).translate_over(m_Position);
+
+	// Smooth out transition between current camera and target
+	if (m_customSmoothing) {
+		ema(m_Camera.j, temp.j, m_customSmoothing);
+		ema(m_Camera.k, temp.k, m_customSmoothing);
+		ema(m_Camera.c, temp.c, m_customSmoothing);
+	} else {
+		ema(m_Camera.j, temp.j, firstPersonDeathDirectionSmoothing);
+		ema(m_Camera.k, temp.k, firstPersonDeathDirectionSmoothing);
+		ema(m_Camera.c, temp.c, firstPersonDeathPositionSmoothing);
+	}
+
+	// update camera
+	info.n.set(m_Camera.j);
+	info.d.set(m_Camera.k);
+	info.p.set(m_Camera.c);
+	return TRUE;
+}
\ No newline at end of file
diff --git a/src/xrGame/EffectorBobbing.h b/src/xrGame/EffectorBobbing.h
index 854b7a7..e202596 100644
--- a/src/xrGame/EffectorBobbing.h
+++ b/src/xrGame/EffectorBobbing.h
@@ -33,3 +33,19 @@ public:
 };
 
 #endif //_EFFECTOR_BOBBING_H
+
+// demonized: First Person Death Cam Effector
+class CFPCamEffector : public CEffectorCam
+{
+public:
+	Fvector m_Position;
+	Fvector m_HPB;
+	Fmatrix m_Camera;
+	unsigned int m_customSmoothing; // 0 - use FPDeath smoothing params, no custom smoothing
+	virtual void ema(Fvector& current, Fvector& target, unsigned int steps);
+	
+public:
+	CFPCamEffector();
+	virtual BOOL ProcessCam(SCamEffectorInfo& info);
+
+};
diff --git a/src/xrGame/EffectorShot.cpp b/src/xrGame/EffectorShot.cpp
index 8ac8fa4..a7ae406 100644
--- a/src/xrGame/EffectorShot.cpp
+++ b/src/xrGame/EffectorShot.cpp
@@ -21,6 +21,11 @@ void CWeaponShotEffector::Initialize(const CameraRecoil& cam_recoil)
 	Reset();
 }
 
+void CWeaponShotEffector::UpdateCameraRecoil(const CameraRecoil& cam_recoil)
+{
+	m_cam_recoil.Clone(cam_recoil);
+}
+
 void CWeaponShotEffector::Reset()
 {
 	m_angle_vert = 0.0f;
diff --git a/src/xrGame/EffectorShot.h b/src/xrGame/EffectorShot.h
index 451d458..500db02 100644
--- a/src/xrGame/EffectorShot.h
+++ b/src/xrGame/EffectorShot.h
@@ -45,6 +45,7 @@ public:
 	};
 
 	void Initialize(const CameraRecoil& cam_recoil);
+	void UpdateCameraRecoil(const CameraRecoil& cam_recoil);
 	void Reset();
 
 	IC bool IsActive() { return m_actived; }
diff --git a/src/xrGame/GameObject.cpp b/src/xrGame/GameObject.cpp
index 1516f8d..1ce2261 100644
--- a/src/xrGame/GameObject.cpp
+++ b/src/xrGame/GameObject.cpp
@@ -116,6 +116,13 @@ void CGameObject::net_Destroy()
 #endif
 
 	VERIFY(m_spawned);
+
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.CGameObject_NetDestroy", funct))
+	{
+		funct(this->lua_game_object());
+	}
+
 	if (m_anim_mov_ctrl)
 		destroy_anim_mov_ctrl();
 
@@ -441,6 +448,11 @@ BOOL CGameObject::net_Spawn(CSE_Abstract* DC)
 	}
 	BOOL ret =CScriptBinder::net_Spawn(DC);
 #else
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.CGameObject_NetSpawn", funct))
+	{
+		funct(this->lua_game_object());
+	}
 	return (CScriptBinder::net_Spawn(DC));
 #endif
 
diff --git a/src/xrGame/GamePersistent.cpp b/src/xrGame/GamePersistent.cpp
index 7087c3a..a45da94 100644
--- a/src/xrGame/GamePersistent.cpp
+++ b/src/xrGame/GamePersistent.cpp
@@ -529,6 +529,14 @@ void CGamePersistent::game_loaded()
 			m_intro->Start("game_loaded");
 			Msg("intro_start game_loaded");
 			m_intro->m_on_destroy_event.bind(this, &CGamePersistent::update_game_loaded);
+
+			// demonized
+			// Callback for when loading screen happens and "Press Any Key to Continue" prompt appears
+			luabind::functor<void> funct;
+			if (ai().script_engine().functor("_G.OnLoadingScreenKeyPrompt", funct))
+			{
+				funct();
+			}
 		}
 		m_intro_event = 0;
 	}
@@ -539,6 +547,14 @@ void CGamePersistent::update_game_loaded()
 	xr_delete(m_intro);
 	Msg("intro_delete ::update_game_loaded");
 	start_game_intro();
+
+	// demonized
+	// Callback for when player dismisses loading screen after "Press Any Key to Continue" pressed
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.OnLoadingScreenDismissed", funct))
+	{
+		funct();
+	}
 }
 
 void CGamePersistent::start_game_intro()
diff --git a/src/xrGame/Level.cpp b/src/xrGame/Level.cpp
index 2f93a35..b1e4c6a 100644
--- a/src/xrGame/Level.cpp
+++ b/src/xrGame/Level.cpp
@@ -96,6 +96,74 @@ u16	GetSpawnInfo(NET_Packet &P, u16 &parent_id)
 #endif
 //-AVO
 
+namespace crash_saving {
+	extern void(*save_impl)();
+	static bool g_isSaving = false;
+	int saveCountMax = 10;
+
+	void _save_impl()
+	{
+		if (g_isSaving) return;
+		if (saveCountMax <= 0) return;
+
+		int saveCount = -1;
+		g_isSaving = true;
+		NET_Packet net_packet;
+		net_packet.w_begin(M_SAVE_GAME);
+
+		std::string path = "fatal_ctd_save_";
+		std::string path_mask(path);
+		std::string path_ext = ".scop";
+		path_mask.append("*").append(path_ext);
+
+		FS_FileSet fset_temp;
+		FS.file_list(fset_temp, "$game_saves$", FS_ListFiles | FS_RootOnly, path_mask.c_str());
+
+		std::vector<FS_File> fset(fset_temp.begin(), fset_temp.end());
+		struct {
+			bool operator()(FS_File& a, FS_File& b) {
+				return a.time_write > b.time_write;
+			}
+		} sortFilesDesc;
+		std::sort(fset.begin(), fset.end(), sortFilesDesc);
+
+		//Msg("save mask %s", path_mask.c_str());
+
+		for (auto &file : fset)
+		{
+			string128 name;
+			xr_strcpy(name, sizeof(name), file.name.c_str());
+			std::string name_string(name);
+			name_string.erase(name_string.length() - path_ext.length());
+
+			//Msg("found save file %s, save_name %s", name, name_string.c_str());
+
+			try {
+				//Msg("save number %s", name_string.substr(path.length()).c_str());
+				int name_count = std::stoi(name_string.substr(path.length()));
+				saveCount = name_count;
+				break;
+			} catch (...) {
+				Msg("!error getting save number from %s", name);
+			}
+		}
+
+		saveCount++;
+		if (saveCount >= saveCountMax) {
+			saveCount = 0;
+		}
+
+		path.append(std::to_string(saveCount));
+		net_packet.w_stringZ(path.c_str());
+		net_packet.w_u8(1);
+		CLevel& level = Level();
+		if (&level != nullptr)
+		{
+			level.Send(net_packet, net_flags(1));
+		}
+
+	}
+}
 
 CLevel::CLevel() :
 	IPureClient(Device.GetTimerGlobal())
@@ -141,12 +209,14 @@ CLevel::CLevel() :
 	g_player_hud = xr_new<player_hud>();
 	g_player_hud->load_default();
 	Msg("%s", Core.Params);
+	crash_saving::save_impl = crash_saving::_save_impl; // CLevel ready, we can save now
 }
 
 extern CAI_Space* g_ai_space;
 
 CLevel::~CLevel()
 {
+	crash_saving::save_impl = nullptr; // CLevel not available, disable crash save
 	xr_delete(g_player_hud);
 	delete_data(hud_zones_list);
 	hud_zones_list = nullptr;
diff --git a/src/xrGame/Level_Bullet_Manager.cpp b/src/xrGame/Level_Bullet_Manager.cpp
index c68bb69..1c59f4b 100644
--- a/src/xrGame/Level_Bullet_Manager.cpp
+++ b/src/xrGame/Level_Bullet_Manager.cpp
@@ -12,6 +12,7 @@
 #include "game_cl_base_weapon_usage_statistic.h"
 #include "game_cl_mp.h"
 #include "reward_event_generator.h"
+#include "material_manager.h"
 
 #include "../Include/xrRender/UIRender.h"
 #include "../Include/xrRender/Kinematics.h"
@@ -41,6 +42,7 @@ SBullet::~SBullet()
 {
 }
 
+u32 SBullet::bulletCount = 0;
 
 void SBullet::Init(const Fvector& position,
                    const Fvector& direction,
@@ -106,6 +108,9 @@ void SBullet::Init(const Fvector& position,
 
 	targetID = 0;
 	density_mode = 0;
+
+	catridgeSection = cartridge.m_ammoSect.c_str();
+	bulletId = bulletCount++;
 }
 
 
@@ -229,6 +234,24 @@ void CBulletManager::AddBullet(const Fvector& position,
 	            e_hit_type, maximum_distance, cartridge, air_resistance_factor, SendHit, iShotNum);
 	//	bullet.frame_num			= Device.dwFrame;
 	bullet.flags.aim_bullet = AimBullet;
+
+	// demonized - bullet on init callback
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.CBulletOnInit", funct)) {
+		funct(
+			position,
+			direction,
+			starting_speed,
+			0,
+			bullet.catridgeSection,
+			bullet.bulletId,
+			bullet.weapon_id,
+			bullet.parent_id,
+			65535,
+			NULL
+		);
+	}
+
 	if (!IsGameTypeSingle())
 	{
 		if (SendHit)
@@ -836,6 +859,13 @@ bool CBulletManager::trajectory_check_error(
 	bullet.start_velocity = Fvector().mul(bullet.dir, bullet.speed);
 	bullet.born_time += iFloor(data.collide_time * 1000.f);
 	bullet.life_time = 0.f;
+
+	// Add RQ range to the bullet fly dist
+	for (auto i = storage.r_begin(); i != storage.r_end();) {
+		bullet.fly_dist += i->range;
+		break;
+	}
+	
 	return (false);
 }
 
@@ -866,6 +896,32 @@ static bool try_update_bullet(SBullet& bullet, Fvector const& gravity, float con
 
 	bullet.bullet_pos = new_position;
 	bullet.dir = Fvector(new_velocity).normalize_safe();
+
+	/*luabind::functor<luabind::object> funct;
+	if (ai().script_engine().functor("_G.CBulletOnUpdate", funct)) {
+		luabind::object table = luabind::newtable(ai().script_engine().lua());
+
+		table["position"] = bullet.bullet_pos;
+		table["direction"] = bullet.dir;
+		table["speed"] = bullet.speed;
+		table["distance"] = bullet.fly_dist;
+		table["section"] = bullet.catridgeSection;
+		table["bullet_id"] = bullet.bulletId;
+		table["weapon_id"] = bullet.weapon_id;
+		table["parent_id"] = bullet.parent_id;
+
+		luabind::object output = funct(table);
+
+		if (output && output.type() == LUA_TTABLE) {
+			bullet.bullet_pos = luabind::object_cast<Fvector>(table["position"]);
+			bullet.dir = luabind::object_cast<Fvector>(table["direction"]);
+			bullet.speed = luabind::object_cast<float>(table["speed"]);
+			bullet.fly_dist = luabind::object_cast<float>(table["distance"]);
+			bullet.weapon_id = luabind::object_cast<u16>(table["weapon_id"]);
+			bullet.parent_id = luabind::object_cast<u16>(table["parent_id"]);
+		}
+	}*/
+
 	bullet.life_time = time;
 	return (true);
 }
@@ -1108,16 +1164,52 @@ void CBulletManager::CommitEvents() // @ the start of frame
 	for (u32 _it = 0; _it < m_Events.size(); _it++)
 	{
 		_event& E = m_Events[_it];
+		SBullet* bullet = &E.bullet;
+		Fvector& end_point = E.point;
+		SGameMtl* mt = GMLib.GetMaterialByIdx(E.tgt_material);
 		switch (E.Type)
 		{
 		case EVENT_HIT:
 			{
+				luabind::functor<void> funct;
+				if (ai().script_engine().functor("_G.CBulletOnImpact", funct)) {
+					funct(
+						!fis_zero(end_point.x) && !fis_zero(end_point.y) && !fis_zero(end_point.z) ? end_point : bullet->bullet_pos,
+						bullet->dir,
+						bullet->speed,
+						bullet->fly_dist + E.R.range,
+						bullet->catridgeSection,
+						bullet->bulletId,
+						bullet->weapon_id,
+						bullet->parent_id,
+						E.dynamic && E.R.O ? E.R.O->ID() : 65535,
+						mt ? mt->m_Name.c_str() : NULL
+					);
+				}
+
 				if (E.dynamic) DynamicObjectHit(E);
 				else StaticObjectHit(E);
 			}
+
 			break;
 		case EVENT_REMOVE:
 			{
+				luabind::functor<void> funct;
+				if (ai().script_engine().functor("_G.CBulletOnRemove", funct)) {
+					funct(
+						!fis_zero(end_point.x) && !fis_zero(end_point.y) && !fis_zero(end_point.z) ? end_point : bullet->bullet_pos,
+						bullet->dir,
+						bullet->speed,
+						bullet->fly_dist,
+						bullet->catridgeSection,
+						bullet->bulletId,
+						bullet->weapon_id,
+						bullet->parent_id,
+						65535,
+						NULL
+					);
+				}
+
 				if (E.bullet.flags.allow_sendhit && GameID() != eGameIDSingle)
 					Game().m_WeaponUsageStatistic->OnBullet_Remove(&E.bullet);
 				m_Bullets[E.tgt_material] = m_Bullets.back();
diff --git a/src/xrGame/Level_Bullet_Manager.h b/src/xrGame/Level_Bullet_Manager.h
index 80938ef..5fb4aab 100644
--- a/src/xrGame/Level_Bullet_Manager.h
+++ b/src/xrGame/Level_Bullet_Manager.h
@@ -45,6 +45,9 @@ struct SBullet
 
 	u16 parent_id; //ID    
 	u16 weapon_id; //ID      
+	LPCSTR catridgeSection;
+	static u32 bulletCount;
+	u32 bulletId;
 
 	float fly_dist; //   
 	Fvector tracer_start_position;
diff --git a/src/xrGame/Level_input.cpp b/src/xrGame/Level_input.cpp
index 3d06b55..a410863 100644
--- a/src/xrGame/Level_input.cpp
+++ b/src/xrGame/Level_input.cpp
@@ -56,7 +56,18 @@ void CLevel::IR_OnMouseWheel(int direction)
 
 	/* avo: script callback */
 #ifdef MOUSE_INPUT_CALLBACKS
-    if (g_actor) g_actor->callback(GameObject::eMouseWheel)(direction);
+    if (g_actor) {
+        // demonized: add mouse wheel callback with consuming input
+        luabind::functor<bool> funct;
+        if (ai().script_engine().functor("_G.COnMouseWheel", funct))
+        {
+            if (!funct(direction))
+            {
+                return;
+            }
+        }
+        //g_actor->callback(GameObject::eMouseWheel)(direction);
+    }
 #endif
 	/* avo: end */
 
diff --git a/src/xrGame/ScriptXMLInit.cpp b/src/xrGame/ScriptXMLInit.cpp
index 3c89e6d..6e490ca 100644
--- a/src/xrGame/ScriptXMLInit.cpp
+++ b/src/xrGame/ScriptXMLInit.cpp
@@ -37,6 +37,29 @@ void _attach_child(CUIWindow* _child, CUIWindow* _parent)
 		_parent->AttachChild(_child);
 }
 
+// demonized
+// Clear XML from BOM
+LPCSTR clearBOM(LPCSTR s) {
+	if (s[0] == (char)0xEF && s[1] == (char)0xBB && s[2] == (char)0xBF) {
+		LPCSTR new_s = s + 3;
+		return new_s;
+	}
+	return s;
+}
+
+// demonized
+// Send XML file contents to Lua for edit
+void XMLLuaCallback(CXml &m_xml, LPCSTR xml_string) {
+	xml_string = clearBOM(xml_string);
+	luabind::functor<LPCSTR> funct;
+	if (ai().script_engine().functor("_G.COnXmlRead", funct))
+	{
+		LPCSTR res = funct(m_xml.m_xml_file_name, xml_string);
+		//Msg("XMLLuaCallback, xml %s, contents %s", m_xml.m_xml_file_name, res);
+		m_xml.LoadFromString(res);
+	}
+}
+
 void CScriptXmlInit::ParseFile(LPCSTR xml_file)
 {
 	m_xml.Load(CONFIG_PATH, UI_PATH, xml_file);
diff --git a/src/xrGame/Weapon.cpp b/src/xrGame/Weapon.cpp
index 080f84d..a95c37f 100644
--- a/src/xrGame/Weapon.cpp
+++ b/src/xrGame/Weapon.cpp
@@ -641,6 +641,19 @@ void CWeapon::Load(LPCSTR section)
 	m_shoot_shake_mat.identity();
 }
 
+// demonized: World model on stalkers adjustments
+void CWeapon::set_mFirePoint(Fvector &fire_point) {
+	vLoadedFirePoint = fire_point;
+}
+
+void CWeapon::set_mFirePoint2(Fvector &fire_point) {
+	vLoadedFirePoint2 = fire_point;
+}
+
+void CWeapon::set_mShellPoint(Fvector &fire_point) {
+	vLoadedShellPoint = fire_point;
+}
+
 void CWeapon::LoadFireParams(LPCSTR section)
 {
 	cam_recoil.Dispersion = deg2rad(pSettings->r_float(section, "cam_dispersion"));
@@ -1775,6 +1788,21 @@ void CWeapon::reload(LPCSTR section)
 	m_ef_weapon_type = READ_IF_EXISTS(pSettings, r_u32, section, "ef_weapon_type", u32(-1));
 }
 
+// demonized: World model on stalkers adjustments
+void CWeapon::set_mOffset(Fvector position, Fvector orientation) {
+	orientation.mul(PI / 180.f);
+
+	m_Offset.setHPB(orientation.x, orientation.y, orientation.z);
+	m_Offset.translate_over(position);
+}
+
+void CWeapon::set_mStrapOffset(Fvector position, Fvector orientation) {
+	orientation.mul(PI / 180.f);
+
+	m_StrapOffset.setHPB(orientation.x, orientation.y, orientation.z);
+	m_StrapOffset.translate_over(position);
+}
+
 void CWeapon::create_physic_shell()
 {
 	CPhysicsShellHolder::create_physic_shell();
diff --git a/src/xrGame/Weapon.h b/src/xrGame/Weapon.h
index 9880065..4add752 100644
--- a/src/xrGame/Weapon.h
+++ b/src/xrGame/Weapon.h
@@ -103,6 +103,14 @@ public:
 
 	virtual void reinit();
 	virtual void reload(LPCSTR section);
+
+	// demonized: World model on stalkers adjustments
+	void set_mOffset(Fvector position, Fvector orientation);
+	void set_mStrapOffset(Fvector position, Fvector orientation);
+	void set_mFirePoint(Fvector &fire_point);
+	void set_mFirePoint2(Fvector &fire_point);
+	void set_mShellPoint(Fvector &fire_point);
+
 	virtual void create_physic_shell();
 	virtual void activate_physic_shell();
 	virtual void setup_physic_shell();
@@ -386,7 +394,16 @@ public:
 	LPCSTR GetScopeNameScript() const { return *GetScopeName(); }
 	float GetFireDispersionScript() const { return fireDispersionBase; }
 	float RPMScript() const { return fOneShotTime; }
+	float RealRPMScript() const { return 60.0f / fOneShotTime; } // Return actual RPM like in configs
 	float ModeRPMScript() const { return fModeShotTime; }
+	float ModeRealRPMScript() const { return 60.0f / fModeShotTime; }
+
+	//Setters
+	void SetFireDispersionScript(float val) { fireDispersionBase = val; }
+	void SetRPM(float newOneShotTime) { fOneShotTime = newOneShotTime; } // Input - time between shots like received from getter
+	void SetRealRPM(float rpm) { fOneShotTime = 60.0f / rpm; } // Input - actual RPM like in configs
+	void SetModeRPM(float newOneShotTime) { fModeShotTime = newOneShotTime; } // Input - time between shots like received from getter
+	void SetModeRealRPM(float rpm) { fModeShotTime = 60.0f / rpm; } // Input - actual RPM like in configs
 
 	virtual float Weight() const;
 	virtual u32 Cost() const;
@@ -563,6 +580,42 @@ public:
 	CameraRecoil cam_recoil; // simple mode (walk, run)
 	CameraRecoil zoom_cam_recoil; // using zoom =(ironsight or scope)
 
+	// Getters
+	float GetCamRelaxSpeed() { return cam_recoil.RelaxSpeed; };
+	float GetCamRelaxSpeed_AI() { return cam_recoil.RelaxSpeed_AI; };
+	float GetCamDispersion() { return cam_recoil.Dispersion; };
+	float GetCamDispersionInc() { return cam_recoil.DispersionInc; };
+	float GetCamDispersionFrac() { return cam_recoil.DispersionFrac; };
+	float GetCamMaxAngleVert() { return cam_recoil.MaxAngleVert; };
+	float GetCamMaxAngleHorz() { return cam_recoil.MaxAngleHorz; };
+	float GetCamStepAngleHorz() { return cam_recoil.StepAngleHorz; };
+	float GetZoomCamRelaxSpeed() { return zoom_cam_recoil.RelaxSpeed; };
+	float GetZoomCamRelaxSpeed_AI() { return zoom_cam_recoil.RelaxSpeed_AI; };
+	float GetZoomCamDispersion() { return zoom_cam_recoil.Dispersion; };
+	float GetZoomCamDispersionInc() { return zoom_cam_recoil.DispersionInc; };
+	float GetZoomCamDispersionFrac() { return zoom_cam_recoil.DispersionFrac; };
+	float GetZoomCamMaxAngleVert() { return zoom_cam_recoil.MaxAngleVert; };
+	float GetZoomCamMaxAngleHorz() { return zoom_cam_recoil.MaxAngleHorz; };
+	float GetZoomCamStepAngleHorz() { return zoom_cam_recoil.StepAngleHorz; };
+
+	// Setters
+	void SetCamRelaxSpeed(float val) { cam_recoil.RelaxSpeed = val; };
+	void SetCamRelaxSpeed_AI(float val) { cam_recoil.RelaxSpeed_AI = val; };
+	void SetCamDispersion(float val) { cam_recoil.Dispersion = val; };
+	void SetCamDispersionInc(float val) { cam_recoil.DispersionInc = val; };
+	void SetCamDispersionFrac(float val) { cam_recoil.DispersionFrac = val; };
+	void SetCamMaxAngleVert(float val) { cam_recoil.MaxAngleVert = val; };
+	void SetCamMaxAngleHorz(float val) { cam_recoil.MaxAngleHorz = val; };
+	void SetCamStepAngleHorz(float val) { cam_recoil.StepAngleHorz = val; };
+	void SetZoomCamRelaxSpeed(float val) { zoom_cam_recoil.RelaxSpeed = val; };
+	void SetZoomCamRelaxSpeed_AI(float val) { zoom_cam_recoil.RelaxSpeed_AI = val; };
+	void SetZoomCamDispersion(float val) { zoom_cam_recoil.Dispersion = val; };
+	void SetZoomCamDispersionInc(float val) { zoom_cam_recoil.DispersionInc = val; };
+	void SetZoomCamDispersionFrac(float val) { zoom_cam_recoil.DispersionFrac = val; };
+	void SetZoomCamMaxAngleVert(float val) { zoom_cam_recoil.MaxAngleVert = val; };
+	void SetZoomCamMaxAngleHorz(float val) { zoom_cam_recoil.MaxAngleHorz = val; };
+	void SetZoomCamStepAngleHorz(float val) { zoom_cam_recoil.StepAngleHorz = val; };
+
 protected:
 	//     
 	//(    )
@@ -590,6 +643,17 @@ public:
 		return misfireEndCondition;
 	};
 
+	// Setters
+	void SetMisfireStartCondition(float val)
+	{
+		misfireStartCondition = val;
+	};
+
+	void SetMisfireEndCondition(float val)
+	{
+		misfireEndCondition = val;
+	};
+
 protected:
 	struct SPDM
 	{
@@ -750,6 +814,107 @@ public:
 	{
 		return m_first_bullet_controller.get_fire_dispertion();
 	};
+
+	// Setters
+	virtual void Set_PDM_Base(float val) 
+	{
+		m_pdm.m_fPDM_disp_base = val;
+	};
+
+	virtual void Set_Silencer_PDM_Base(float val) 
+	{
+		cur_silencer_koef.pdm_base = val;
+	};
+
+	virtual void Set_Scope_PDM_Base(float val) 
+	{
+		cur_scope_koef.pdm_base = val;
+	};
+
+	virtual void Set_Launcher_PDM_Base(float val) 
+	{
+		cur_launcher_koef.pdm_base = val;
+	};
+
+	virtual void Set_PDM_BuckShot(float val) 
+	{
+		m_pdm.m_fPDM_disp_buckShot = val;
+	};
+
+	virtual void Set_PDM_Vel_F(float val) 
+	{
+		m_pdm.m_fPDM_disp_vel_factor = val;
+	};
+
+	virtual void Set_Silencer_PDM_Vel(float val) 
+	{
+		cur_silencer_koef.pdm_vel = val;
+	};
+
+	virtual void Set_Scope_PDM_Vel(float val) 
+	{
+		cur_scope_koef.pdm_vel = val;
+	};
+
+	virtual void Set_Launcher_PDM_Vel(float val) 
+	{
+		cur_launcher_koef.pdm_vel = val;
+	};
+
+	virtual void Set_PDM_Accel_F(float val) 
+	{
+		m_pdm.m_fPDM_disp_accel_factor = val;
+	};
+
+	virtual void Set_Silencer_PDM_Accel(float val) 
+	{
+		cur_silencer_koef.pdm_accel = val;
+	};
+
+	virtual void Set_Scope_PDM_Accel(float val) 
+	{
+		cur_scope_koef.pdm_accel = val;
+	};
+
+	virtual void Set_Launcher_PDM_Accel(float val) 
+	{
+		cur_launcher_koef.pdm_accel = val;
+	};
+
+	virtual void Set_PDM_Crouch(float val) 
+	{
+		m_pdm.m_fPDM_disp_crouch = val;
+	};
+
+	virtual void Set_PDM_Crouch_NA(float val) 
+	{
+		m_pdm.m_fPDM_disp_crouch_no_acc = val;
+	};
+
+	virtual void SetCrosshairInertion(float val) 
+	{
+		m_crosshair_inertion = val;
+	};
+
+	virtual void Set_Silencer_CrosshairInertion(float val) 
+	{
+		cur_silencer_koef.crosshair_inertion = val;
+	};
+
+	virtual void Set_Scope_CrosshairInertion(float val) 
+	{
+		cur_scope_koef.crosshair_inertion = val;
+	};
+
+	virtual void Set_Launcher_CrosshairInertion(float val)
+	{
+		cur_launcher_koef.crosshair_inertion = val;
+	};
+
+	void SetFirstBulletDisp(float val)
+	{
+		m_first_bullet_controller.set_fire_dispertion(val);
+	};
 protected:
 	int iAmmoElapsed; // ammo in magazine, currently
 	int iMagazineSize; // size (in bullets) of magazine
@@ -795,6 +960,20 @@ public:
 	virtual float GetHitPowerCritical() { return fvHitPowerCritical[g_SingleGameDifficulty]; };
 	virtual float GetHitImpulse() { return fHitImpulse; };
 	virtual float GetFireDistance() { return fireDistance; };
+
+	// Setters
+	virtual void SetHitPower(float val) {
+		for (int i = ESingleGameDifficulty::egdNovice; i < ESingleGameDifficulty::egdCount; i++) {
+			fvHitPower[i] = val;
+		}
+	};
+	virtual void SetHitPowerCritical(float val) {
+		for (int i = ESingleGameDifficulty::egdNovice; i < ESingleGameDifficulty::egdCount; i++) {
+			fvHitPowerCritical[i] = val;
+		}
+	};
+	virtual void SetHitImpulse(float val) { fHitImpulse = val; };
+	virtual void SetFireDistance(float val) { fireDistance = val; };
 	
 	IC u8 GetZoomType() const
 	{
diff --git a/src/xrGame/WeaponAK74.cpp b/src/xrGame/WeaponAK74.cpp
index 6f55903..45f79bc 100644
--- a/src/xrGame/WeaponAK74.cpp
+++ b/src/xrGame/WeaponAK74.cpp
@@ -62,7 +62,9 @@ void CWeaponAK74::script_register	(lua_State *L)
 			.def("GetAmmoType", &CWeapon::GetAmmoType)
 			.def("AmmoTypeForEach", &CWeapon::AmmoTypeForEach)
 			.def("RPM", &CWeapon::RPMScript)
+			.def("RealRPM", &CWeapon::RealRPMScript)
 			.def("ModeRPM", &CWeapon::ModeRPMScript)
+			.def("ModeRealRPM", &CWeapon::ModeRealRPMScript)
 			.def("GetZoomType", &CWeapon::GetZoomType)
 			
 			.def("Get_PDM_Base", &CWeapon::Get_PDM_Base)
@@ -93,6 +95,83 @@ void CWeaponAK74::script_register	(lua_State *L)
 			.def("GetFireMode", &CWeapon::GetCurrentFireMode)
 
 			.def("GetInertionAimFactor", &CWeapon::GetInertionAimFactor)
+
+			// Setters
+			.def("SetFireDispersion", &CWeapon::SetFireDispersionScript)
+			.def("SetMisfireStartCondition", &CWeapon::SetMisfireStartCondition)
+			.def("SetMisfireEndCondition", &CWeapon::SetMisfireEndCondition)
+			.def("SetRPM", &CWeapon::SetRPM)
+			.def("SetRealRPM", &CWeapon::SetRealRPM)
+			.def("SetModeRPM", &CWeapon::SetModeRPM)
+			.def("SetModeRealRPM", &CWeapon::SetModeRealRPM)
+			.def("Set_PDM_Base", &CWeapon::Set_PDM_Base)
+			.def("Set_Silencer_PDM_Base", &CWeapon::Set_Silencer_PDM_Base)
+			.def("Set_Scope_PDM_Base", &CWeapon::Set_Scope_PDM_Base)
+			.def("Set_Launcher_PDM_Base", &CWeapon::Set_Launcher_PDM_Base)
+			.def("Set_PDM_BuckShot", &CWeapon::Set_PDM_BuckShot)
+			.def("Set_PDM_Vel_F", &CWeapon::Set_PDM_Vel_F)
+			.def("Set_Silencer_PDM_Vel", &CWeapon::Set_Silencer_PDM_Vel)
+			.def("Set_Scope_PDM_Vel", &CWeapon::Set_Scope_PDM_Vel)
+			.def("Set_Launcher_PDM_Vel", &CWeapon::Set_Launcher_PDM_Vel)
+			.def("Set_PDM_Accel_F", &CWeapon::Set_PDM_Accel_F)
+			.def("Set_Silencer_PDM_Accel", &CWeapon::Set_Silencer_PDM_Accel)
+			.def("Set_Scope_PDM_Accel", &CWeapon::Set_Scope_PDM_Accel)
+			.def("Set_Launcher_PDM_Accel", &CWeapon::Set_Launcher_PDM_Accel)
+			.def("Set_PDM_Crouch", &CWeapon::Set_PDM_Crouch)
+			.def("Set_PDM_Crouch_NA", &CWeapon::Set_PDM_Crouch_NA)
+			.def("SetCrosshairInertion", &CWeapon::SetCrosshairInertion)
+			.def("Set_Silencer_CrosshairInertion", &CWeapon::Set_Silencer_CrosshairInertion)
+			.def("Set_Scope_CrosshairInertion", &CWeapon::Set_Scope_CrosshairInertion)
+			.def("Set_Launcher_CrosshairInertion", &CWeapon::Set_Launcher_CrosshairInertion)
+			.def("SetFirstBulletDisp", &CWeapon::SetFirstBulletDisp)
+			.def("SetHitPower", &CWeapon::SetHitPower)
+			.def("SetHitPowerCritical", &CWeapon::SetHitPowerCritical)
+			.def("SetHitImpulse", &CWeapon::SetHitImpulse)
+			.def("SetFireDistance", &CWeapon::SetFireDistance)
+
+			// demonized: World model on stalkers adjustments
+			.def("Set_mOffset", &CWeapon::set_mOffset)
+			.def("Set_mStrapOffset", &CWeapon::set_mStrapOffset)
+			.def("Set_mFirePoint", &CWeapon::set_mFirePoint)
+			.def("Set_mFirePoint2", &CWeapon::set_mFirePoint2)
+			.def("Set_mShellPoint", &CWeapon::set_mShellPoint)
+
+			// Cam Recoil
+			// Getters
+			.def("GetCamRelaxSpeed", &CWeapon::GetCamRelaxSpeed)
+			.def("GetCamRelaxSpeed_AI", &CWeapon::GetCamRelaxSpeed_AI)
+			.def("GetCamDispersion", &CWeapon::GetCamDispersion)
+			.def("GetCamDispersionInc", &CWeapon::GetCamDispersionInc)
+			.def("GetCamDispersionFrac", &CWeapon::GetCamDispersionFrac)
+			.def("GetCamMaxAngleVert", &CWeapon::GetCamMaxAngleVert)
+			.def("GetCamMaxAngleHorz", &CWeapon::GetCamMaxAngleHorz)
+			.def("GetCamStepAngleHorz", &CWeapon::GetCamStepAngleHorz)
+			.def("GetZoomCamRelaxSpeed", &CWeapon::GetZoomCamRelaxSpeed)
+			.def("GetZoomCamRelaxSpeed_AI", &CWeapon::GetZoomCamRelaxSpeed_AI)
+			.def("GetZoomCamDispersion", &CWeapon::GetZoomCamDispersion)
+			.def("GetZoomCamDispersionInc", &CWeapon::GetZoomCamDispersionInc)
+			.def("GetZoomCamDispersionFrac", &CWeapon::GetZoomCamDispersionFrac)
+			.def("GetZoomCamMaxAngleVert", &CWeapon::GetZoomCamMaxAngleVert)
+			.def("GetZoomCamMaxAngleHorz", &CWeapon::GetZoomCamMaxAngleHorz)
+			.def("GetZoomCamStepAngleHorz", &CWeapon::GetZoomCamStepAngleHorz)
+
+			// Setters
+			.def("SetCamRelaxSpeed", &CWeapon::SetCamRelaxSpeed)
+			.def("SetCamRelaxSpeed_AI", &CWeapon::SetCamRelaxSpeed_AI)
+			.def("SetCamDispersion", &CWeapon::SetCamDispersion)
+			.def("SetCamDispersionInc", &CWeapon::SetCamDispersionInc)
+			.def("SetCamDispersionFrac", &CWeapon::SetCamDispersionFrac)
+			.def("SetCamMaxAngleVert", &CWeapon::SetCamMaxAngleVert)
+			.def("SetCamMaxAngleHorz", &CWeapon::SetCamMaxAngleHorz)
+			.def("SetCamStepAngleHorz", &CWeapon::SetCamStepAngleHorz)
+			.def("SetZoomCamRelaxSpeed", &CWeapon::SetZoomCamRelaxSpeed)
+			.def("SetZoomCamRelaxSpeed_AI", &CWeapon::SetZoomCamRelaxSpeed_AI)
+			.def("SetZoomCamDispersion", &CWeapon::SetZoomCamDispersion)
+			.def("SetZoomCamDispersionInc", &CWeapon::SetZoomCamDispersionInc)
+			.def("SetZoomCamDispersionFrac", &CWeapon::SetZoomCamDispersionFrac)
+			.def("SetZoomCamMaxAngleVert", &CWeapon::SetZoomCamMaxAngleVert)
+			.def("SetZoomCamMaxAngleHorz", &CWeapon::SetZoomCamMaxAngleHorz)
+			.def("SetZoomCamStepAngleHorz", &CWeapon::SetZoomCamStepAngleHorz)
 			
 			.def("Cost", &CWeapon::Cost)
 			.def("Weight", &CWeapon::Weight)
diff --git a/src/xrGame/ai/monsters/control_animation_base_accel.cpp b/src/xrGame/ai/monsters/control_animation_base_accel.cpp
index 10bd71f..02d3e9f 100644
--- a/src/xrGame/ai/monsters/control_animation_base_accel.cpp
+++ b/src/xrGame/ai/monsters/control_animation_base_accel.cpp
@@ -136,6 +136,8 @@ bool CControlAnimationBase::accel_check_braking(float before_interval, float nom
 {
 	if (!m_man->path_builder().is_moving_on_path()) return (braking_mode = false);
 	if (!accel_active(eAV_Braking)) return (braking_mode = false);
+	if (m_man->path_builder().detail().path()[m_man->path_builder().detail().curr_travel_point_index()].velocity == MonsterMovement::eVelocityParameterStand)
+		return (braking_mode = false);
 
 	float acceleration = accel_get(eAV_Braking);
 	float braking_dist = (nominal_speed * ((braking_mode) ? nominal_speed : m_man->movement().velocity_current())) / (2
diff --git a/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp b/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp
index 908d83f..313f802 100644
--- a/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp
+++ b/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp
@@ -17,6 +17,13 @@
 #include "../control_path_builder_base.h"
 #include "inventory_item.h"
 
+#include "script_hit.h"
+#include "pch_script.h"
+#include "../../script_game_object.h"
+
+// demonized: Flag for damaging NPCs and other objects by the stomp attack
+BOOL pseudogiantCanDamageObjects = 1;
+
 
 CPseudoGigant::CPseudoGigant()
 {
@@ -262,6 +269,21 @@ void CPseudoGigant::on_activate_control(ControlCom::EControlType type)
 	{
 		m_sound_start_threaten.play_at_pos(this, get_head_position(this));
 		m_time_next_threaten = time() + Random.randI(m_threaten_delay_min, m_threaten_delay_max);
+
+		// callback for start animation, will be triggered by everyone in radius
+		m_nearest.clear_not_free();
+		Level().ObjectSpace.GetNearest(m_nearest, Position(), 15.f, NULL);
+		for (u32 i = 0; i < m_nearest.size(); i++)
+		{
+			CPhysicsShellHolder* obj = smart_cast<CPhysicsShellHolder*>(m_nearest[i]);
+			if (obj && obj->ID() != 0 && obj->ID() != ID()) {
+				luabind::functor<void> funct;
+				if (ai().script_engine().functor("_G.CPseudoGigant__OnStartStompAnimation", funct))
+				{
+					funct(obj->lua_game_object(), this->lua_game_object());
+				}
+			}
+		}
 	}
 }
 
@@ -274,6 +296,56 @@ void CPseudoGigant::on_threaten_execute()
 	{
 		CPhysicsShellHolder* obj = smart_cast<CPhysicsShellHolder *>(m_nearest[i]);
 		CInventoryItem* itm = smart_cast<CInventoryItem*>(m_nearest[i]);
+
+		if (pseudogiantCanDamageObjects && obj && obj->ID() != 0 && obj->ID() != ID()) {
+			float dist_to_enemy = obj->Position().distance_to(Position());
+			float hit_value;
+			hit_value = m_kick_damage - m_kick_damage * dist_to_enemy / m_threaten_dist_max;
+			clamp(hit_value, 0.f, 1.f);
+
+			SHit HS;
+
+			HS.GenHeader(GE_HIT, obj->ID()); 
+			HS.whoID = ID(); 
+			HS.who = this;
+			HS.weaponID = ID(); 
+			HS.dir = Fvector().set(0.f, 1.f, 0.f); 
+			HS.power = hit_value; 
+			HS.boneID = smart_cast<IKinematics*>(obj->Visual())->LL_GetBoneRoot();
+			HS.p_in_bone_space = Fvector().set(0.f, 0.f, 0.f);
+
+			HS.impulse = obj->cast_entity_alive() && obj->cast_entity_alive()->g_Alive() ? 80 * 80 : 0; // 0 impulse for not alive objects, they will receive the impulse later
+			//HS.impulse = 80 * obj->character_physics_support()->movement()->GetMass();
+
+			HS.hit_type = ALife::eHitTypeStrike;
+
+			bool doHit = true;
+			luabind::functor<bool> funct;
+			CScriptHit tLuaHit(&HS);
+			if (ai().script_engine().functor("_G.CPseudoGigant__BeforeHitCallback", funct))
+			{
+				doHit = funct(obj->lua_game_object(), this->lua_game_object(), &tLuaHit, HS.boneID);
+				if (doHit) {
+					HS.ApplyScriptHit(&tLuaHit);
+				}
+			}
+
+			if (doHit) {
+				//Msg("hit entity %d, name %s, damage %f", obj->ID(), obj->Name(), hit_value);
+				obj->Hit(&HS);
+
+				luabind::functor<void> hitFunct;
+				if (ai().script_engine().functor("_G.CPseudoGigant__HitCallback", hitFunct))
+				{
+					hitFunct(obj->lua_game_object(), this->lua_game_object(), &tLuaHit, HS.boneID);
+				}
+
+				//NET_Packet l_P;
+				//HS.Write_Packet(l_P);
+				//u_EventSend(l_P);
+			}						
+		}
+
 		if (!obj || !obj->m_pPhysicsShell || (itm && itm->IsQuestItem())) continue;
 
 		Fvector dir;
diff --git a/src/xrGame/ai/stalker/ai_stalker.h b/src/xrGame/ai/stalker/ai_stalker.h
index 0409ea5..8b4965f 100644
--- a/src/xrGame/ai/stalker/ai_stalker.h
+++ b/src/xrGame/ai/stalker/ai_stalker.h
@@ -157,6 +157,10 @@ public:
 public:
 	bool m_wounded;
 
+	// demonized: add enabling pathfinding and damage by anomalies flags
+	bool m_enable_anomalies_pathfinding = false;
+	bool m_enable_anomalies_damage = false;
+
 public:
 	CAI_Stalker();
 	virtual ~CAI_Stalker();
diff --git a/src/xrGame/ai/stalker/ai_stalker_events.cpp b/src/xrGame/ai/stalker/ai_stalker_events.cpp
index f38ad85..c578a68 100644
--- a/src/xrGame/ai/stalker/ai_stalker_events.cpp
+++ b/src/xrGame/ai/stalker/ai_stalker_events.cpp
@@ -15,6 +15,7 @@
 #include "../../level.h"
 #include "../../ai_monster_space.h"
 #include "../../characterphysicssupport.h"
+#include "space_restrictor.h"
 
 using namespace StalkerSpace;
 using namespace MonsterSpace;
@@ -139,6 +140,7 @@ void CAI_Stalker::UpdateAvailableDialogs(CPhraseDialogManager* partner)
 	CAI_PhraseDialogManager::UpdateAvailableDialogs(partner);
 }
 
+extern BOOL g_ai_die_in_anomaly;
 void CAI_Stalker::feel_touch_new(CObject* O)
 {
 	//	Msg					("FEEL_TOUCH::NEW : %s",*O->cName());
@@ -146,6 +148,14 @@ void CAI_Stalker::feel_touch_new(CObject* O)
 	if (Remote()) return;
 	if ((O->spatial.type | STYPE_VISIBLEFORAI) != O->spatial.type) return;
 
+	// demonized: add g_ai_die_in_anomaly == 0 check
+	if (!(g_ai_die_in_anomaly || m_enable_anomalies_pathfinding)) {
+		CSpaceRestrictor* sr = smart_cast<CSpaceRestrictor*>(O);
+		if (sr) {
+			return;
+		}
+	}
+
 	// Now, test for game specific logical objects to minimize traffic
 	CInventoryItem* I = smart_cast<CInventoryItem*>(O);
 
diff --git a/src/xrGame/ai/stalker/ai_stalker_feel.cpp b/src/xrGame/ai/stalker/ai_stalker_feel.cpp
index c0d54c9..1abc2f7 100644
--- a/src/xrGame/ai/stalker/ai_stalker_feel.cpp
+++ b/src/xrGame/ai/stalker/ai_stalker_feel.cpp
@@ -14,6 +14,7 @@
 #include "../../sight_manager.h"
 #include "../../stalker_movement_manager_smart_cover.h"
 #include "../../stalker_animation_manager.h"
+#include "space_restrictor.h"
 
 #ifdef DEBUG
 #	include "../../ai_debug.h"
@@ -56,6 +57,7 @@ bool CAI_Stalker::bfCheckForNodeVisibility(u32 dwNodeID, bool bIfRayPick)
 	return (memory().visual().visible(dwNodeID, movement().m_head.current.yaw, ffGetFov()));
 }
 
+extern BOOL g_ai_die_in_anomaly;
 bool CAI_Stalker::feel_touch_contact(CObject* O)
 {
 	if (!m_take_items_enabled && smart_cast<CInventoryItem*>(O))
@@ -71,6 +73,15 @@ bool CAI_Stalker::feel_touch_contact(CObject* O)
 	if (!game_object)
 		return (false);
 
+	// demonized: add g_ai_die_in_anomaly == 0 and m_enable_anomalies_pathfinding check
+	// when 0 - disable pathfinding around anomaly
+	if (!(g_ai_die_in_anomaly || m_enable_anomalies_pathfinding)) {
+		CSpaceRestrictor* sr = smart_cast<CSpaceRestrictor*>(O);
+		if (sr && (sr->spatial.type & STYPE_VISIBLEFORAI)) {
+			return false;
+		}
+	}
+
 	return (game_object->feel_touch_on_contact(this));
 }
 
@@ -81,6 +92,15 @@ bool CAI_Stalker::feel_touch_on_contact(CObject* O)
 	if ((O->spatial.type | STYPE_VISIBLEFORAI) != O->spatial.type)
 		return (false);
 
+	// demonized: add g_ai_die_in_anomaly == 0 and m_enable_anomalies_damage check
+	// when 0 - prevent any damage from anomalies
+	if (!(g_ai_die_in_anomaly || m_enable_anomalies_damage)) {
+		CSpaceRestrictor* sr = smart_cast<CSpaceRestrictor*>(O);
+		if (sr) {
+			return false;
+		}
+	}
+
 	return (inherited::feel_touch_on_contact(O));
 }
 
diff --git a/src/xrGame/alife_simulator_script.cpp b/src/xrGame/alife_simulator_script.cpp
index e5b96f1..34e7719 100644
--- a/src/xrGame/alife_simulator_script.cpp
+++ b/src/xrGame/alife_simulator_script.cpp
@@ -412,6 +412,15 @@ CSE_Abstract* reprocess_spawn(CALifeSimulator* self, CSE_Abstract* object)
 	return (self->server().Process_spawn(packet, clientID));
 }
 
+// demonized: iterate alife objects
+void CALifeSimulator__iterate_objects(const CALifeSimulator* self, luabind::functor<bool> functor)
+{
+	const CALifeObjectRegistry &objects = self->objects();
+	for (const auto& se_obj : objects.objects()) {
+		if (functor(se_obj.second)) break;
+	}
+}
+
 CSE_Abstract* try_to_clone_object(CALifeSimulator* self, CSE_Abstract* object, LPCSTR section, const Fvector& position,
                                   u32 level_vertex_id, GameGraph::_GRAPH_ID game_vertex_id, ALife::_OBJECT_ID id_parent,
                                   bool bRegister = true)
@@ -514,6 +523,9 @@ void CALifeSimulator::script_register(lua_State* L)
 		.def("get_children", &get_children, return_stl_iterator)
 		//Alundaio: END
 
+		// demonized: iterate alife objects
+		.def("iterate_objects", &CALifeSimulator__iterate_objects)
+
 		, def("alife", &alife)
 	];
 
diff --git a/src/xrGame/artefact_script.cpp b/src/xrGame/artefact_script.cpp
index 90f6dcf..c3f787c 100644
--- a/src/xrGame/artefact_script.cpp
+++ b/src/xrGame/artefact_script.cpp
@@ -33,6 +33,7 @@ void CArtefact::script_register(lua_State* L)
 		.def_readwrite("m_fSatietyRestoreSpeed", &CArtefact::m_fSatietyRestoreSpeed)
 		.def_readwrite("m_fPowerRestoreSpeed", &CArtefact::m_fPowerRestoreSpeed)
 		.def_readwrite("m_fBleedingRestoreSpeed", &CArtefact::m_fBleedingRestoreSpeed)
+		.def_readwrite("m_additional_weight", &CArtefact::m_additional_weight)
 		.def("FollowByPath", &CArtefact::FollowByPath)
 		.def("SwitchVisibility", &CArtefact::SwitchVisibility)
 		.def("GetAfRank", &CArtefact::GetAfRank),
diff --git a/src/xrGame/console_commands.cpp b/src/xrGame/console_commands.cpp
index 2841970..601f10e 100644
--- a/src/xrGame/console_commands.cpp
+++ b/src/xrGame/console_commands.cpp
@@ -1,3 +1,4 @@
+#include <unordered_set>
 #include "pch_script.h"
 #include "../xrEngine/xr_ioconsole.h"
 #include "../xrEngine/xr_ioc_cmd.h"
@@ -110,6 +111,15 @@ float streff;
 
 extern BOOL g_ai_die_in_anomaly; //Alundaio
 
+//demonized: new console vars
+extern BOOL firstPersonDeath;
+extern BOOL pseudogiantCanDamageObjects;
+extern BOOL use_english_text_for_missing_translations;
+namespace crash_saving {
+	extern BOOL enabled;
+	extern int saveCountMax;
+}
+
 ENGINE_API extern float g_console_sensitive;
 
 u32 g_dead_body_collision = 1;
@@ -458,6 +468,7 @@ public:
 };
 
 //-----------------------------------------------------------------------
+std::unordered_set<CDemoRecord*> pDemoRecords;
 class CCC_DemoRecord : public IConsole_Command
 {
 public:
@@ -482,7 +493,55 @@ public:
 		string_path fn;
 		FS.update_path(fn, "$game_saves$", fn_);
 
-		g_pGameLevel->Cameras().AddCamEffector(xr_new<CDemoRecord>(fn));
+		auto pDemoRecord = xr_new<CDemoRecord>(fn, &pDemoRecords);
+		g_pGameLevel->Cameras().AddCamEffector(pDemoRecord);
+	}
+};
+
+class CCC_DemoRecordBlockedInput : public IConsole_Command
+{
+public:
+
+	CCC_DemoRecordBlockedInput(LPCSTR N) : IConsole_Command(N)
+	{
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+#ifndef	DEBUG
+		//if (GameID() != eGameIDSingle)
+		//{
+		//	Msg("For this game type Demo Record is disabled.");
+		//	return;
+		//};
+#endif
+		Console->Hide();
+
+		LPSTR fn_;
+		STRCONCAT(fn_, args, ".xrdemo");
+		string_path fn;
+		FS.update_path(fn, "$game_saves$", fn_);
+
+		auto pDemoRecord = xr_new<CDemoRecord>(fn, &pDemoRecords, TRUE);
+		g_pGameLevel->Cameras().AddCamEffector(pDemoRecord);
+	}
+};
+
+class CCC_DemoRecordStop : public IConsole_Command
+{
+public:
+
+	CCC_DemoRecordStop(LPCSTR N) : IConsole_Command(N)
+	{
+		bEmptyArgsHandled = true;
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+		for (auto pDemoRecord : pDemoRecords) {
+			pDemoRecord->StopDemo();
+		}
+		pDemoRecords.clear();
 	}
 };
 
@@ -515,6 +574,35 @@ public:
 
 Fvector CCC_DemoRecordSetPos::p = {0, 0, 0};
 
+class CCC_DemoRecordSetDir : public CCC_Vector3
+{
+	static Fvector d;
+public:
+
+	CCC_DemoRecordSetDir(LPCSTR N) : CCC_Vector3(N, &d, Fvector().set(-FLT_MAX, -FLT_MAX, -FLT_MAX),
+		Fvector().set(FLT_MAX, FLT_MAX, FLT_MAX))
+	{
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+#ifndef	DEBUG
+		//if (GameID() != eGameIDSingle)
+		//{
+		//	Msg("For this game type Demo Record is disabled.");
+		//	return;
+		//};
+#endif
+		CDemoRecord::GetGlobalDirection(d);
+		CCC_Vector3::Execute(args);
+		CDemoRecord::SetGlobalDirection(d);
+	}
+
+	virtual void Save(IWriter* F) { ; }
+};
+
+Fvector CCC_DemoRecordSetDir::d = { 0, 0, 0 };
+
 class CCC_DemoPlay : public IConsole_Command
 {
 public:
@@ -555,6 +643,57 @@ public:
 	}
 };
 
+// First Person Death
+extern float offsetH;
+extern float offsetP;
+extern float offsetB;
+extern float offsetX;
+extern float offsetY;
+extern float offsetZ;
+extern float viewportNearOffset;
+extern int firstPersonDeathPositionSmoothing;
+extern int firstPersonDeathDirectionSmoothing;
+
+class CCC_FPDDirectionOffset : public CCC_Vector3
+{
+	static Fvector d;
+public:
+
+	CCC_FPDDirectionOffset(LPCSTR N) : CCC_Vector3(N, &d, Fvector().set(-FLT_MAX, -FLT_MAX, -FLT_MAX),
+		Fvector().set(FLT_MAX, FLT_MAX, FLT_MAX))
+	{
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+		CCC_Vector3::Execute(args);
+		offsetH = d.x;
+		offsetP = d.y;
+		offsetB = d.z;
+	}
+};
+Fvector CCC_FPDDirectionOffset::d = { 0, 0, 0 };
+
+class CCC_FPDPositionOffset : public CCC_Vector3
+{
+	static Fvector d;
+public:
+
+	CCC_FPDPositionOffset(LPCSTR N) : CCC_Vector3(N, &d, Fvector().set(-FLT_MAX, -FLT_MAX, -FLT_MAX),
+		Fvector().set(FLT_MAX, FLT_MAX, FLT_MAX))
+	{
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+		CCC_Vector3::Execute(args);
+		offsetX = d.x;
+		offsetY = d.y;
+		offsetZ = d.z;
+	}
+};
+Fvector CCC_FPDPositionOffset::d = { 0, 0, 0 };
+
 // helper functions --------------------------------------------
 
 bool valid_saved_game_name(LPCSTR file_name)
@@ -2072,7 +2211,10 @@ void CCC_RegisterCommands()
 	//#ifndef MASTER_GOLD
 	CMD1(CCC_DemoPlay, "demo_play");
 	CMD1(CCC_DemoRecord, "demo_record");
+	CMD1(CCC_DemoRecordBlockedInput, "demo_record_blocked_input");
+	CMD1(CCC_DemoRecordStop, "demo_record_stop");
 	CMD1(CCC_DemoRecordSetPos, "demo_set_cam_position");
+	CMD1(CCC_DemoRecordSetDir, "demo_set_cam_direction");
 	//#endif // #ifndef MASTER_GOLD
 
 #ifndef MASTER_GOLD
@@ -2448,6 +2590,8 @@ void CCC_RegisterCommands()
 
 	CMD4(CCC_Integer, "ai_die_in_anomaly", &g_ai_die_in_anomaly, 0, 1); //Alundaio
 
+	CMD4(CCC_Integer, "pseudogiant_can_damage_objects_on_stomp", &pseudogiantCanDamageObjects, 0, 1);
+
 	CMD4(CCC_Float, "ai_aim_predict_time", &g_aim_predict_time, 0.f, 10.f);
 
 	CMD4(CCC_Float, "head_bob_factor", &g_head_bob_factor, 0.f, 2.f);
@@ -2508,6 +2652,21 @@ void CCC_RegisterCommands()
 	CMD3(CCC_Mask, "g_feel_grenade", &psDeviceFlags2, rsFeelGrenade);
 	CMD3(CCC_Mask, "g_always_active", &psDeviceFlags2, rsAlwaysActive);
 
+	// demonized: use_english_text_for_missing_translations
+	CMD4(CCC_Integer, "use_english_text_for_missing_translations", &use_english_text_for_missing_translations, 0, 1);
+
+	//First Person Death
+	CMD4(CCC_Integer, "first_person_death", &firstPersonDeath, 0, 1);
+	CMD1(CCC_FPDDirectionOffset, "first_person_death_direction_offset");
+	CMD1(CCC_FPDPositionOffset, "first_person_death_position_offset");
+	CMD4(CCC_Integer, "first_person_death_position_smoothing", &firstPersonDeathPositionSmoothing, 1, 30);
+	CMD4(CCC_Integer, "first_person_death_direction_smoothing", &firstPersonDeathDirectionSmoothing, 1, 60);
+	CMD4(CCC_Float, "first_person_death_near_plane_offset", &viewportNearOffset, -0.1, 0.5);
+
+	//Toggle crash saving
+	CMD4(CCC_Integer, "crash_save", &crash_saving::enabled, 0, 1);
+	CMD4(CCC_Integer, "crash_save_count", &crash_saving::saveCountMax, 0, 20);
+
 	if (strstr(Core.Params, "-dbgdev"))
 		CMD4(CCC_Float, "g_streff", &streff, -10.f, 10.f);
 	//No need for server commands in a singleplayer-only mod
diff --git a/src/xrGame/death_anims_predicates.cpp b/src/xrGame/death_anims_predicates.cpp
index 05efd48..c9d6437 100644
--- a/src/xrGame/death_anims_predicates.cpp
+++ b/src/xrGame/death_anims_predicates.cpp
@@ -6,6 +6,7 @@
 #include	"ai/stalker/ai_stalker.h"
 #include	"stalker_movement_manager_smart_cover.h"
 #include	"weaponshotgun.h"
+#include	"WeaponAutomaticShotgun.h"
 #include	"explosive.h"
 #include	"weaponmagazined.h"
 #include	"CharacterPhysicsSupport.h"
@@ -177,8 +178,11 @@ class type_motion2 : public type_motion
 			return false;
 		//static_cast<CGameObject*>(O)->cast_weapon()
 		CWeaponShotgun* s = smart_cast<CWeaponShotgun*>(static_cast<CGameObject*>(O));
-		if (!s)
-			return false;
+		if (!s) {
+			CWeaponAutomaticShotgun* s = smart_cast<CWeaponAutomaticShotgun*>(static_cast<CGameObject*>(O));
+			if (!s)
+				return false;
+		}		
 		Fvector p;
 		const float max_distance = 20.f;
 		if (Fvector().sub(H.initiator()->Position(), global_hit_position(p, ea, H)).magnitude() > max_distance)
diff --git a/src/xrGame/first_bullet_controller.h b/src/xrGame/first_bullet_controller.h
index 0d3548b..e55621e 100644
--- a/src/xrGame/first_bullet_controller.h
+++ b/src/xrGame/first_bullet_controller.h
@@ -14,6 +14,7 @@ public:
 	void load(shared_str const& section);
 	bool is_bullet_first(float actor_linear_velocity) const;
 	inline float get_fire_dispertion() const { return m_fire_dispertion; };
+	inline void set_fire_dispertion(float val) { m_fire_dispertion = val; };
 	void make_shot();
 }; //class first_bullet_controller
 
diff --git a/src/xrGame/level_script.cpp b/src/xrGame/level_script.cpp
index c16d21c..14b450b 100644
--- a/src/xrGame/level_script.cpp
+++ b/src/xrGame/level_script.cpp
@@ -50,6 +50,7 @@
 #include "../xrEngine/GameMtlLib.h"
 #include "../xrEngine/xr_input.h"
 #include "script_ini_file.h"
+#include "EffectorBobbing.h"
 
 using namespace luabind;
 
@@ -333,6 +334,12 @@ void map_remove_object_spot(u16 id, LPCSTR spot_type)
 	Level().MapManager().RemoveMapLocation(spot_type, id);
 }
 
+// demonized: remove all map object spots by id
+void map_remove_all_object_spots(u16 id)
+{
+	Level().MapManager().RemoveAllMapLocationsById(id);
+}
+
 u16 map_has_object_spot(u16 id, LPCSTR spot_type)
 {
 	return Level().MapManager().HasMapLocation(spot_type, id);
@@ -626,6 +633,27 @@ float add_cam_effector(LPCSTR fn, int id, bool cyclic, LPCSTR cb_func, float cam
 	return e->GetAnimatorLength();
 }
 
+// demonized: Set custom camera position and direction with movement smoothing (for cutscenes, etc)
+void set_cam_position_direction(Fvector& position, Fvector& direction, unsigned int smoothing)
+{
+	CActor* actor = Actor();
+	actor->initFPCam();
+	actor->m_FPCam->m_HPB.set(direction);
+	actor->m_FPCam->m_Position.set(position);
+	actor->m_FPCam->m_customSmoothing = smoothing;
+}
+
+void set_cam_position_direction(Fvector& position, Fvector& direction)
+{
+	set_cam_position_direction(position, direction, 1);
+}
+
+void remove_cam_position_direction() 
+{
+	CActor* actor = Actor();
+	actor->removeFPCam();
+}
+
 void remove_cam_effector(int id)
 {
 	Actor()->Cameras().RemoveCamEffector((ECamEffectorType)id);
@@ -679,6 +707,15 @@ void set_snd_volume(float v)
 	clamp(psSoundVFactor, 0.0f, 1.0f);
 }
 
+float get_music_volume() {
+	return psSoundVMusicFactor;
+}
+
+void set_music_volume(float v) {
+	psSoundVMusicFactor = v;
+	clamp(psSoundVMusicFactor, 0.0f, 1.0f);
+}
+
 #include "actor_statistic_mgr.h"
 
 void add_actor_points(LPCSTR sect, LPCSTR detail_key, int cnt, int pts)
@@ -1374,6 +1411,98 @@ const Fvector2 world2ui(Fvector pos, bool hud = false)
 	return { x,y };
 }
 
+// demonized: unproject ui coordinates (ie mouse cursor coordinates) to world coordinates
+// returns position and underlying object id if found. If there is no object, obj_id will be 65535
+void ui2world(Fvector2 pos, Fvector& res, u16& obj_id)
+{
+	res.set(0, 0, 0);
+	if (pos.x < 0 || pos.x > UI_BASE_WIDTH || pos.y < 0 || pos.y > UI_BASE_HEIGHT) {
+		return;
+	}
+
+	// Convert to [-1; 1] NDC space
+	pos.x = 2 * pos.x / UI_BASE_WIDTH - 1;
+	pos.y = 1 - 2 * pos.y / UI_BASE_HEIGHT;
+
+	Fmatrix mProject = Device.mFullTransform;
+
+	// 4x4 invert of camera matrix
+	{
+		Fmatrix& m = mProject;
+
+		float mProjectDet = m._11 * (m._22*m._33*m._44 + m._23*m._34*m._42 + m._24*m._32*m._43 - m._24*m._33*m._42 - m._23*m._32*m._44 - m._22*m._34*m._43)
+						-   m._21 * (m._12*m._33*m._44 + m._13*m._34*m._42 + m._14*m._32*m._43 - m._14*m._33*m._42 - m._13*m._32*m._44 - m._12*m._34*m._43)
+						+   m._31 * (m._12*m._23*m._44 + m._13*m._24*m._42 + m._14*m._22*m._43 - m._14*m._23*m._42 - m._13*m._22*m._44 - m._12*m._24*m._43)
+						-   m._41 * (m._12*m._23*m._34 + m._13*m._24*m._32 + m._14*m._22*m._33 - m._14*m._23*m._32 - m._13*m._22*m._34 - m._12*m._24*m._33);
+
+		Fmatrix mProjectAdjugate;
+		mProjectAdjugate._11 = m._22*m._33*m._44 + m._23*m._34*m._42 + m._24*m._32*m._43 - m._24*m._33*m._42 - m._23*m._32*m._44 - m._22*m._34*m._43;
+		mProjectAdjugate._12 = -m._12*m._33*m._44 - m._13*m._34*m._42 - m._14*m._32*m._43 + m._14*m._33*m._42 + m._13*m._32*m._44 + m._12*m._34*m._43;
+		mProjectAdjugate._13 = m._12*m._23*m._44 + m._13*m._24*m._42 + m._14*m._22*m._43 - m._14*m._23*m._42 - m._13*m._22*m._44 - m._12*m._24*m._43;
+		mProjectAdjugate._14 = -m._12*m._23*m._34 - m._13*m._24*m._32 - m._14*m._22*m._33 + m._14*m._23*m._32 + m._13*m._22*m._34 + m._12*m._24*m._33;
+
+		mProjectAdjugate._21 = -m._21*m._33*m._44 - m._23*m._34*m._41 - m._24*m._31*m._43 + m._24*m._33*m._41 + m._23*m._31*m._44 + m._21*m._34*m._43;
+		mProjectAdjugate._22 = m._11*m._33*m._44 + m._13*m._34*m._41 + m._14*m._31*m._43 - m._14*m._33*m._41 - m._13*m._31*m._44 - m._11*m._34*m._43;
+		mProjectAdjugate._23 = -m._11*m._23*m._44 - m._13*m._24*m._41 - m._14*m._21*m._43 + m._14*m._23*m._41 + m._13*m._21*m._44 + m._11*m._24*m._43;
+		mProjectAdjugate._24 = m._11*m._23*m._34 + m._13*m._24*m._31 + m._14*m._21*m._33 - m._14*m._23*m._31 - m._13*m._21*m._34 - m._11*m._24*m._33;
+
+		mProjectAdjugate._31 = m._21*m._32*m._44 + m._22*m._34*m._41 + m._24*m._31*m._42 - m._24*m._32*m._41 - m._22*m._31*m._44 - m._21*m._34*m._42;
+		mProjectAdjugate._32 = -m._11*m._32*m._44 - m._12*m._34*m._41 - m._14*m._31*m._42 + m._14*m._32*m._41 + m._12*m._31*m._44 + m._11*m._34*m._42;
+		mProjectAdjugate._33 = m._11*m._22*m._44 + m._12*m._24*m._41 + m._14*m._21*m._42 - m._14*m._22*m._41 - m._12*m._21*m._44 - m._11*m._24*m._42;
+		mProjectAdjugate._34 = -m._11*m._22*m._34 - m._12*m._24*m._31 - m._14*m._21*m._32 + m._14*m._22*m._31 + m._12*m._21*m._34 + m._11*m._24*m._32;
+
+		mProjectAdjugate._41 = -m._21*m._32*m._43 - m._22*m._33*m._41 - m._23*m._31*m._42 + m._23*m._32*m._41 + m._22*m._31*m._43 + m._21*m._33*m._42;
+		mProjectAdjugate._42 = m._11*m._32*m._43 + m._12*m._33*m._41 + m._13*m._31*m._42 - m._13*m._32*m._41 - m._12*m._31*m._43 - m._11*m._33*m._42;
+		mProjectAdjugate._43 = -m._11*m._22*m._43 - m._12*m._23*m._41 - m._13*m._21*m._42 + m._13*m._22*m._41 + m._12*m._21*m._43 + m._11*m._23*m._42;
+		mProjectAdjugate._44 = m._11*m._22*m._33 + m._12*m._23*m._31 + m._13*m._21*m._32 - m._13*m._22*m._31 - m._12*m._21*m._33 - m._11*m._23*m._32;
+
+		mProjectDet = 1.0 / mProjectDet;
+		mProjectAdjugate.mul(mProjectDet);
+		mProject.set(mProjectAdjugate);
+	}
+		
+	// get position at arbitrary depth
+	res.set(pos.x, pos.y, 1);
+	{
+		auto& e = mProject.m;
+		auto x = res.x;
+		auto y = res.y;
+		auto z = res.z;
+		float w = 1.0 / (e[0][3] * x + e[1][3] * y + e[2][3] * z + e[3][3]);
+
+		res.x = (e[0][0] * x + e[1][0] * y + e[2][0] * z + e[3][0]) * w;
+		res.y = (e[0][1] * x + e[1][1] * y + e[2][1] * z + e[3][1]) * w;
+		res.z = (e[0][2] * x + e[1][2] * y + e[2][2] * z + e[3][2]) * w;
+	}
+
+	// perform ray cast to get actual position
+	collide::rq_result R;
+	CObject* ignore = Actor();
+	Fvector start = Device.vCameraPosition;
+	Fvector dir;
+	dir.set(res).sub(start).normalize();
+	start.mad(dir, R_VIEWPORT_NEAR);
+	float range = g_pGamePersistent->Environment().CurrentEnv->far_plane;
+
+	obj_id = 65535;
+	if (Level().ObjectSpace.RayPick(start, dir, range, collide::rqtBoth, R, ignore))
+	{
+		res.mad(start, dir, R.range);
+
+		if (R.O) {
+			CGameObject* o = smart_cast<CGameObject*>(R.O);
+			if (o) {
+				obj_id = o->ID();
+			}
+		}
+	}
+}
+
+void ui2world(Fvector& pos, Fvector& res, u16& obj_id)
+{
+	ui2world(Fvector2().set(pos.x, pos.y), res, obj_id);
+}
+
 const float get_env_rads()
 {
 	if (!CurrentGameUI())
@@ -1675,6 +1804,9 @@ void CLevel::script_register(lua_State* L)
 			def("map_has_object_spot", map_has_object_spot),
 			def("map_change_spot_hint", map_change_spot_hint),
 
+			// demonized: remove all map object spots by id
+			def("map_remove_all_object_spots", map_remove_all_object_spots),
+
 			def("add_dialog_to_render", add_dialog_to_render),
 			def("remove_dialog_to_render", remove_dialog_to_render),
 			def("hide_indicators", hide_indicators),
@@ -1705,10 +1837,18 @@ void CLevel::script_register(lua_State* L)
 			def("get_snd_volume", &get_snd_volume),
 			def("get_rain_volume", &get_rain_volume),
 			def("set_snd_volume", &set_snd_volume),
+			def("get_music_volume", &get_music_volume),
+			def("set_music_volume", &set_music_volume),
 			def("add_cam_effector", ((float (*)(LPCSTR, int, bool, LPCSTR))&add_cam_effector)),
 			def("add_cam_effector", ((float (*)(LPCSTR, int, bool, LPCSTR, float))&add_cam_effector)),
 			def("add_cam_effector", ((float (*)(LPCSTR, int, bool, LPCSTR, float, bool))&add_cam_effector)),
 			def("add_cam_effector", ((float (*)(LPCSTR, int, bool, LPCSTR, float, bool, float))&add_cam_effector)),
+
+			// demonized: Set custom camera position and direction with movement smoothing (for cutscenes, etc)
+			def("set_cam_custom_position_direction", ((void (*)(Fvector&, Fvector&, unsigned int))&set_cam_position_direction)),
+			def("set_cam_custom_position_direction", ((void (*)(Fvector&, Fvector&))&set_cam_position_direction)),
+			def("remove_cam_custom_position_direction", &remove_cam_position_direction),
+
 			def("remove_cam_effector", &remove_cam_effector),
 			def("set_cam_effector_factor", &set_cam_effector_factor),
 			def("get_cam_effector_factor", &get_cam_effector_factor),
@@ -1762,6 +1902,21 @@ void CLevel::script_register(lua_State* L)
 		.def_readonly("object", &script_rq_result::O)
 		.def_readonly("range", &script_rq_result::range)
 		.def_readonly("element", &script_rq_result::element)
+		.def_readonly("material_name", &script_rq_result::pMaterialName)
+		.def_readonly("material_flags", &script_rq_result::pMaterialFlags)
+		.def_readonly("material_phfriction", &script_rq_result::fPHFriction)
+		.def_readonly("material_phdamping", &script_rq_result::fPHDamping)
+		.def_readonly("material_phspring", &script_rq_result::fPHSpring)
+		.def_readonly("material_phbounce_start_velocity", &script_rq_result::fPHBounceStartVelocity)
+		.def_readonly("material_phbouncing", &script_rq_result::fPHBouncing)
+		.def_readonly("material_flotation_factor", &script_rq_result::fFlotationFactor)
+		.def_readonly("material_shoot_factor", &script_rq_result::fShootFactor)
+		.def_readonly("material_shoot_factor_mp", &script_rq_result::fShootFactorMP)
+		.def_readonly("material_bounce_damage_factor", &script_rq_result::fBounceDamageFactor)
+		.def_readonly("material_injurious_speed", &script_rq_result::fInjuriousSpeed)
+		.def_readonly("material_vis_transparency_factor", &script_rq_result::fVisTransparencyFactor)
+		.def_readonly("material_snd_occlusion_factor", &script_rq_result::fSndOcclusionFactor)
+		.def_readonly("material_density_factor", &script_rq_result::fDensityFactor)
 		.def(constructor<>()),
 		class_<enum_exporter<collide::rq_target>>("rq_target")
 		.enum_("targets")
@@ -1887,6 +2042,8 @@ void CLevel::script_register(lua_State* L)
 		def("prefetch_texture", prefetch_texture),
 		def("prefetch_model", prefetch_model),
 		def("get_visual_userdata", GetVisualUserdata),
-		def("world2ui", world2ui)
+		def("world2ui", world2ui),
+		def("ui2world", (void (*)(Fvector2, Fvector&, u16&))&ui2world, pure_out_value(_2) + pure_out_value(_3)),
+		def("ui2world", (void (*)(Fvector&, Fvector&, u16&))&ui2world, pure_out_value(_2) + pure_out_value(_3))
 	];
 }
\ No newline at end of file
diff --git a/src/xrGame/level_sounds.cpp b/src/xrGame/level_sounds.cpp
index 28718aa..8ea30cb 100644
--- a/src/xrGame/level_sounds.cpp
+++ b/src/xrGame/level_sounds.cpp
@@ -1,4 +1,6 @@
 #include "stdafx.h"
+#include <random>
+#include <algorithm>
 #pragma hdrstop
 
 #include "level.h"
@@ -188,6 +190,9 @@ void CLevelSoundManager::Load()
 				Msg("- Loading music tracks from '%s'...",music_sect);
 #endif // #ifdef DEBUG
 				CInifile::Sect& S = gameLtx.r_section(music_sect);
+				std::random_device rd;
+				std::mt19937 g(rd());
+				std::shuffle(S.Data.begin(), S.Data.end(), g);
 				CInifile::SectCIt it = S.Data.begin(), end = S.Data.end();
 				m_MusicTracks.reserve(S.Data.size());
 				for (; it != end; it++)
@@ -206,6 +211,7 @@ void CLevelSoundManager::Unload()
 	m_StaticSounds.clear();
 	// music
 	m_MusicTracks.clear();
+	m_PlayedMusicIndices.clear();
 }
 
 void CLevelSoundManager::Update()
@@ -228,32 +234,46 @@ void CLevelSoundManager::Update()
 		if (m_CurrentTrack < 0 && engine_time > m_NextTrackTime)
 		{
 			U32Vec indices;
-			for (u32 k = 0; k < m_MusicTracks.size(); ++k)
+			for (u32 k = 0; k < m_MusicTracks.size(); k++)
 			{
+				// Msg("Checking track %d", k);
 				SMusicTrack& T = m_MusicTracks[k];
-				if (T.IsPlaying())
+				if (T.IsPlaying()) {
 					T.Stop();
-
-				if (T.in(game_time))
+					// Msg("Stopping track %d", k);
+				}
+				if ((T.in(game_time) && m_PlayedMusicIndices.empty()) || 
+					(T.in(game_time) && !(std::find(m_PlayedMusicIndices.begin(), m_PlayedMusicIndices.end(), k) != m_PlayedMusicIndices.end()))) {
 					indices.push_back(k);
-				/*
-								if ((0==T.m_ActiveTime.x) && (0==T.m_ActiveTime.y)||
-									((int(game_time)>=T.m_ActiveTime.x)&&(int(game_time)<T.m_ActiveTime.y)))
-									indices.push_back	(k);
-				*/
+					// Msg("Pushing track %d", k);
+					/*
+									if ((0==T.m_ActiveTime.x) && (0==T.m_ActiveTime.y)||
+										((int(game_time)>=T.m_ActiveTime.x)&&(int(game_time)<T.m_ActiveTime.y)))
+										indices.push_back	(k);
+					*/
+				}
 			}
 			if (!indices.empty())
 			{
-				u32 idx = Random.randI(indices.size());
+				//u32 idx = Random.randI(indices.size());
+				u32 idx = 0;
 				m_CurrentTrack = indices[idx];
 				SMusicTrack& T = m_MusicTracks[m_CurrentTrack];
 				T.Play();
+				m_PlayedMusicIndices.push_back(indices[idx]);
+				// Msg("Starting track %d", indices[idx]);
 #ifdef DEBUG
 				Log				("- Play music track:",T.m_DbgName.c_str());
 #endif
 			}
 			else
 			{
+				// Msg("m_PlayedMusicIndices.size %d", m_PlayedMusicIndices.size());
+				m_PlayedMusicIndices.clear();
+				std::random_device rd;
+				std::mt19937 g(rd());
+				std::shuffle(m_MusicTracks.begin(), m_MusicTracks.end(), g);
+				// Msg("Refreshing tracks");
 				m_NextTrackTime = engine_time + 10000; // next check after 10 sec
 			}
 		}
@@ -262,7 +282,7 @@ void CLevelSoundManager::Update()
 		{
 			SMusicTrack& T = m_MusicTracks[m_CurrentTrack];
 			if (!T.IsPlaying())
-			{
+			{	
 				m_CurrentTrack = -1;
 				m_NextTrackTime = engine_time;
 
diff --git a/src/xrGame/level_sounds.h b/src/xrGame/level_sounds.h
index 596cc31..79359b6 100644
--- a/src/xrGame/level_sounds.h
+++ b/src/xrGame/level_sounds.h
@@ -44,6 +44,7 @@ class CLevelSoundManager
 	StaticSoundsVec m_StaticSounds;
 	DEFINE_VECTOR(SMusicTrack, MusicTrackVec, MusicTrackVecIt);
 	MusicTrackVec m_MusicTracks;
+	U32Vec m_PlayedMusicIndices; //Already played music array
 	u32 m_NextTrackTime;
 	int m_CurrentTrack;
 public:
diff --git a/src/xrGame/map_manager.cpp b/src/xrGame/map_manager.cpp
index b354e38..dc72c28 100644
--- a/src/xrGame/map_manager.cpp
+++ b/src/xrGame/map_manager.cpp
@@ -170,6 +170,21 @@ void CMapManager::RemoveMapLocation(const shared_str& spot_type, u16 id)
 	}
 }
 
+// demonized: remove all map object spots by id
+void CMapManager::RemoveAllMapLocationsById(u16 id)
+{
+	for (Locations_it it = Locations().begin(); it != Locations().end(); ) {
+		if (it->object_id == id) {
+			if (IsGameTypeSingle())
+				Level().GameTaskManager().MapLocationRelcase((*it).location);
+			Destroy((*it).location);
+			it = Locations().erase(it);
+		} else {
+			it++;
+		}
+	}
+}
+
 void CMapManager::RemoveMapLocationByObjectID(u16 id) //call on destroy object
 {
 	FindLocationByID key(id);
diff --git a/src/xrGame/map_manager.h b/src/xrGame/map_manager.h
index a49b14a..56eb0ee 100644
--- a/src/xrGame/map_manager.h
+++ b/src/xrGame/map_manager.h
@@ -21,6 +21,10 @@ public:
 	CMapLocation* AddMapLocation(const shared_str& spot_type, u16 id);
 	CMapLocation* AddRelationLocation(CInventoryOwner* pInvOwner);
 	void RemoveMapLocation(const shared_str& spot_type, u16 id);
+
+	// demonized: remove all map object spots by id
+	void RemoveAllMapLocationsById(u16 id);
+
 	bool HasMapLocation(const shared_str& spot_type, u16 id);
 	void RemoveMapLocationByObjectID(u16 id); //call on destroy object
 	void RemoveMapLocation(CMapLocation* ml);
diff --git a/src/xrGame/player_hud.cpp b/src/xrGame/player_hud.cpp
index 96fae36..46f77f2 100644
--- a/src/xrGame/player_hud.cpp
+++ b/src/xrGame/player_hud.cpp
@@ -401,7 +401,7 @@ void attachable_hud_item::load(const shared_str& sect_name)
 	// Visual
 	LPCSTR visual_name = pSettings->r_string(sect_name, "item_visual");
 	IKinematicsAnimated* visual = ::Render->model_Create(visual_name)->dcast_PKinematicsAnimated();
-	R_ASSERT2(visual, make_string("could not create model %s", visual_name));
+	R_ASSERT2(visual, make_string("could not create model %s, section %s", visual_name, sect_name.c_str()));
 	m_model = smart_cast<IKinematics*>(visual);
 
 	m_attach_place_idx = pSettings->r_u16(sect_name, "attach_place_idx");
@@ -456,7 +456,7 @@ u32 attachable_hud_item::anim_play(const shared_str& anm_name_b, BOOL bMixIn, co
 		else if (bDebug)
 			Msg("playing item animation [%s]", item_anm_name.c_str());
 
-		R_ASSERT3(M2.valid(), "model has no motion [idle] ", pSettings->r_string(m_sect_name, "item_visual"));
+		R_ASSERT3(M2.valid(), make_string("model has no motion [idle], section %s", m_sect_name.c_str()).c_str(), pSettings->r_string(m_sect_name, "item_visual"));
 
 		u16 root_id = m_model->LL_GetBoneRoot();
 		CBoneInstance& root_binst = m_model->LL_GetBoneInstance(root_id);
@@ -1263,7 +1263,7 @@ player_hud_motion_container* player_hud::get_hand_motions(LPCSTR section)
 		if (phm->section == section)
 			return &phm->pm;
 	}
-
+	
 	hand_motions* res = xr_new<hand_motions>();
 	res->section = section;
 	res->pm.load(m_model, section);
@@ -1442,8 +1442,10 @@ void player_hud::remove_from_model_pool(LPCSTR sect)
 	}
 }
 
+shared_str current_player_hud_sect;
 attachable_hud_item* player_hud::create_hud_item(const shared_str& sect)
 {
+	current_player_hud_sect = sect;
 	xr_vector<attachable_hud_item*>::iterator it = m_pool.begin();
 	xr_vector<attachable_hud_item*>::iterator it_e = m_pool.end();
 	for (; it != it_e; ++it)
diff --git a/src/xrGame/raypick.cpp b/src/xrGame/raypick.cpp
index 8fd463b..a07bb0c 100644
--- a/src/xrGame/raypick.cpp
+++ b/src/xrGame/raypick.cpp
@@ -1,6 +1,7 @@
 #include "stdafx.h"
 #include "raypick.h"
 #include "level.h"
+#include "material_manager.h"
 
 CRayPick::CRayPick()
 {
@@ -28,6 +29,30 @@ bool CRayPick::query()
 	if (Level().ObjectSpace.RayPick(start_position, direction, range, flags, R, ignore))
 	{
 		result.set(R);
+		if (!R.O) {
+			//Msg("no object, check material");
+			auto pTri = Level().ObjectSpace.GetStaticTris() + R.element;
+			auto pMaterial = GMLib.GetMaterialByIdx(pTri->material);
+			auto pMaterialFlags = pMaterial->Flags;
+			//result.pTri = pTri;
+			//result.pMaterial = pMaterial;
+			result.pMaterialFlags = pMaterialFlags.flags;
+			result.pMaterialName = pMaterial->m_Name.c_str();
+
+			result.fPHFriction = pMaterial->fPHFriction;
+			result.fPHDamping = pMaterial->fPHDamping;
+			result.fPHSpring = pMaterial->fPHSpring;
+			result.fPHBounceStartVelocity = pMaterial->fPHBounceStartVelocity;
+			result.fPHBouncing = pMaterial->fPHBouncing;
+			result.fFlotationFactor = pMaterial->fFlotationFactor;
+			result.fShootFactor = pMaterial->fShootFactor;
+			result.fShootFactorMP = pMaterial->fShootFactorMP;
+			result.fBounceDamageFactor = pMaterial->fBounceDamageFactor;
+			result.fInjuriousSpeed = pMaterial->fInjuriousSpeed;
+			result.fVisTransparencyFactor = pMaterial->fVisTransparencyFactor;
+			result.fSndOcclusionFactor = pMaterial->fSndOcclusionFactor;
+			result.fDensityFactor = pMaterial->fDensityFactor;
+		}
 		return true;
 	}
 	else
diff --git a/src/xrGame/raypick.h b/src/xrGame/raypick.h
index 81e990e..ff36f04 100644
--- a/src/xrGame/raypick.h
+++ b/src/xrGame/raypick.h
@@ -9,6 +9,26 @@ struct script_rq_result
 	float range;
 	int element;
 
+	// Material of tri of ray query result
+	str_c pMaterialName;
+	u32 pMaterialFlags;
+
+	// physics part
+	float fPHFriction; // ?
+	float fPHDamping; // ?
+	float fPHSpring; // ?
+	float fPHBounceStartVelocity; // ?
+	float fPHBouncing; // ?
+					   // shoot&bounce&visibility&flotation
+	float fFlotationFactor; // 0.f - 1.f (1.f- )
+	float fShootFactor; // 0.f - 1.f (1.f- )
+	float fShootFactorMP; // 0.f - 1.f (1.f- )
+	float fBounceDamageFactor; // 0.f - 100.f
+	float fInjuriousSpeed; // 0.f - ... (0.f-   (  ))
+	float fVisTransparencyFactor; // 0.f - 1.f (1.f- )
+	float fSndOcclusionFactor; // 0.f - 1.f (1.f- )
+	float fDensityFactor;
+
 	script_rq_result()
 	{
 		O = 0;
diff --git a/src/xrGame/script_game_object.cpp b/src/xrGame/script_game_object.cpp
index 5489997..9a1a917 100644
--- a/src/xrGame/script_game_object.cpp
+++ b/src/xrGame/script_game_object.cpp
@@ -369,6 +369,32 @@ Fvector CScriptGameObject::bone_position(LPCSTR bone_name, bool bHud) const
 	return (matrix.c);
 }
 
+Fvector CScriptGameObject::bone_direction(LPCSTR bone_name, bool bHud) const
+{
+	IKinematics* k = nullptr;
+
+	CHudItem* itm = smart_cast<CHudItem*>(&object());
+	if (bHud && itm)
+		k = itm->HudItemData()->m_model;
+	else
+		k = object().Visual()->dcast_PKinematics();
+
+	u16 bone_id;
+	if (xr_strlen(bone_name))
+	{
+		bone_id = k->LL_BoneID(bone_name);
+		if (bone_id == BI_NONE)
+			bone_id = k->LL_GetBoneRoot();
+	} else
+		bone_id = k->LL_GetBoneRoot();
+
+	Fmatrix matrix;
+	Fvector res;
+	matrix.mul_43((bHud && itm) ? itm->HudItemData()->m_item_transform : object().XFORM(),
+		k->LL_GetTransform(bone_id));
+	matrix.getHPB(res);
+	return (res);
+}
 
 LPCSTR CScriptGameObject::bone_name(u16 id, bool bHud)
 {
diff --git a/src/xrGame/script_game_object.h b/src/xrGame/script_game_object.h
index 640dcab..ed31343 100644
--- a/src/xrGame/script_game_object.h
+++ b/src/xrGame/script_game_object.h
@@ -683,6 +683,7 @@ public:
 	void stop_particles(LPCSTR pname, LPCSTR bone);
 
 	Fvector bone_position(LPCSTR bone_name, bool bHud = false) const;
+	Fvector bone_direction(LPCSTR bone_name, bool bHud = false) const;
 	LPCSTR bone_name(u16 id, bool bHud);
 	bool is_body_turning() const;
 	cphysics_shell_scripted* get_physics_shell() const;
@@ -937,6 +938,12 @@ public:
 	u8 GetRestrictionType();
 	void SetRestrictionType(u8 typ);
 
+	// demonized: add getters and setters for pathfinding for npcs around anomalies and damage for npcs
+	bool get_enable_anomalies_pathfinding();
+	void set_enable_anomalies_pathfinding(bool v);
+	bool get_enable_anomalies_damage();
+	void set_enable_anomalies_damage(bool v);
+
 	//Weapon
 	void Weapon_AddonAttach(CScriptGameObject* item);
 	void Weapon_AddonDetach(LPCSTR item_section, bool b_spawn_item = true);
@@ -998,6 +1005,9 @@ public:
 	void SetArtefactBleedingRestoreSpeed(float value);
 	void SetArtefactImmunity(ALife::EHitType hit_type, float value);
 
+	float GetArtefactAdditionalInventoryWeight();
+	void SetArtefactAdditionalInventoryWeight(float value);
+
 	//Eatable items
 	void SetRemainingUses(u8 value);
 	u8 GetRemainingUses();
@@ -1027,6 +1037,14 @@ public:
 	void SetActorRunCoef(float run_coef);
 	float GetActorRunBackCoef() const;
 	void SetActorRunBackCoef(float run_back_coef);
+	float GetActorWalkAccel() const;
+	void SetActorWalkAccel(float val);
+	float GetActorWalkBackCoef() const;
+	void SetActorWalkBackCoef(float val);
+
+	// demonized: Adjust Lookout coeff
+	float GetActorLookoutCoef() const;
+	void SetActorLookoutCoef(float val);
 
 	void SetCharacterIcon(LPCSTR iconName);
 #endif
diff --git a/src/xrGame/script_game_object3.cpp b/src/xrGame/script_game_object3.cpp
index c7b3f95..421b3f4 100644
--- a/src/xrGame/script_game_object3.cpp
+++ b/src/xrGame/script_game_object3.cpp
@@ -1540,6 +1540,22 @@ void CScriptGameObject::SetArtefactImmunity(ALife::EHitType hit_type, float valu
 	return artefact->SetImmunity(hit_type, value);
 }
 
+float CScriptGameObject::GetArtefactAdditionalInventoryWeight()
+{
+	CArtefact* artefact = smart_cast<CArtefact*>(&object());
+	THROW(artefact);
+
+	return artefact->m_additional_weight;
+}
+
+void CScriptGameObject::SetArtefactAdditionalInventoryWeight(float value)
+{
+	CArtefact* artefact = smart_cast<CArtefact*>(&object());
+	THROW(artefact);
+
+	artefact->m_additional_weight = value;
+}
+
 void CScriptGameObject::AttachVehicle(CScriptGameObject* veh, bool bForce)
 {
 	CActor* actor = smart_cast<CActor*>(&object());
@@ -1823,5 +1839,51 @@ void CScriptGameObject::SetRestrictionType(u8 typ)
 			Level().space_restriction_manager().register_restrictor(restr, RestrictionSpace::ERestrictorTypes(typ));
 	}
 }
+
+// demonized: add getters and setters for pathfinding for npcs around anomalies and damage for npcs
+bool CScriptGameObject::get_enable_anomalies_pathfinding()
+{
+	auto stalker = smart_cast<CAI_Stalker*>(&object());
+	if (!stalker)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CGameObject : cannot access class member m_enable_anomalies_pathfinding!");
+		return false;
+	}
+	return stalker->m_enable_anomalies_pathfinding;
+}
+void CScriptGameObject::set_enable_anomalies_pathfinding(bool v)
+{
+	auto stalker = smart_cast<CAI_Stalker*>(&object());
+	if (!stalker)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CGameObject : cannot access class member m_enable_anomalies_pathfinding!");
+		return;
+	}
+	stalker->m_enable_anomalies_pathfinding = v;
+}
+bool CScriptGameObject::get_enable_anomalies_damage()
+{
+	auto stalker = smart_cast<CAI_Stalker*>(&object());
+	if (!stalker)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CGameObject : cannot access class member m_enable_anomalies_damage!");
+		return false;
+	}
+	return stalker->m_enable_anomalies_damage;
+}
+void CScriptGameObject::set_enable_anomalies_damage(bool v)
+{
+	auto stalker = smart_cast<CAI_Stalker*>(&object());
+	if (!stalker)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CGameObject : cannot access class member m_enable_anomalies_damage!");
+		return;
+	}
+	stalker->m_enable_anomalies_damage = v;
+}
 #endif
 //-Alundaio
\ No newline at end of file
diff --git a/src/xrGame/script_game_object_inventory_owner.cpp b/src/xrGame/script_game_object_inventory_owner.cpp
index 3ad0a2f..377a214 100644
--- a/src/xrGame/script_game_object_inventory_owner.cpp
+++ b/src/xrGame/script_game_object_inventory_owner.cpp
@@ -2491,6 +2491,55 @@ void CScriptGameObject::SetActorRunBackCoef(float run_back_coef)
 	pActor->m_fRunBackFactor = run_back_coef;
 }
 
+
+float CScriptGameObject::GetActorWalkAccel() const
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member GetActorWalkAccel!");
+		return (false);
+	}
+	return (pActor->m_fWalkAccel);
+}
+void CScriptGameObject::SetActorWalkAccel(float val)
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member SetActorWalkAccel!");
+		return;
+	}
+	pActor->m_fWalkAccel = val;
+}
+
+
+float CScriptGameObject::GetActorWalkBackCoef() const
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member GetActorWalkBackCoef!");
+		return (false);
+	}
+	return (pActor->m_fWalkBackFactor);
+}
+void CScriptGameObject::SetActorWalkBackCoef(float val)
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member SetActorWalkBackCoef!");
+		return;
+	}
+	pActor->m_fWalkBackFactor = val;
+}
+
+
 void CScriptGameObject::SetCharacterIcon(LPCSTR iconName)
 {
 	CInventoryOwner* pInventoryOwner = smart_cast<CInventoryOwner*>(&object());
@@ -2503,5 +2552,30 @@ void CScriptGameObject::SetCharacterIcon(LPCSTR iconName)
 	}
 	return pInventoryOwner->SetIcon(iconName);
 }
+
+// demonized: Adjust Lookout factor
+float CScriptGameObject::GetActorLookoutCoef() const
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member GetActorLookoutCoef!");
+		return (false);
+	}
+	return (pActor->m_fLookoutFactor);
+}
+void CScriptGameObject::SetActorLookoutCoef(float val)
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member SetActorLookoutCoef!");
+		return;
+	}
+	pActor->m_fLookoutFactor = val;
+}
+
 #endif
 //Alundaio: END
diff --git a/src/xrGame/script_game_object_script3.cpp b/src/xrGame/script_game_object_script3.cpp
index aeeaf8f..477e99f 100644
--- a/src/xrGame/script_game_object_script3.cpp
+++ b/src/xrGame/script_game_object_script3.cpp
@@ -115,6 +115,7 @@ class_<CScriptGameObject>& script_register_game_object2(class_<CScriptGameObject
 			     ::set_item))
 
 		.def("bone_position", &CScriptGameObject::bone_position)
+		.def("bone_direction", &CScriptGameObject::bone_direction)
 
 		.def("bone_name", &CScriptGameObject::bone_name)
 		.def("is_body_turning", &CScriptGameObject::is_body_turning)
@@ -304,6 +305,7 @@ class_<CScriptGameObject>& script_register_game_object2(class_<CScriptGameObject
 		.def("get_artefact_power", &CScriptGameObject::GetArtefactPowerRestoreSpeed)
 		.def("get_artefact_bleeding", &CScriptGameObject::GetArtefactBleedingRestoreSpeed)
 		.def("get_artefact_immunity", &CScriptGameObject::GetArtefactImmunity)
+		.def("get_artefact_additional_inventory_weight", &CScriptGameObject::GetArtefactAdditionalInventoryWeight)
 
 		.def("set_artefact_health", &CScriptGameObject::SetArtefactHealthRestoreSpeed)
 		.def("set_artefact_radiation", &CScriptGameObject::SetArtefactRadiationRestoreSpeed)
@@ -311,6 +313,7 @@ class_<CScriptGameObject>& script_register_game_object2(class_<CScriptGameObject
 		.def("set_artefact_power", &CScriptGameObject::SetArtefactPowerRestoreSpeed)
 		.def("set_artefact_bleeding", &CScriptGameObject::SetArtefactBleedingRestoreSpeed)
 		.def("set_artefact_immunity", &CScriptGameObject::SetArtefactImmunity)
+		.def("set_artefact_additional_inventory_weight", &CScriptGameObject::SetArtefactAdditionalInventoryWeight)
 
 		//HELICOPTER
 		.def("get_helicopter", &CScriptGameObject::get_helicopter)
@@ -536,6 +539,22 @@ class_<CScriptGameObject>& script_register_game_object2(class_<CScriptGameObject
 		.def("get_actor_runback_coef", &CScriptGameObject::GetActorRunBackCoef)
 		.def("set_actor_runback_coef", &CScriptGameObject::SetActorRunBackCoef)
 		//end AVO
+
+		// demonized: Additional exports
+		.def("get_actor_walk_accel", &CScriptGameObject::GetActorWalkAccel)
+		.def("set_actor_walk_accel", &CScriptGameObject::SetActorWalkAccel)
+		.def("get_actor_walk_back_coef", &CScriptGameObject::GetActorWalkBackCoef)
+		.def("set_actor_walk_back_coef", &CScriptGameObject::SetActorWalkBackCoef)
+
+		// demonized: Adjust Lookout factor
+		.def("get_actor_lookout_coef", &CScriptGameObject::GetActorLookoutCoef)
+		.def("set_actor_lookout_coef", &CScriptGameObject::SetActorLookoutCoef)
+
+		// demonized: add getters and setters for pathfinding for npcs around anomalies and damage for npcs
+		.def("get_enable_anomalies_pathfinding", &CScriptGameObject::get_enable_anomalies_pathfinding)
+		.def("set_enable_anomalies_pathfinding", &CScriptGameObject::set_enable_anomalies_pathfinding)
+		.def("get_enable_anomalies_damage", &CScriptGameObject::get_enable_anomalies_damage)
+		.def("set_enable_anomalies_damage", &CScriptGameObject::set_enable_anomalies_damage)
 #endif
 
 		.def("set_can_be_harmed", &CScriptGameObject::SetCanBeHarmed)
diff --git a/src/xrGame/space_restrictor.cpp b/src/xrGame/space_restrictor.cpp
index 6448d01..3b50ea4 100644
--- a/src/xrGame/space_restrictor.cpp
+++ b/src/xrGame/space_restrictor.cpp
@@ -79,7 +79,8 @@ BOOL CSpaceRestrictor::net_Spawn(CSE_Abstract* data)
 
 	//Alundaio: zone visible for ai if g_ai_die_in_anomaly = 1 unless it's Radioactive Zone or Campfire
 	CCustomZone* zone = smart_cast<CCustomZone*>(this);
-	if (g_ai_die_in_anomaly == 0 || !zone || smart_cast<CRadioactiveZone*>(zone) || smart_cast<CZoneCampfire*>(zone))
+	//if (g_ai_die_in_anomaly == 0 || !zone || smart_cast<CRadioactiveZone*>(zone) || smart_cast<CZoneCampfire*>(zone))
+	if (!zone || smart_cast<CRadioactiveZone*>(zone) || smart_cast<CZoneCampfire*>(zone))
 		spatial.type &= ~STYPE_VISIBLEFORAI;
 
 	setEnabled(FALSE);
diff --git a/src/xrGame/string_table.cpp b/src/xrGame/string_table.cpp
index bc29288..300c635 100644
--- a/src/xrGame/string_table.cpp
+++ b/src/xrGame/string_table.cpp
@@ -30,6 +30,8 @@ void CStringTable::rescan()
 
 extern void refresh_npc_names();
 
+// demonized: use english text if locale text string is missing
+BOOL use_english_text_for_missing_translations = TRUE;
 void CStringTable::Init()
 {
 	if (NULL != pData) return;
@@ -39,6 +41,24 @@ void CStringTable::Init()
 	// ,    (NULL),   <text>  <string>  XML
 	pData->m_sLanguage = READ_IF_EXISTS(pSettings, r_string, "string_table", "language", "eng");
 
+	// demonized: parse english files first, then they will be replaced by current locale
+	if (use_english_text_for_missing_translations && xr_strcmp(pData->m_sLanguage, "eng") != 0) {
+		FS_FileSet fset;
+		string_path files_mask;
+		xr_sprintf(files_mask, "text\\%s\\*.xml", "eng");
+		FS.file_list(fset, "$game_config$", FS_ListFiles, files_mask);
+		FS_FileSetIt fit = fset.begin();
+		FS_FileSetIt fit_e = fset.end();
+
+		for (; fit != fit_e; ++fit)
+		{
+			string_path fn, ext;
+			_splitpath((*fit).name.c_str(), 0, 0, fn, ext);
+			xr_strcat(fn, ext);
+
+			Load(fn, "eng");
+		}
+	}
 
 	//---
 	FS_FileSet fset;
@@ -77,11 +97,12 @@ void CStringTable::Init()
 	discord_gameinfo.ex_update = true;
 }
 
-void CStringTable::Load(LPCSTR xml_file_full)
+void CStringTable::Load(LPCSTR xml_file_full, LPCSTR lang_in)
 {
+	LPCSTR lang = lang_in ? lang_in : pData->m_sLanguage.c_str();
 	CUIXml uiXml;
 	string_path _s;
-	strconcat(sizeof(_s), _s, "text\\", pData->m_sLanguage.c_str());
+	strconcat(sizeof(_s), _s, "text\\", lang);
 
 	uiXml.Load(CONFIG_PATH, _s, xml_file_full);
 
@@ -98,7 +119,7 @@ void CStringTable::Load(LPCSTR xml_file_full)
 		LPCSTR string_text = uiXml.Read(uiXml.GetRoot(), "string:text", i, NULL);
 
 		if (m_bWriteErrorsToLog && string_text)
-			Msg("[string table] '%s' no translation in '%s'", string_name, pData->m_sLanguage.c_str());
+			Msg("[string table] '%s' no translation in '%s'", string_name, lang);
 
 		VERIFY3(string_text, "string table entry does not have a text", string_name);
 
diff --git a/src/xrGame/string_table.h b/src/xrGame/string_table.h
index 1f0faea..0132c16 100644
--- a/src/xrGame/string_table.h
+++ b/src/xrGame/string_table.h
@@ -33,7 +33,7 @@ public:
 	void ReloadLanguage();
 private:
 	void Init();
-	void Load(LPCSTR xml_file);
+	void Load(LPCSTR xml_file, LPCSTR lang = 0);
 	static STRING_VALUE ParseLine(LPCSTR str, LPCSTR key, bool bFirst);
 	static STRING_TABLE_DATA* pData;
 };
diff --git a/src/xrGame/ui/UILines.cpp b/src/xrGame/ui/UILines.cpp
index d639789..44b48a1 100644
--- a/src/xrGame/ui/UILines.cpp
+++ b/src/xrGame/ui/UILines.cpp
@@ -7,6 +7,7 @@
 // Copyright 2005 GSC Game World
 
 #include "StdAfx.h"
+#include <cstdio>
 
 #include "UILines.h"
 #include "UIXmlInit.h"
@@ -158,7 +159,12 @@ void CUILines::ParseText(bool force)
 				{
 					bNewLines = TRUE;
 					*pszTemp = '\0';
-					ptmp_line->AddSubLine(pszSearch, tcolor);
+					CUISubLine subline;
+					subline.m_text = pszSearch;
+					subline.m_color = tcolor;
+					subline.m_last_in_line = true;
+					//ptmp_line->AddSubLine(pszSearch, tcolor);
+					ptmp_line->AddSubLine(&subline);
 					pszSearch = pszTemp + 2;
 				}
 				ptmp_line->AddSubLine(pszSearch, tcolor);
@@ -201,8 +207,9 @@ void CUILines::ParseText(bool force)
 		{
 			for (int i = 0; i < vsz; i++)
 			{
-				const char* pszText = line->m_subLines[i].m_text.c_str();
-				const u32 tcolor = line->m_subLines[i].m_color;
+				CUISubLine* pSubLine = &line->m_subLines[i];
+				const char* pszText = pSubLine->m_text.c_str();
+				const u32 tcolor = pSubLine->m_color;
 				u16 uFrom = 0, uPartLen = 0;
 				VERIFY(pszText);
 				u16 nMarkers = m_pFont->SplitByWidth(aMarkers, UBUFFER_SIZE, fTargetWidth, pszText);
@@ -222,8 +229,11 @@ void CUILines::ParseText(bool force)
 				}
 				strncpy_s(szTempLine, pszText + uFrom, MAX_MB_CHARS);
 				tmp_line.AddSubLine(szTempLine, tcolor);
-				m_lines.push_back(tmp_line);
-				tmp_line.Clear();
+				if (pSubLine->m_last_in_line || i == (vsz -1))
+				{
+					m_lines.push_back(tmp_line);
+					tmp_line.Clear();
+				}
 			}
 		}
 	}
diff --git a/src/xrGame/ui/UILogsWnd.cpp b/src/xrGame/ui/UILogsWnd.cpp
index cda3adc..6d1fad1 100644
--- a/src/xrGame/ui/UILogsWnd.cpp
+++ b/src/xrGame/ui/UILogsWnd.cpp
@@ -76,6 +76,16 @@ void CUILogsWnd::Update()
 
 	if (!m_items_ready.empty())
 	{
+		// Sort news by date correctly
+		struct {
+			bool operator()(CUIWindow* x, CUIWindow* y) {
+				CUINewsItemWnd* a = smart_cast<CUINewsItemWnd*>(x);
+				CUINewsItemWnd* b = smart_cast<CUINewsItemWnd*>(y);
+				return a->receive_time > b->receive_time;
+			}
+		} sortNewsDesc;
+		std::sort(m_items_ready.begin(), m_items_ready.end(), sortNewsDesc);
+
 		WINDOW_LIST::iterator it = m_items_ready.begin();
 		WINDOW_LIST::iterator it_e = m_items_ready.end();
 		for (; it != it_e; ++it)
@@ -178,6 +188,14 @@ void CUILogsWnd::ReLoadNews()
 	VERIFY(m_filter_news && m_filter_talk);
 	GAME_NEWS_VECTOR& news_vector = Actor()->game_news_registry->registry().objects();
 
+	// Sort news by date correctly
+	struct {
+		bool operator()(GAME_NEWS_DATA& a, GAME_NEWS_DATA& b) {
+			return a.receive_time < b.receive_time;
+		}
+	} sortNewsDesc;
+	std::sort(news_vector.begin(), news_vector.end(), sortNewsDesc);
+
 	//	u32 currentNews = 0;
 
 	bool filter_news = m_filter_news->GetCheck();
diff --git a/src/xrGame/ui/UINewsItemWnd.cpp b/src/xrGame/ui/UINewsItemWnd.cpp
index 86180d2..2d8eac6 100644
--- a/src/xrGame/ui/UINewsItemWnd.cpp
+++ b/src/xrGame/ui/UINewsItemWnd.cpp
@@ -33,6 +33,7 @@ void CUINewsItemWnd::Init(CUIXml& uiXml, LPCSTR start_from)
 
 void CUINewsItemWnd::Setup(GAME_NEWS_DATA& news_data)
 {
+	receive_time = news_data.receive_time;
 	shared_str time_str = InventoryUtilities::GetTimeAndDateAsString(news_data.receive_time);
 	u32 sz = (time_str.size() + 5) * sizeof(char);
 	PSTR str = (PSTR)_alloca(sz);
diff --git a/src/xrGame/ui/UINewsItemWnd.h b/src/xrGame/ui/UINewsItemWnd.h
index 464c410..e7f0642 100644
--- a/src/xrGame/ui/UINewsItemWnd.h
+++ b/src/xrGame/ui/UINewsItemWnd.h
@@ -2,6 +2,7 @@
 
 #include "UIWindow.h"
 #include "xrUIXmlParser.h"
+#include "../alife_time_manager.h"
 class CUIStatic;
 class CUITextWnd;
 struct GAME_NEWS_DATA;
@@ -15,6 +16,10 @@ class CUINewsItemWnd : public CUIWindow
 	CUITextWnd* m_UIText;
 	CUIStatic* m_UIImage;
 
+	// Store GAME_NEWS_DATA time
+public:
+	ALife::_TIME_ID receive_time = 0;
+
 public:
 	CUINewsItemWnd();
 	virtual ~CUINewsItemWnd();
diff --git a/src/xrServerEntities/script_engine.cpp b/src/xrServerEntities/script_engine.cpp
index 6d36d9e..3e17f3e 100644
--- a/src/xrServerEntities/script_engine.cpp
+++ b/src/xrServerEntities/script_engine.cpp
@@ -13,6 +13,8 @@
 #include "script_process.h"
 #include "../build_config_defines.h"
 #include "script_storage.h"
+#include <unordered_map>
+#include <set>
 
 #ifdef USE_DEBUGGER
 #	ifndef USE_LUA_STUDIO
@@ -282,6 +284,8 @@ void CScriptEngine::setup_auto_load()
 }
 
 extern void export_classes(lua_State* L);
+extern std::unordered_map<std::string, std::set<std::string>> unlocalizers;
+extern bool unlocalizerPassed;
 
 void CScriptEngine::init()
 {
@@ -328,6 +332,8 @@ void CScriptEngine::init()
 #endif // #ifndef USE_LUA_STUDIO
 	//	lua_sethook							(lua(), lua_hook_call,	LUA_MASKLINE|LUA_MASKCALL|LUA_MASKRET,	0);
 
+	unlocalizers.clear();
+	unlocalizerPassed = false;
 	bool save = m_reload_modules;
 	m_reload_modules = true;
 	process_file_if_exists("_G", false);
diff --git a/src/xrServerEntities/script_fvector_script.cpp b/src/xrServerEntities/script_fvector_script.cpp
index 06020de..a1a7aa6 100644
--- a/src/xrServerEntities/script_fvector_script.cpp
+++ b/src/xrServerEntities/script_fvector_script.cpp
@@ -79,6 +79,7 @@ void CScriptFvector::script_register(lua_State* L)
 		.def("dotproduct", &Fvector::dotproduct)
 		.def("crossproduct", &Fvector::crossproduct, return_reference_to(_1))
 		.def("distance_to_xz", &Fvector::distance_to_xz)
+		.def("distance_to_xz_sqr", &Fvector::distance_to_xz_sqr)
 		.def("distance_to_sqr", &Fvector::distance_to_sqr)
 		.def("distance_to", &Fvector::distance_to)
 		//			.def("from_bary",					(Fvector & (Fvector::*)(const Fvector &, const Fvector &, const Fvector &, float, float, float))(&Fvector::from_bary),	return_reference_to(_1))
diff --git a/src/xrServerEntities/script_storage.cpp b/src/xrServerEntities/script_storage.cpp
index 450b304..2d5616e 100644
--- a/src/xrServerEntities/script_storage.cpp
+++ b/src/xrServerEntities/script_storage.cpp
@@ -10,6 +10,10 @@
 #include "script_storage.h"
 #include "script_thread.h"
 #include <stdarg.h>
+#include <unordered_map>
+#include <set>
+#include <sstream>
+#include <regex>
 
 #if !defined(DEBUG) && defined(USE_LUAJIT_ONE)
 #	include "opt.lua.h"
@@ -556,18 +560,27 @@ int __cdecl CScriptStorage::script_log(ScriptStorage::ELuaMessageType tLuaMessag
 	int result = vscript_log(tLuaMessageType, caFormat, marker);
 	va_end(marker);
 
-#ifdef PRINT_CALL_STACK
-#	ifndef ENGINE_BUILD
-    static bool	reenterability = false;
-    if (!reenterability)
-    {
-        reenterability = true;
-        if (eLuaMessageTypeError == tLuaMessageType)
-            ai().script_engine().print_stack();
-        reenterability = false;
-    }
-#	endif //!ENGINE_BUILD
-#endif //-PRINT_CALL_STACK
+	static bool reenterability = false;
+	if (!reenterability)
+	{
+		reenterability = true;
+		if (tLuaMessageType == ScriptStorage::eLuaMessageTypeError)
+			ai().script_engine().print_stack();
+		reenterability = false;
+	}
+
+	// #ifdef PRINT_CALL_STACK
+	// #	ifndef ENGINE_BUILD
+	//     static bool	reenterability = false;
+	//     if (!reenterability)
+	//     {
+	//         reenterability = true;
+	//         if (eLuaMessageTypeError == tLuaMessageType)
+	//             ai().script_engine().print_stack();
+	//         reenterability = false;
+	//     }
+	// #	endif //!ENGINE_BUILD
+	// #endif //-PRINT_CALL_STACK
 
 	return (result);
 }
@@ -680,19 +693,266 @@ bool CScriptStorage::load_buffer(lua_State* L, LPCSTR caBuffer, size_t tSize, LP
 	return (true);
 }
 
+std::unordered_map<std::string, std::set<std::string>> unlocalizers;
+bool unlocalizerPassed = false;
+
+std::vector<std::string> splitStringMulti(std::string& inputString, std::string separator = " ", bool includeSeparators = false) {
+	std::stringstream stringStream(inputString);
+	std::string line;
+	std::vector<std::string> wordVector;
+	while (std::getline(stringStream, line))
+	{
+		std::size_t prev = 0, pos;
+		while ((pos = line.find_first_of(separator, prev)) != std::string::npos)
+		{
+			if (pos > prev)
+				wordVector.push_back(line.substr(prev, pos - prev));
+
+			if (includeSeparators)
+				wordVector.push_back(line.substr(pos, 1));
+
+			prev = pos + 1;
+		}
+		if (prev < line.length())
+			wordVector.push_back(line.substr(prev, std::string::npos));
+	}
+	return wordVector;
+}
+
+std::vector<std::string> splitStringLimit(std::string& inputString, std::string separator = " ", int limit = 0) {
+	std::stringstream stringStream(inputString);
+	std::string line;
+	std::vector<std::string> wordVector;
+	while (std::getline(stringStream, line))
+	{
+		std::size_t prev = 0, pos;
+		while ((pos = line.find_first_of(separator, prev)) != std::string::npos)
+		{
+			if (pos > prev)
+				wordVector.push_back(line.substr(prev, pos - prev));
+
+			prev = pos + 1;
+			if (limit > 0) {
+				if (wordVector.size() >= limit) {
+					wordVector.push_back(line.substr(prev, std::string::npos));
+					return wordVector;
+				}
+			}
+		}
+		if (prev < line.length())
+			wordVector.push_back(line.substr(prev, std::string::npos));
+	}
+	return wordVector;
+}
+
+static std::string join_list(const std::vector<std::string>& items_vec) {
+	std::string ret;
+	for (const auto& i : items_vec) {
+		ret += i;
+	}
+	return ret;
+};
+
+bool unlocalRegex(std::set<std::string>& unlocals, std::string& s, const std::regex pattern, const int group, const std::string replacement) {
+	if (std::regex_match(s, pattern)) {
+		//Msg("matching local function pattern");
+		std::smatch match;
+		std::regex_search(s, match, pattern);
+		std::string variable = match[group];
+		if (unlocals.find(variable) != unlocals.end()) {
+			Msg("found variable %s to unlocal", variable.c_str());
+			s = std::regex_replace(s, pattern, replacement);
+			return true;
+		}
+	} else {
+		return false;
+	}
+	return false;
+};
+
+static void trim(std::string& s, const char* t = " \t\n\r\f\v") {
+	s.erase(s.find_last_not_of(t) + 1);
+	s.erase(0, s.find_first_not_of(t));
+};
+
+
 bool CScriptStorage::do_file(LPCSTR caScriptName, LPCSTR caNameSpaceName)
 {
+	if (!unlocalizerPassed) {
+		auto file_list = FS.file_list_open("$game_config$", "unlocalizers\\", FS_RootOnly | FS_ListFiles);
+		if (!file_list) {
+			unlocalizerPassed = true;
+		} else {
+			xr_string id;
+			auto i = file_list->begin();
+			auto e = file_list->end();
+			for (; i != e; ++i)
+			{
+				u32 length = xr_strlen(*i);
+
+				if (!((length >= 4) &&
+					((*i)[length - 4] == '.') &&
+					((*i)[length - 3] == 'l') &&
+					((*i)[length - 2] == 't') &&
+					((*i)[length - 1] == 'x')))
+					continue;
+
+				id.assign(*i, length - 4);
+
+				string_path file_name;
+				FS.update_path(file_name, "$game_config$", (xr_string("unlocalizers\\") + id).c_str());
+				xr_strcat(file_name, ".ltx");
+
+				Msg("opening file %s", file_name);
+				CInifile* config = CInifile::Create(file_name);
+
+				typedef CInifile::Root sections_type;
+				sections_type& sections = config->sections();
+
+				sections_type::const_iterator i = sections.begin();
+				sections_type::const_iterator e = sections.end();
+				for (; i != e; ++i)
+				{
+					auto sectionName = std::string((*i)->Name.c_str());
+					if (unlocalizers.find(sectionName) == unlocalizers.end()) {
+
+						// construct set that contains top level variables to delocalize by section name
+						unlocalizers[sectionName].clear();
+						Msg("creating unlocalizer for script %s", sectionName.c_str());
+					}
+					auto& data = (*i)->Data;
+					for (auto& item : data) {
+						unlocalizers[sectionName].insert(std::string(item.first.c_str()));
+						Msg("adding variable %s for unlocalizer for script %s", item.first.c_str(), sectionName.c_str());
+					}
+				}
+				CInifile::Destroy(config);
+			}
+			FS.file_list_close(file_list);
+			unlocalizerPassed = true;
+		}
+	}
 	int start = lua_gettop(lua());
 	string_path l_caLuaFileName;
 	IReader* l_tpFileReader = FS.r_open(caScriptName);
+
 	if (!l_tpFileReader)
 	{
 		script_log(eLuaMessageTypeError, "Cannot open file \"%s\"", caScriptName);
 		return (false);
 	}
+
+	// Unlocalize variables in the script defined by unlocalizers map
+	auto scriptContents = static_cast<LPCSTR>(l_tpFileReader->pointer());
+	auto scriptLength = (size_t)l_tpFileReader->length();
+	if (unlocalizers.find(std::string(caNameSpaceName)) != unlocalizers.end()) {
+		Msg("found script %s in unlocalizers data", caNameSpaceName);
+
+		// Get contents of the script file and split by lines
+		std::vector<std::string> tokens;
+		std::string temp;
+		while (!l_tpFileReader->eof())
+		{
+			char c = l_tpFileReader->r_u8();
+			temp += c;
+		}
+
+		std::stringstream stringStream(temp);
+		std::string line;
+		tokens.clear();
+		while (std::getline(stringStream, line)) {
+			tokens.push_back(line);
+		}
+
+		// Iterate lines and unlocalize variables
+		auto& unlocals = unlocalizers[std::string(caNameSpaceName)];
+
+		/*for (auto& u : unlocals) {
+			Msg("%s", u);
+		}*/
+
+		for (auto& s : tokens) {
+
+			//Msg("%s", s.c_str());
+
+			trim(s, "\n\r");
+			if (s.empty()) {
+				continue;
+			}
+
+			std::regex pattern;
+
+			//local function x(a,b,c)
+			pattern = std::regex(R"((^local)([\t ]+)(function)([\t ]+)([_a-zA-Z].*)([\t ]*)(\(.*$))");
+			if (unlocalRegex(unlocals, s, pattern, 5, "$3$4$5$6$7")) {
+				continue;
+			}
+
+			//local a = ...
+			//local a
+			//local a,b,c = ... (if one of a,b,c is in unlocalizers list - all of them will be unlocalized)
+			//local x; local y; - unsupported yet
+			pattern = std::regex(R"((^local)([\t ]+)(.*))");
+			if (std::regex_match(s, pattern)) {
+				std::smatch match;
+				std::regex_search(s, match, pattern);
+				std::string m = match[3];
+
+				// strip comments
+				std::regex r = std::regex(R"((.*)--.*)");
+				if (std::regex_match(m, r)) {
+					//Msg("found comments\n");
+					std::smatch noncomments;
+					std::regex_search(m, noncomments, r);
+					m = noncomments[1];
+				}
+
+
+				auto variablesAndValues = splitStringLimit(m, "=", 1);
+				bool hasValue = variablesAndValues.size() > 1;
+				auto variables = splitStringMulti(variablesAndValues[0], ",");
+				for (auto v : variables) {
+					trim(v);
+					//Msg("%s\n", v.c_str());
+					if (unlocals.find(v) != unlocals.end()) {
+						Msg("found variable %s to unlocal", v.c_str());
+						s = std::regex_replace(s, pattern, "$3");
+						if (!hasValue) {
+
+							// strip comments
+							std::regex r = std::regex(R"((.*)(--.*))");
+							if (std::regex_match(s, r)) {
+								//Msg("found comments\n");
+								std::smatch noncomments;
+								std::regex_search(s, noncomments, r);
+								s = std::string(noncomments[1]) + "= nil " + std::string(noncomments[2]);
+							} else {
+								s += " = nil";
+							}
+						}
+						break;
+					}
+				}
+			}
+		}
+
+		// Store result back
+		for (auto& s : tokens) {
+			s += "\n";
+		}
+
+		/*for (auto& s : tokens) {
+			Msg("%s", s.c_str());
+		}*/
+
+		auto result = join_list(tokens);
+		scriptContents = result.c_str();
+		scriptLength = strlen(scriptContents);
+	}
+
 	strconcat(sizeof(l_caLuaFileName), l_caLuaFileName, "@", caScriptName);
 
-	if (!load_buffer(lua(), static_cast<LPCSTR>(l_tpFileReader->pointer()), (size_t)l_tpFileReader->length(),
+	if (!load_buffer(lua(), scriptContents, scriptLength,
 	                 l_caLuaFileName, caNameSpaceName))
 	{
 		//		VERIFY		(lua_gettop(lua()) >= 4);
diff --git a/src/xrServerEntities/specific_character.cpp b/src/xrServerEntities/specific_character.cpp
index 9029b27..02517bc 100644
--- a/src/xrServerEntities/specific_character.cpp
+++ b/src/xrServerEntities/specific_character.cpp
@@ -5,6 +5,8 @@
 #include "PhraseDialog.h"
 #include "string_table.h"
 
+#include "ai_space.h"
+#include "Script_Game_Object.h"
 
 SSpecificCharacterData::SSpecificCharacterData()
 {
@@ -125,6 +127,32 @@ void CSpecificCharacter::load_shared(LPCSTR)
 		data()->m_ActorDialogs.push_back(dialog_name);
 	}
 
+	luabind::functor<luabind::object> funct;
+	if (ai().script_engine().functor("_G.CSpecificCharacterDialogList", funct))
+	{
+		luabind::object table = luabind::newtable(ai().script_engine().lua());
+		int i = 1;
+		for (auto const &dialog : data()->m_ActorDialogs) {
+			table[i] = dialog.c_str();
+			i++;
+		}
+		auto character_name = item_data.id.c_str();
+		luabind::object output = funct(character_name, table);
+		if (output && output.type() == LUA_TTABLE) {
+			data()->m_ActorDialogs.clear();
+			luabind::object::iterator i = output.begin();
+			luabind::object::iterator e = output.end();
+			for (; i != e; ++i) {
+				luabind::object v = *i;
+				if (v.type() == LUA_TSTRING) {
+					shared_str dialog_name = luabind::object_cast<LPCSTR>(v);
+					//Msg("character_id %s, dialog_name %s", character_name, dialog_name.c_str());
+					data()->m_ActorDialogs.push_back(dialog_name);
+				}
+			}
+		}
+	}
+
 	data()->m_icon_name = pXML->Read("icon", 0, "ui_npc_u_barman");
 
 
@@ -240,6 +268,78 @@ void CSpecificCharacter::load_shared(LPCSTR)
 		MoneyDef().inf_money = false;
 	}
 
+	luabind::functor<luabind::object> init_funct;
+	if (ai().script_engine().functor("_G.CSpecificCharacterInit", init_funct))
+	{
+		luabind::object table = luabind::newtable(ai().script_engine().lua());
+		table["name"] = Name();
+		table["bio"] = Bio().c_str();
+		table["community"] = Community().id().c_str();
+		table["icon"] = data()->m_icon_name.c_str();
+		table["start_dialog"] = data()->m_StartDialog.c_str();
+		table["panic_threshold"] = panic_threshold();
+		table["hit_probability_factor"] = hit_probability_factor();
+		table["crouch_type"] = crouch_type();
+		table["mechanic_mode"] = upgrade_mechanic();
+		table["critical_wound_weights"] = critical_wound_weights();
+		table["supplies"] = SupplySpawn();
+		table["visual"] = Visual();
+		table["npc_config"] = NpcConfigSect();
+		table["snd_config"] = sound_voice_prefix();
+		table["terrain_sect"] = terrain_sect().c_str();
+		table["rank_min"] = RankDef().min;
+		table["rank_max"] = RankDef().max;
+		table["reputation_min"] = ReputationDef().min;
+		table["reputation_max"] = ReputationDef().max;
+		table["money_min"] = MoneyDef().min_money;
+		table["money_max"] = MoneyDef().max_money;
+		table["money_infinitive"] = MoneyDef().inf_money;
+		auto character_name = item_data.id.c_str();
+		luabind::object output = init_funct(character_name, table);
+		if (output && output.type() == LUA_TTABLE) {
+			data()->m_sGameName = luabind::object_cast<LPCSTR>(output["name"]);
+			data()->m_sBioText = CStringTable().translate(luabind::object_cast<LPCSTR>(output["bio"]));
+
+			data()->m_Community.set(luabind::object_cast<LPCSTR>(output["community"]));
+			if (data()->m_Community.index() == NO_COMMUNITY_INDEX)
+				Debug.fatal(DEBUG_INFO, "wrong 'community' '%s' in specific character %s ", luabind::object_cast<LPCSTR>(output["community"]), *m_OwnId);
+
+			data()->m_icon_name = luabind::object_cast<LPCSTR>(output["icon"]);
+			data()->m_StartDialog = output["start_dialog"].type() == LUA_TSTRING ? luabind::object_cast<LPCSTR>(output["start_dialog"]) : NULL;
+			data()->m_fPanic_threshold = luabind::object_cast<float>(output["panic_threshold"]);
+			data()->m_fHitProbabilityFactor = luabind::object_cast<float>(output["hit_probability_factor"]);
+			data()->m_crouch_type = luabind::object_cast<int>(output["crouch_type"]);
+			data()->m_upgrade_mechanic = luabind::object_cast<bool>(output["mechanic_mode"]);
+			data()->m_critical_wound_weights = luabind::object_cast<LPCSTR>(output["critical_wound_weights"]);
+			data()->m_sVisual = luabind::object_cast<LPCSTR>(output["visual"]);
+			data()->m_sNpcConfigSect = luabind::object_cast<LPCSTR>(output["npc_config"]);
+			data()->m_sound_voice_prefix = luabind::object_cast<LPCSTR>(output["snd_config"]);
+			data()->m_terrain_sect = luabind::object_cast<LPCSTR>(output["terrain_sect"]);
+
+			data()->m_sSupplySpawn = luabind::object_cast<LPCSTR>(output["supplies"]);
+			if (!data()->m_sSupplySpawn.empty())
+			{
+				xr_string& str = data()->m_sSupplySpawn;
+				xr_string::size_type pos = str.find("\\n");
+				while (xr_string::npos != pos)
+				{
+					str.replace(pos, 2, "\n");
+					pos = str.find("\\n", pos + 1);
+				}
+			}
+
+			RankDef().min = _min(luabind::object_cast<int>(output["rank_min"]), luabind::object_cast<int>(output["rank_max"]));
+			RankDef().max = _max(luabind::object_cast<int>(output["rank_min"]), luabind::object_cast<int>(output["rank_max"]));
+
+			ReputationDef().min = _min(luabind::object_cast<int>(output["reputation_min"]), luabind::object_cast<int>(output["reputation_max"]));
+			ReputationDef().max = _max(luabind::object_cast<int>(output["reputation_min"]), luabind::object_cast<int>(output["reputation_max"]));
+
+			MoneyDef().min_money = _min(luabind::object_cast<int>(output["money_min"]), luabind::object_cast<int>(output["money_max"]));
+			MoneyDef().max_money = _max(luabind::object_cast<int>(output["money_min"]), luabind::object_cast<int>(output["money_max"]));
+			MoneyDef().inf_money = luabind::object_cast<bool>(output["money_infinitive"]);
+		}
+	}
+
 #endif
 
 #if 0
diff --git a/src/xrSound/Sound.h b/src/xrSound/Sound.h
index eeb6d58..07237c7 100644
--- a/src/xrSound/Sound.h
+++ b/src/xrSound/Sound.h
@@ -36,6 +36,7 @@ XRSOUND_API extern u32 psSoundModel;
 XRSOUND_API extern float psSoundVEffects;
 XRSOUND_API extern float psSoundVFactor;
 XRSOUND_API extern float psSoundVMusic;
+XRSOUND_API extern float psSoundVMusicFactor;
 XRSOUND_API extern float psSoundRolloff;
 XRSOUND_API extern float psSoundOcclusionScale;
 XRSOUND_API extern Flags32 psSoundFlags;
@@ -212,17 +213,72 @@ class XRSOUND_API CSound_environment
 public:
 };
 
+namespace soundSmoothingParams {
+	extern float power;
+	extern int steps;
+	extern float alpha;
+	extern float getAlpha();
+	extern float getTimeDeltaSmoothing();
+	extern float getSmoothedValue(float, float, float);
+};
+
 /// definition (Sound Params)
 class XRSOUND_API CSound_params
 {
+public:
+	CSound_params() :
+		set(false)
+		{
+			position.set(0.0f, 0.0f, 0.0f);
+			velocity.set(0.0f, 0.0f, 0.0f);
+			accVelocity.set(0.f, 0.f, 0.f);
+		}
+
+private:
+	bool set;
+
 public:
 	Fvector position;
+	Fvector velocity;  // Cribbledirge.  Added for doppler effect.
+	Fvector curVelocity;  // Current velocity.
+	Fvector prevVelocity;  // Previous velocity.
+	Fvector accVelocity;  // Velocity accumulator (for moving average).
 	float base_volume;
 	float volume;
 	float freq;
 	float min_distance;
 	float max_distance;
 	float max_ai_distance;
+
+	// Functions added by Cribbledirge for doppler effect.
+	IC virtual void update_position(const Fvector& newPosition)
+	{
+		// If the position has been set already, start getting a moving average of the velocity.
+		if (set)
+		{
+			prevVelocity.set(accVelocity);
+			curVelocity.sub(newPosition, position);
+
+			//accVelocity.set(curVelocity.mul(alpha).add(prevVelocity.mul(1.f - alpha)));
+		}
+		else
+		{
+			set = true;
+		}
+		position.set(newPosition);
+	}
+
+	IC virtual void update_velocity(const float dt)
+	{
+		float a = soundSmoothingParams::getTimeDeltaSmoothing();
+		int p = soundSmoothingParams::power;
+		accVelocity.x = soundSmoothingParams::getSmoothedValue(curVelocity.x * p / dt, accVelocity.x, a);
+		accVelocity.y = soundSmoothingParams::getSmoothedValue(curVelocity.y * p / dt, accVelocity.y, a);
+		accVelocity.z = soundSmoothingParams::getSmoothedValue(curVelocity.z * p / dt, accVelocity.z, a);
+		velocity.set(accVelocity);
+
+		//Msg("VELOC: %f", velocity.magnitude());
+	}
 };
 
 /// definition (Sound Interface)
diff --git a/src/xrSound/SoundRender_Core.cpp b/src/xrSound/SoundRender_Core.cpp
index 203aeb3..3caa495 100644
--- a/src/xrSound/SoundRender_Core.cpp
+++ b/src/xrSound/SoundRender_Core.cpp
@@ -17,6 +17,7 @@ float psSoundVEffects = 1.0f;
 float psSoundVFactor = 1.0f;
 
 float psSoundVMusic = 1.f;
+float psSoundVMusicFactor = 1.f;
 int psSoundCacheSizeMB = 32;
 
 CSoundRender_Core* SoundRender = 0;
diff --git a/src/xrSound/SoundRender_CoreA.cpp b/src/xrSound/SoundRender_CoreA.cpp
index 4301be7..a90e63c 100644
--- a/src/xrSound/SoundRender_CoreA.cpp
+++ b/src/xrSound/SoundRender_CoreA.cpp
@@ -7,6 +7,22 @@
 #include "../xrEngine/pure.h"
 #include "../xrEngine/XR_IOConsole.h"
 
+namespace soundSmoothingParams {
+	float power = 1.8;
+	int steps = 15;
+	float alpha = getAlpha();
+	IC float getAlpha() {
+		return 2.0f / (steps + 1);
+	}
+	IC float getTimeDeltaSmoothing() {
+		return alpha;
+		//return min(1.0f, alpha * (Device.fTimeDelta / steps));
+	}
+	IC float getSmoothedValue(float target, float current, float smoothing = getTimeDeltaSmoothing()) {
+		return current + smoothing * (target - current);
+	}
+};
+
 extern CConsole* Console;
 
 CSoundRender_CoreA* SoundRenderA = 0;
@@ -148,6 +164,14 @@ void CSoundRender_CoreA::_initialize(int stage)
 		bEAX = EAXTestSupport(FALSE);
 	}
 
+	// Init listener struct
+	Listener.position.set(0.0f, 0.0f, 0.0f);
+	Listener.prevVelocity.set(0.0f, 0.0f, 0.0f);
+	Listener.curVelocity.set(0.0f, 0.0f, 0.0f);
+	Listener.accVelocity.set(0.0f, 0.0f, 0.0f);
+	Listener.orientation[0].set(0.0f, 0.0f, 0.0f);
+	Listener.orientation[1].set(0.0f, 0.0f, 0.0f);
+
 	inherited::_initialize(stage);
 
 	if (stage == 1) //first initialize
@@ -218,6 +242,18 @@ void CSoundRender_CoreA::update_listener(const Fvector& P, const Fvector& D, con
 {
 	inherited::update_listener(P, D, N, dt);
 
+	Listener.curVelocity.sub(P, Listener.position);
+
+	float a = soundSmoothingParams::getTimeDeltaSmoothing();
+	int p = soundSmoothingParams::power;
+	Listener.accVelocity.x = soundSmoothingParams::getSmoothedValue(Listener.curVelocity.x * p / dt, Listener.accVelocity.x, a);
+	Listener.accVelocity.y = soundSmoothingParams::getSmoothedValue(Listener.curVelocity.y * p / dt, Listener.accVelocity.y, a);
+	Listener.accVelocity.z = soundSmoothingParams::getSmoothedValue(Listener.curVelocity.z * p / dt, Listener.accVelocity.z, a);
+	
+	Listener.prevVelocity.set(Listener.accVelocity);
+
+	// Msg("listener sound update delta %.3f, velocity %.3f, %.3f, %.3f, power %.1f, alpha %.3f", dt, Listener.prevVelocity.x, Listener.prevVelocity.y, Listener.prevVelocity.z, soundSmoothingParams::power, soundSmoothingParams::alpha);
+
 	if (!Listener.position.similar(P))
 	{
 		Listener.position.set(P);
@@ -227,6 +263,6 @@ void CSoundRender_CoreA::update_listener(const Fvector& P, const Fvector& D, con
 	Listener.orientation[1].set(N.x, N.y, -N.z);
 
 	A_CHK(alListener3f (AL_POSITION,Listener.position.x,Listener.position.y,-Listener.position.z));
-	A_CHK(alListener3f (AL_VELOCITY,0.f,0.f,0.f));
+	A_CHK(alListener3f (AL_VELOCITY, Listener.prevVelocity.x, Listener.prevVelocity.y, -Listener.prevVelocity.z));
 	A_CHK(alListenerfv (AL_ORIENTATION,&Listener.orientation[0].x));
 }
diff --git a/src/xrSound/SoundRender_CoreA.h b/src/xrSound/SoundRender_CoreA.h
index e0eaabd..81d81c3 100644
--- a/src/xrSound/SoundRender_CoreA.h
+++ b/src/xrSound/SoundRender_CoreA.h
@@ -26,6 +26,9 @@ class CSoundRender_CoreA : public CSoundRender_Core
 	struct SListener
 	{
 		Fvector position;
+		Fvector prevVelocity;
+		Fvector curVelocity;
+		Fvector accVelocity;
 		Fvector orientation[2];
 	};
 
diff --git a/src/xrSound/SoundRender_Emitter.cpp b/src/xrSound/SoundRender_Emitter.cpp
index fa6be85..425130f 100644
--- a/src/xrSound/SoundRender_Emitter.cpp
+++ b/src/xrSound/SoundRender_Emitter.cpp
@@ -12,7 +12,7 @@ extern float psSoundVEffects;
 void CSoundRender_Emitter::set_position(const Fvector& pos)
 {
 	if (source()->channels_num() == 1)
-		p_source.position = pos;
+		p_source.update_position(pos);
 	else
 		p_source.position.set(0, 0, 0);
 
diff --git a/src/xrSound/SoundRender_Emitter_FSM.cpp b/src/xrSound/SoundRender_Emitter_FSM.cpp
index 87a6824..23141fe 100644
--- a/src/xrSound/SoundRender_Emitter_FSM.cpp
+++ b/src/xrSound/SoundRender_Emitter_FSM.cpp
@@ -68,7 +68,7 @@ void CSoundRender_Emitter::update(float dt)
 		occluder_volume = SoundRender->get_occlusion(p_source.position, .2f, occluder);
 		smooth_volume = p_source.base_volume * p_source.volume * (owner_data->s_type == st_Effect
 			                                                          ? psSoundVEffects * psSoundVFactor
-			                                                          : psSoundVMusic) * (b2D ? 1.f : occluder_volume);
+			                                                          : psSoundVMusic * psSoundVMusicFactor) * (b2D ? 1.f : occluder_volume);
 		e_current = e_target = *SoundRender->get_environment(p_source.position);
 		if (update_culling(dt))
 		{
@@ -94,7 +94,7 @@ void CSoundRender_Emitter::update(float dt)
 		occluder_volume = SoundRender->get_occlusion(p_source.position, .2f, occluder);
 		smooth_volume = p_source.base_volume * p_source.volume * (owner_data->s_type == st_Effect
 			                                                          ? psSoundVEffects * psSoundVFactor
-			                                                          : psSoundVMusic) * (b2D ? 1.f : occluder_volume);
+			                                                          : psSoundVMusic * psSoundVMusicFactor) * (b2D ? 1.f : occluder_volume);
 		e_current = e_target = *SoundRender->get_environment(p_source.position);
 		if (update_culling(dt))
 		{
@@ -297,7 +297,7 @@ BOOL CSoundRender_Emitter::update_culling(float dt)
 		float fade_scale = bStopping || (att * p_source.base_volume * p_source.volume * (owner_data->s_type == st_Effect
 			                                                                                 ? psSoundVEffects *
 			                                                                                 psSoundVFactor
-			                                                                                 : psSoundVMusic) <
+			                                                                                 : psSoundVMusic * psSoundVMusicFactor) <
 			                   psSoundCull)
 			                   ? -1.f
 			                   : 1.f;
@@ -313,7 +313,7 @@ BOOL CSoundRender_Emitter::update_culling(float dt)
 	clamp(fade_volume, 0.f, 1.f);
 	// Update smoothing
 	smooth_volume = .9f * smooth_volume + .1f * (p_source.base_volume * p_source.volume * (
-			owner_data->s_type == st_Effect ? psSoundVEffects * psSoundVFactor : psSoundVMusic) * occluder_volume *
+			owner_data->s_type == st_Effect ? psSoundVEffects * psSoundVFactor : psSoundVMusic * psSoundVMusicFactor) * occluder_volume *
 		fade_volume);
 	if (smooth_volume < psSoundCull) return FALSE; // allow volume to go up
 	// Here we has enought "PRIORITY" to be soundable
@@ -333,6 +333,9 @@ float CSoundRender_Emitter::priority()
 
 void CSoundRender_Emitter::update_environment(float dt)
 {
-	if (bMoved) e_target = *SoundRender->get_environment(p_source.position);
+	if (bMoved) {
+		e_target = *SoundRender->get_environment(p_source.position);
+		p_source.update_velocity(dt);
+	}
 	e_current.lerp(e_current, e_target, dt);
 }
diff --git a/src/xrSound/SoundRender_TargetA.cpp b/src/xrSound/SoundRender_TargetA.cpp
index ef418a7..f3bcdab 100644
--- a/src/xrSound/SoundRender_TargetA.cpp
+++ b/src/xrSound/SoundRender_TargetA.cpp
@@ -154,6 +154,9 @@ void CSoundRender_TargetA::fill_parameters()
 	A_CHK(alSource3f(pSource, AL_POSITION, m_pEmitter->p_source.position.x,m_pEmitter->p_source.position.y,-m_pEmitter->
 		p_source.position.z));
 
+	VERIFY2(m_pEmitter, SE->source()->file_name());
+	A_CHK(alSource3f(pSource, AL_VELOCITY, m_pEmitter->p_source.velocity.x, m_pEmitter->p_source.velocity.y, -m_pEmitter->p_source.velocity.z));
+
 	VERIFY2(m_pEmitter, SE->source()->file_name());
 	A_CHK(alSourcei (pSource, AL_SOURCE_RELATIVE, m_pEmitter->b2D));
 
diff --git a/src/xrXMLParser/xrXMLParser.cpp b/src/xrXMLParser/xrXMLParser.cpp
index 1d69c77..1cde914 100644
--- a/src/xrXMLParser/xrXMLParser.cpp
+++ b/src/xrXMLParser/xrXMLParser.cpp
@@ -3,6 +3,7 @@
 
 #include "xrXMLParser.h"
 
+extern void XMLLuaCallback(CXml &m_xml, LPCSTR xml_string);
 
 XRXMLPARSER_API CXml::CXml()
 	: m_root(NULL),
@@ -138,6 +139,21 @@ void CXml::Load(LPCSTR path, LPCSTR xml_filename)
 		R_ASSERT2(false, str);
 	}
 
+	m_root = m_Doc.FirstChildElement();
+	XMLLuaCallback(*this, (LPCSTR)W.pointer());
+}
+
+void CXml::LoadFromString(LPCSTR xml_string)
+{
+	ClearInternal();
+	m_Doc.Parse(&m_Doc, xml_string);
+	if (m_Doc.Error())
+	{
+		string1024 str;
+		xr_sprintf(str, "XML file:%s value:%s errDescr:%s", m_xml_file_name, m_Doc.Value(), m_Doc.ErrorDesc());
+		R_ASSERT2(false, str);
+	}
+
 	m_root = m_Doc.FirstChildElement();
 }
 
diff --git a/src/xrXMLParser/xrXMLParser.h b/src/xrXMLParser/xrXMLParser.h
index 3a13303..fcdc789 100644
--- a/src/xrXMLParser/xrXMLParser.h
+++ b/src/xrXMLParser/xrXMLParser.h
@@ -31,7 +31,7 @@ public:
 	void ClearInternal();
 
 	void Load(LPCSTR path_alias, LPCSTR path, LPCSTR xml_filename);
-
+	void LoadFromString(LPCSTR xml_string);
 
 	// 
 	LPCSTR Read(LPCSTR path, int index, LPCSTR default_str_val);
